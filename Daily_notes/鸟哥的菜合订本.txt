<<<<<<< HEAD
《鸟哥的linux私房菜》http://linux.vbird.org/linux_basic/centos5.php
***********************************第1章 linux是什么***********************************************************************
硬件->内核->系统调用->应用程序   内核和系统调用两者组成操作系统
linux distribution：Redhat Fedora Centos 等
其实Linux是指的系统的内核，不能认为是一个系统。有人在内核的基础上增加一些软件，就成了一个操作系统了。

***********************************第3章 磁盘分区**********************************************************************************
主分区P、扩展分区E（最多有一个扩展分区，扩展分区又可以分出逻辑分区L号码由5号开始）
扩展分区的目的是使用额外的扇区来记录分区信息,扩展分区本身并不能被拿来格式化。
逻辑分区的数量依据操作系统而不同,在Linux系统中,IDE硬盘最多有59个逻辑分区(5号到63号),SATA硬盘则有11个逻辑
分区(5号到15号)。

/dev/hda[1-4]前四个号码都是保留给主分区或扩展分区使用,所以逻辑分区的设备名称号码就由5号开始。

两者最多有四个,分区最小单位是柱面
扇区为最小物理存储单位，每个扇区为512bytes
将扇区组成一个圆，那就是柱面（cylinder），柱面是分区（partition）的最小单位
/dev/sd[a-p][1-15]：为SCSI，SATA,USB,Flash等接口的磁盘文件名
/dev/hd[a-d][1-63]: 为IDE接口的磁盘文件名

各硬件设备在Linux中的文件名:
IDE硬盘:/dev/hd[a-d]      CD ROM/DVD ROM:/dev/cdrom    25针打印机:/dev/lp[0-2]、USB打印机:/dev/usb/lp[0-15]
SCSI/SATA/USB硬盘/U盘:/dev/sd[a-p]   软盘:/dev/fd[0-1]   USB鼠标:/ddev.usb/mouse[0-15]、PS2鼠标:/dev/psaux
IDE磁带机:/dev/ht0、SCSI磁带机:/dev/st0

文件系统通常会将权限与属性放置到inode中，而实际数据则放置到data block块中，还有一个超级块
会记录整个文件系统的整体信息，包括inode与block的总量、使用量、余额量等

所谓的磁盘分区就是指告诉操作系统"我这块磁盘在此分区可以访问的区域是由A柱面到B柱面之间的块"
通常我们可以称呼一个可以挂载的数据为一个文件系统而不是分区

CMOS是记录各项硬件参数且嵌入在主板上面的存储器，BIOS则是一个写入主板的一个韧体（韧体就是写入到
硬件的一个软件程序）接下来BIOS会去分析计算机里面有哪些存储设备，并取得能够开机的硬盘，并到该硬
盘里面去读取第一个扇区的MBR,MBR这个仅446bytes容量里会放置最基本的引导加载程序，这个程序目的是
加载内核文件。

BIOS->MBR（主引导分区）->引导加载程序（boot loader）->内核文件
BIOS和MBR都是硬件本身支持的功能，boot loader是MBR上面的一套软件

***********************************第4章 安装小技巧**************************************************************************
swap:内存交换空间。由于swap并不会使用到目录树的挂载，所以swap就不需要指定挂载点
磁盘阵列（saftware RAID） /dev/md[0-15]
引导装载程序grub，安装时最好选择安装在设备MBR中
若笔记本安装失败，可以尝试在开机时加入"inux nofb apm=off acpi=off"来关闭省电功能
设置时不要选择启动kdump，那是供开发者查阅司机数据的。kdump就是当内核发送错误时,是否要将当时的内存内的信息
写到文件中,而这个文件就能够给内核开发者研究为什么会宕机。

新主机仅有一块硬盘：使用windows XP光盘启动安装，安装分区，再将XP安装到C盘，再来安装linux
旧主机有两块以上硬盘
旧主机仅有一块硬盘：window和linux不能共存在同一个分区，所以要清出来一块分区

GMT时间:格林尼治时间,比上海时间晚了8个小时。

***********************************第5章 在线求助**********************************************************************************
目前,CentOS默认至少提供GNOME/KDE这两种图形界面(我们称窗口管理员,Window Manager)。
注销并不是关机,只是让你的账号离开系统而已。

X Window与命令行模式的切换:
Linux默认情况下会提供6个Terminal终端界面来让用户登录，切换方式是Ctrl+Alt+F1~F6
Ctrl+Alt+F1~F6 为tty1~tty6的操作界面环境（运行等级run level 3）
Ctrl+Alt+F7 为图形界面桌面（运行等级run level 5）
tty7 就是开机完成后默认等待登录的图形环境
tty也就是teletypewriter。tty1～6六个文字界面终端,tty7图形界面终端,tty8系统信息。

如果你是以纯文本环境启动Linux的,默认tty7是没有东西的,万一如此的话,那怎么启动X窗口界面呢？你可以在tty1~tty6
的任意的一个终端界面使用你的账号登录后,然后执行如下命令:startx
不过startx生效必须要以下事情的配合:1.你的tty7并没有其他的窗口软件正在运行；
                                   2.你安装了X Window系统,并且X Server是能够顺利启动的；
                                   3.你最好有窗口管理员；
                                   4.启动X窗口所必须的服务,例如字型服务器(XFS)必须要先启动；

显示日期的命令: date +%Y/%m/%d 年月日   date +%H:%M:%s 时分秒

command [-options] parameter1 parameter2 ...

Tab键具有"命令补全"和"文件补全"的功能，可以避免我们打错命令或文件名。
例：命令（cat）[Tab][Tab] 即Tab接在一串命令的第一个命令后面，则为"命令补全"，可以查看以命令
   （cat）开头的命令。
    命令（ls) [-options选项 例：-al]  parameterl（参数 例:~/.bash ）[tab][tab] 即Tab接在一串
    命令的第二个命令以后时，则为"文件补全"，表示在该目录下面所有以.bash为开头的文件名都被显
    示出来了。

ctrl+c中断目前程序； ctrl+d键盘输入结束代替exit ；ctrl+z挂起,fg返回；
man page ： 在线求助         显示内容的文件放在/user/share/man 与 /user/local/man
	NAME         这个命令完整全名
                SYNOPSIS     这个命令的基本用法
	DESCRIPTION  详细说明刚才语法谈到的参数的用法
	ENVIRONMENT  这个命令相关的环境参数说明

man -k 命令 :为查询关键字  
man -K 命令 :则是整个系统的man page查询，每个被检查到有关键字的man page file都会询问是否有要显示,你可以
             输入[ynq],y表示显示到屏幕,n表示不显示,q结束man的查询。
man -f  命令         查询与命令有换的说明文件 也可写whatis
man -k  命令         查询含有命令关键字的文件 也可以apropos
两个特殊命令要使用需要创建whatis数据库，必须以root身份执行makewhatis命令。
帮助文件放在/user/share/doc目录
如果你想知道某些关键字的话,那么可以在任何时候输入"/word"来主动查找关键字。

在man page显示的内容中，指令后面接一组章节数字（1/5/8/...）
1表示的是一般用户可使用的命令；3表示一些常用的函数与函数库；5表示的是配置文件或某些格式文件 ；
7表示惯例与协议；              8表示的是系统管理员可用的指令...
例如你执行了"man date",会出现在第一行的是DATE(1),则代表的是一般用户可使用的命令。

也可以这样输入命令：“man [章节号] 手册名称”
例如：
man 1 time （或 man time） 就是查看 time 系统命令；
man 2 time 就是查看C函数 time_t time(time_t *t); 的定义
查询crontab指令可以使用man crontab,至于查询/etc/crontab则可以使用man 5 crontab.

whatis [命令或者数据] <==相当于 man -f [命令或者数据]
apropos [命令或这数据] <==相当于man -k [命令或者数据]

info page：linux中额外的在线求助方法

当输入命令后出现乱码：默认中文编码无法输出数据，输入LANG=en_US，echo $LANG查看更改

超简单文本编辑器：nano
^代表ctrl键  M代表ALT键
^G	取得在线帮助 
^X	离开nano软件，若有修改过文件会提示是否保存
^O	保存文件，若有权限的话就能保存文件
^R	从其他文件读入数据，可以将摸个文件的内容粘贴在本文件中。
^W	查询字符串。
^C	说明目前光标所在处的行数和列数等信息
^_	可以直接输入行号，让光标快速移动到该行
M+Y 	校正语法功能开启或关闭
M+M	可以支持鼠标来移动光标的功能

*的用法：比如当前目录下有abc.c、abdd.c、abeff.c。可以用ls ab*.c来查看。
\的用法：比如一行不够没有打完，在后面打上\接enter，在下一行就能继续输入。

数据同步写入磁盘：sync(将内存中尚未被跟新的数据写入硬盘,防止不正常关机导致的数据丢失)

X window重启而不是linux重启ctrl+alt+backspace

正确的关机方法：
如果查看目前有谁在线，可以执行who命令，如果要查看网络的联机状态，可以执行netstat -a命令，
而要看后台执行的程序可以执行ps -aux命令。
将数据同步写入硬盘的命令：sync 
惯用的关机命令：shutdown
重启，关机：reboot，halt，poweroff

惯用的关机命令:/sbin/shutdown [-t秒] [-arkhncfF] 时间 [警告信息]

切换执行等级：init
linux共有七个执行等级，下面是其中五个：
run level 0 关机
run level 1 单用户模式,与Win9x下的安全模式类似
run level 2 基本多用户模式，没有 NFS 支持
run level 3 纯命令行模式,完整的多用户模式,是标准的运行级
run level 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。
run level 5 含有图形界面模式,就是X11,进到XWindow系统了
run level 6 重启

开机过程的问题排解
 如果根目录没有损坏:输入"fsck/错误分区位置"
 如果根目录损坏了：将硬盘拔掉，接在另一台linux上，不要挂载，以root身份执行"fsck/dev/sdb1 "
 （dev/sdb1指的是硬盘设备文件名）

忘记root密码:你只要以单用户维护模式登录即可更改你的root账号密码。

例题:1.由于反斜杠(\)的英文为"escape",因此在上个步骤的man环境中,你可以使用"/escape"来查询各反斜杠后面接的
       字符所代表的意义。
     2.如果我想要在/etc/issue文件内表示时间与tty好吗的话,应该找到哪个字符来表示(通过反斜杠功能)?答案:\t与\l
     

***************************************第6章 文件权限与目录配置**************************************************************
[权限][连接][所有者][用户组][文件容量][修改日期][文件名]                 所有者 用户组 其他

ls -al：表示列出所有文件详细权限与属性
[权限]：-rwxrwx---      rwx为读、写、执行 4 2 1
     ①第一个字符代表这个文件是"目录、文件、或链接文件等"。
      若是[d]则是目录，若是[-]则是文件，若是[L]则是链接文件linkfile，若是[b]则表示设备文件里面
      的可供存储的接口设备，若是[c]则表示设备文件里面的串行端口设备，例如键盘、鼠标。
     ②接下来的字符以三个为一组，第一组为文件所有者的权限，
                                 第二组为同用户组的权限，
                                 第三组为其他非本用户组的权限。
[连接]：表示有多少文件名连接到此节点（i-node） 连接文件相当于快捷方式的作用，但文件名又有不同
[文件名]：如果文件名之前多了一个"."表示为隐藏文件。      

chgrp [-R] dirname/filename....             <==改变文件所属用户组
要改变的组名必须要在/etc/group文件内存在才行

chown [-R] 账号名称:组名 文件或目录         <== 改变文件所有者
例：将install.log所有者改为bin这个账号  chown bin install.log
    将install.log所有者与用户组改回root chown root:root install.log 
    将install.log所有组改为sshd这个组   chown .sshd install.log
chmod [-R] xyz 文件或目录                   <==改变文件的权限
cp 源文件 目标文件 
chomd a代表all u代表user g代表group o代表others
      添加权限 例:增加.bashrc这个文件么每个人均可写入的权限chmod a+w .bashrc
      权限针对文件的重要性：其中的w不具备删除文件本身的权限。
      权限针对目录的重要性：r具有读取目录结构列表的权限。
                            w具有更改目录结构列表的权限,可以删除已经存在的文件与目录(无论该文件权限为何)。
                            x代表用户能否进入该目录成为工作目录的用途。如果只开放了r权限，将会
			    导致无法到目录下读取文件（最多只能看到文件名），无法查阅到文件的内
			    容。要注意，要开放目录给任何人浏览，至少应该要给r及x的权限，w不可随
                            便给。
工作目录（用cd进入该目录）			   

设备与设备文件： 块（block）设备文件：存储数据，以提供系统随机访问的接口设备，例如硬盘，软盘。
    		 字符（character）设备文件：串口的接口设备，例如键盘，鼠标。
套接字（sockets）：既然被称作数据接口文件，这种数据文件通常被用在网络的数据连接。
管道（FIFO，pipe）：主要解决多个程序同时访问一个文件造成的错误问题。

linux目录配置标准:FHS标准---主要目的是希望让用户可以了解到已安装软件通常放置于哪个目录下
/（root，根目录）：与开机系统有关； 越小越好，且应用程序所安装的软件最好不要与根目录放在同一个
				    分区。
/usr（UNIX software resource）：UNIX操作系统软件资源所放置的目录，与软件安装/执行有关
				 而不是用户目录
/var（variable）：与系统运作过程有关
/lost+found  这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发
             生错误时，将一些丢失的片段放在这个目录下。
/proc   这个目录本身是一个虚拟文件系统。它放置的数据都是在内存当中。例如系统内核、进程、外部设备
        的状态及网络状态等。
/sys    这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。

.：代表当前目录，也可以用./来表示
..：表示上一层目录，也可以../来表示   你常常会看到cd..或./command就是代表上一层与目前所在目录的
                                      工作状态。
例子：如何先进入/var/spool/mail目录在进到/var/spool/cron/目录内？
      1.cd/var/spool/mail 
      2.cd../cron              相对路径的应用

查看linux标准与内核   uname -r
                      lsb_release -a

目录的相关操作： 比较特殊的目录： . 代表此层目录  .. 代表上层目录 -代表前一个工作目录
				  ~ 代表目前用户身份 ~account 代表account这个用户的主文件夹

例题:1.FHS制定出来的四种目录特色为shareable、unshareable、staric、variable。
     2.FHS所定义的三层主目录为/、/var、/usr。
     3.有五个目录不可与根目录放在不同的分区,分别为/etc、/bin、/lib、/dev、/sbin五个。
     4./bin放置的是一般使用者惯用的指令,至于/sbin则是系统管理员才会使用的指令。

***************************************第7章 文件与目录管理*********************************************************************************
1.目录的相关操作:
  . 代表此层目录 ； .. 代表上一层目录 ； - 代表前一个工作目录 ； ~ 代表"目前用户身份"所在的主文件夹 ；

pwd 显示目前所在目录 [-p]显示当前目录而非用连接路径

创建/删除一个目录：
mkdir [-mp] 目录名称 -m：配置文件案的权限 mkdir -m 711 test2
                     -p：帮助你直接将所需的目录（包含上层目录）递归创建起来/即可以创建多层目录
                         mkdir -p text1/text2/text3
rmdir [-p] 目录名称  删除空的目录 仅能删除空的目录
echo 显示、打印  $表示后面接的是变量

2.执行文件路径的变量 ：$PATH 
环境变量PATH这个变量内容是由一堆目录所组成的！
各个命令相当于在PATH内创建了快捷方式，随着目录的更改，这些快捷方式会失效，因此也可以在PATH添加这些
"快捷方式"，输入PATH="$PATH"/命令所在位置。因此使用绝对路径直接指定某个命令的文件名来执行会比查询
PATH来得正确。
例:将/root目录加入PATH当中: PATH="$PATH":/root

查看文件和目录：
ls [-aAdfFhilnrRSt] 目录名称   /   ls [--color={never,auto,always}] 目录名称 
ls [--full-time] 目录名称
-F：根据文件、目录等信息给予附加数据结构，例如：*代表可执行文件   /：代表目录 
					        =：代表socket文件 |：代表FIFO文件
-l：列出长数据串，包含文件属性与权限等数据 ll命令相当于 ls -l
-i：列出inode号码  /  -d：列出目录本身，而不是列出目录内的文件数据
蓝色显示目录，白色显示一般文件

复制文件或目录：
cp [-adfilprsu] 源文件（source） 目标文件（destination）
-a：相当于下面-p+d+r的意思 
-d: 若源文件为连接文件的属性（link file），则复制连接文件属性而非文件本身
-p：连同文件属性一起复制过去，而非使用默认属性（备份常用）
-u：在目标文件与源文件有差异时才会复制（备份常用）
-r：递归持续复制，用于目录的复制行为 
-s：复制成为符号链接（symbolic link）/软连接文件,即"快捷方式"文件；
-l：进行硬链接（hard link）的连接文件的创建，而非复制文件本身。与i-node节点有关。
要想复制到当前目录（先cd到目录），最后的"."不要忘

移除目录或文件：rm命令
rm [-fir] 文件或目录
-r：递归删除，最常用在目录的删除。
如果确定要删除目录而不要询问，在命令前加上反斜杠，可以忽略alias的指定参数。

移动文件或目录，或更名：mv命令
mv [-fiu] 源文件（source） 目标文件（destination）

取得路径的文件名与目录名称
basename：取得最后的文件名   dirname：取得最后的目录名

cat：由第一行开始显示文件内容 cat[-AbEnTv] /  tac：从最后一行开始显示
-A:相当于-v+E+T的整合参数，可列出一些特殊字符，而不是空白而已
-b：列出行号，仅针对非空白行做行号显示，空白行不标行号
-E：将结尾的 [断行字符$] 显示出来
-n: 打印出行号，连同空白行也会有行号
-T：将 [Tab键] 以^I显示出来
-v： 列出一些看不出来的特殊字符

nl：添加行号打印  nl[-bnw] 文件

more/less:一页一页地显示文件内容，less可以向前翻页
Enter ：代表向下滚动一行  /   空格键 ：代表向下翻一页
/字符串 ：代表在显示的内容当中，向下查询字符串这个关键字，重复前一个查询n
?字符串 ：代表向上查询字符串，反向重复前一个查询N
:f :立即显示文件名一级目前显示的行数 /  q ：代表立即离开more，不在显示该文件内容
b或ctrl+b ：代表往回翻页，不过这操作只对文件有用，对管道无用

head：取出前面几行  head [-n number] 文件
tail：取出后面几行  tail [-n number] 文件 

od：以二进制的方式读取文件内容   od [-t TYPE] 文件
TYPE: a: 利用默认字符输出 / c:使用ASCII字符输出 / d：利用十进制来输出 / f：利用浮点数来输出
      o：利用八进制来输出数据 / x：利用十六进制来输出数据

修改文件时间或创建新文件:touch
--time=mtime （modification time）内容数据（指的是文件的内容）更改时，就会更新这个时间
--time=ctime （status time）文件的状态（权限与属性）更改时，就会更新这个时间
--time=atime （access time）文件内容被取用（被命令读取）时，就会更改这个时间

touch [-acdmt] 文件
-a：仅修改访问时间 / -c：仅修改文件时间 
-d：后面可以接欲修改的日期而不用目前的日期 也可使用 --date="日期或时间"
-t：仅修改mtime / t：后面可以接欲修改的时间而不用目前的时间 格式为：[YYMMDDhhmm]

；代表连续命令的执行，可以在一行命令当中写入多条命令

文件默认权限-- umask [-s]  / umask的分数指的是该默认值需要减去的权限 /修改默认 umask 数字
用户创建文件默认没有可执行（x）权限，创建目录默认所有权限开放
例：022代表 user没有被拿走任何权限，group与others的权限被拿走了2（也就是w这个权限）
    新建文件时：（-rw-rw-rw-）-（-----w--w-）==>-rw-r--r--

3.文件与目录的默认权限与隐藏属性
设置文件隐藏属性（只能在Ext2/Ext3的文件系统上面生效）
chattr [+-=] [Asacdistu] 文件或目录名称
a：当设置a之后，这个文件将只能增加数据，不能修改和删除数据，只有root才能设置这个属性
i: 使文件不能被删除，改名，设置连接也无法写入或添加数据，只有root才能设置这个属性
lsattr [-adR] 文件或目录  显示文件隐藏属性

4.文件特殊权限: SUID、SGID、SBIT
当s这个标准出现在文件所有者的x权限上，此时就被称为Set UID。基本SUID有这样的限制和功能：
1.SUID仅对二进制程序(binary program)有效
2.执行者对于该程序需要具备x的可执行权限
3.本权限仅在执行该程序的过程中（run-time）有效
4.执行者将具有该程序所有者（owner）的权限

当s这个标准出现在用户组的x权限上，此时就被称为Set GID。基本SGID有这样的限制和功能：
1.SGID仅对二进制程序(binary program)有效
2.程序执行者对于该程序来说需要具备x的权限
3.执行者在执行过程中将会获得该程序用户组的支持
目录具有SGID的特殊权限时，代表用户在这个目录下新建的文件用户组都会与该目录用户组名相同。

Sticky Bit目前只针对目录有效，对于文件已经没有效果了，SBIT对于目录的作用是：
1.当用户对于此目录具有w,x权限，即具有写入的权限时；
2.当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除改文件

在三个数字之前再加上一个数字，4代表SUID,2代表SGID,1代表SBIT  《==========================
例：将一个文件权限改为"-rwsr-xr-x"，由于s在用户权利中，所以是SUID，因此还要在原先755之前加上4
    也就是用"chmod 4755 filename"来设置

SUID不是用在目录上,SBIT不是用在文件上
S,T代表原先没有x可执行标注，所以S,T代表空的。
符号法： SUID为u+s，SGID为g+s，SBIT为o+t

查看文件类型：file   ――ASCLL或者data或者binary且又没有用到动态函数库（share library）

5.命令与文件查询
which [-a] command  ：寻找执行文件（binary），默认查找PATH内所规范的目录
alias 就是所谓的"命令别名",即输入前面的会等于后面接的命令，页码p188

要查找文件的完整文件名,可以使用whereis或locate到数据库文件去查找，而不实际查找文件系统。
whereis [-bmsu] 文件或目录名  ：寻找特定文件，但是会以数据库的结果去查找文件
-m：找出说明文件manual路径下的文件
locate [-ir] keyword :可以通过部分文件名称查找

updatedb:手动更新数据库的命令updatedb命令读取/etc/updatedb.conf，再去硬盘里面查找文件名的操作，最后就
更新/var/lib/mlocate内整个数据库文件咯~
寻找的数据是通过查找已创建的数据库/var/lib/mlocate，数据库的创建默认是每天执行一次

find [PATH] [option] [action]   利用find可以加入很多参数来直接查询文件系统,以获得自己想知道的文件名
-mtime n :n为数字，意义为在n天之前的"一天以内"被更改过的文件
-mtime +n:列出在n天之前（不含n天本身）被更改过的文件名
查找系统不属于任何人的文件：find / -nouser
查找/home下面属于vbird的文件：find /home -user vbird
-name filename：查找文件名为filename的文件
-type TYPE：查找文件的类型为TYPE的,一般正规文件(f),设备文件(b,c),目录(d),连接文件(l),socket(s),FIFO(p)等属性
-perm mode：查找文件权限刚好等于mode的文件
-exec command：command为其他命令，-exec后面再接其他命令来处理查找到的结果

例：找出/etc底下，文件容量大于50K，且文件所属人不是root的文件名，并且将权限完整的列出
find /etc -size +50k -a！-user root -exec ls -l{}\;
{}代表由find找到的内容，-exec一直到\是关键字，代表find额外的命令的开始（-exec）到结束（\），
在中间的就是find命令内的额外命令，在本例中就是ls -l{}，因为;在bash环境是具有特殊意义的，因此
利用反斜杠来转义。注意到-a，那个-a是and的意思为符合两者才算成功。！代表的是反向选择，亦即不是
后面的项目之意。-o就是or的意思。

权限与命令间的关系:
让用户能够进入某目录成为可工作目录的基本权限是什么
1.可使用的命令：例如cd等切换工作目录的命令
2.目录所需权限：用户对这个目录至少需要x的权限
3.额外需求：如果用户想要在这个目录利用ls查阅文件名，则用户对此目录还需要r的权限

用户在某个目录读取一个文件的基本权限是什么
1.可使用的命令：例如cat、more、less等
2.目录所需的权限：用户对于这个目录至少需要的x的权限
3.文件所需的权限：用户对于文件至少需要具有r的权限才行

让用户可以修改一个文件的基本权限是什么
1.可使用的命令：例如nano、vi编辑器
2.目录所需要的权限：用户在该文件所在目录至少需要x的权限
3.文件所需权限：用户对改文件至少需要r,w的权限

让一个用户可以创建一个文件的基本权限是什么
1.目录所需权限：用户在该目录需要具有w,x的权限，重点在w

让用户进入某目录并执行该目录下的某个命令的基本权限是什么
1.目录所需权限：用户在该目录至少需要x的权限
2.文件所需权限：用户在该目录至少需要x的权限

************************************第8章 文件系统管理*******************************************  
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性
读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。
启动扇区（boot sector） 数据块（data block）
文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、
文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。

inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，
存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。
每个inode大小固定为128bytes，block大小有1K,2K,4K

传统的磁盘与文件系统的应用中，一个分区就只能被格式化为一个文件系统，所以我们可以说一个文件系统
就是一个分区，但是由于新技术的利用，LVM与软磁盘阵列的应用，可以将一个分区格式化为多个操作系统
（例如LVM），也能将多个分区合为一个文件系统（LVM,RAID）
通常我们可以称呼一个可挂载的数据为一个文件系统而不是一个分区

super block：记录文件系统的整体信息，包括inode/block总量，使用量，剩余量以及文件系统的格式与
             相关信息
inode：记录文件的属性，一个文件占用一个inode（单可能有连接文件占用同一个inode），同时记录此文件
       的数据所在的block号码
block：记录实际文件的内容，若文件太大，会占用多个block

data block是用来放置文件内容的地方，在Ext2文件系统中所支持的block大小有1kb，2kb，4kb三种
每个block内最多只能放置一个文件的数据

inodetable（inode表格）
inode要记录的数据非常多，单偏偏只有128bytes，而inode记录一个block号码要花掉4bytes，那么至少
也要10万条block号码的记录，为此我们系统聪明的将inode记录block号码的区域定义为12个直接，一个
间接，一个双间接与一个三间接记录区。
第一层block会指定256个第二层，每个第二层可以指定256个第三层，每个第三层可以指定256个号码。

superblock（超级块）
一个validbit数据，若此文件系统已被挂载，则valid bit为0，若未挂载，则valid bit为1
一个文件系统应该仅有一个superblock，事实上除了第一个block group内会含有superblock之外，后续
的block group不一定含有superblock，而若含有superblock则该superblock主要是作为第一个blockgroup
内的super block的备份，这样就可以进行损害后的救援。

File system Description（文件系统操作说明）
block bitmap（块对照表）
inode bitmap（inode对照表）

dumpe2fs [-bh] 设备文件名  （查看文件系统） -h：仅列出superblock的数据，不会列出其他区段的内容
df 查看目前挂载的设备

每个文件（不管是一般文件还是目录文件）都会占用一个inode，可依据文件内容的大小分配多个block
给该文件使用。同一个文件系统是不会重复inode。

要想读取该文件，必须要经过目录记录的文件名来指向正确的inode号码才能读取。
也就是说，其实文件名只有目录有关，但文件内容则与inode有关。

数据不一致（inconsistent）状态：通过super block当中记录的valid bit（是否有挂载）与文件系统的
                                sate（clean与否）等状态强制进行数据一致性的检查。
日志文件系统（journaling file system）

异步处理（asynchronously）：如果文件没有被改动过，则内存区段的文件数据会被设置为clean
			    如果文件被改动过，此时内存中数据会被设置为Dirty
数据Dirty时,此时所有的操作都还在内存中执行,并没有写入到磁盘中,系统会不定时地将内存中设置为Dirty的数据
写回磁盘,以保持磁盘与内存数据的一致性。

手动使用sync命令来强迫内存中设置为Dirty的文件回写到磁盘中，若正常关机，关机命令会主动调用sync
来将内存的数据回写入磁盘中

挂载点的意义：将文件系统和目录树结合的操作我们称为挂载。挂载一定是目录，该目录为进入文件系统的
  	      入口。
挂载之前一定记得格式化。

查看你的Linux支持的文件系统有哪些，可以查看ls -l /lib/modules/$（umane -r）/kernel/fs
系统目前已加载到内存中支持的文件系统则有，cat /proc/filesystems

linux VFS：Virtual Filesystem Switch 的内核功能去读取文件系统，整个linux认识的文件系统其实都是
           VFS在进行管理，我们用户并不知道每个分区上面的文件系统是什么,VFS会主动帮我们做好读取
 	   的工作
		
磁盘与目录的容量:df、du
df [-ahikHTm] 目录或文件名： 列出文件系统的整体磁盘使用量
df / ：重点在找出磁盘文件名而已
-h：以人们较易阅读的GB,MB,KB等格式自行显示 / -i：不用硬盘容量，而以inode的数量来显示
-T：连同该分区的文件系统名称（例如ext3）也列出。

[Filesysterm][1k-blocks][Used][Available][Use%][Mounted on]

Filesysterm:代表该文件系统是在哪个分区，所以列出设备名称
1k-block：说明下面的数字单位是1KB，可以利用-h，-m来改变容量
Mounted on：磁盘挂载目录所在（挂载点）

/dev/shm ：利用内存虚拟出来的磁盘空间，在每部主机都不一样，而且新建的东西在下次开机时就消失了

du [-ahsSkm] 文件或目录名称： 评估文件系统的磁盘使用量（常用于评估目录所占容量）
-s：列出总量而已，而不列出每个各别的目录所占容量
-S：不包括子目录下的总计

连接文件：ln
hard link（硬连接或实际连接）：每个文件都会占用一个inode，有没有可能有多个文件名对应同一个inode
                               号码呢？hard link是在某个目录下新建一条文件名，将两个文件名连接
                               到同一个inode（与两文件不同的inode real），自然这两个文件名的相关
			       信息就会一样。
实际连接的文件读取示意图:
被连接文件->被连接文件所在目录的block->inode real->文件实际内容（block）
硬连接文件->硬文件所在目录的block->inode real->文件实际内容（block）
			       
hard link是有限制的：不能跨文件系统；不能连接到目录；

symbolic link（符号连接，也即是快捷方式）：由快捷方式inode读取到的连接文件的内容仅有文件名，
                                           根据文件名连接到正确的目录（原文件的目录）去取得
					   目标的inode，最终就能够得到正确的数据了。
符号连接的文件读取示意图:
快捷方式->连接文件的block->inode 文件->目录的block->inode real->文件实际内容（block）

ln [-sf] 源文件 目标文件
-s：如果不加任何参数就是hard link，至于-s就是symbolic link
-f：如果目标文件存在时，就主动将目标文件直接删除后再创建

关于目录的连接数量：新建一个新的目录，新的目录连接数量为2，上层目录的连接上则增加1.

磁盘分区：   包含安装分区，删除分区等命令
fdisk [-l] 设备名称
-l：输出后面接的设备所有分区内容    
-n:新增一个分区  /  -t:修改系统ID
注意：逻辑分区是会随着拓展分区消失而消失的。显示的分区是按照主分区，拓展分区，逻辑分区排序。
分区是由n1到n2的柱面号码，但柱面的大小每块磁盘都不相同。
拓展分区最好能够包含所有为分区的区间。

partprobe命令更新分区表信息,将内核的partition table 更新。

磁盘格式化：
mkfs [-t 文件系统格式] 设备文件名
-t：可以接文件系统格式，例如ext3，ext2,vfat等（系统有支持才会生效）
mkfs -t vfat /dev/sda1 将sda1格式化为windows可读的vfat格式

mke2fs [-b block大小] [-i block大小] [-L:卷标] [-cj] 设备               / 卷标（label）
-b：可以设置每个block的大小，目前支持1024,2048,4096 bytes
-i：多少容量给予一个inode呢？ / -c:检查磁盘错误 
-j：本来mke2fs是EXT2，加上-j后，会主动加入journal成为EXT3

fsck [-t 文件系统] [-ACayf] 设备名称
-a/-y：自动修复有问题的扇区，有些系统仅支持-y
-C：可以在检验的过程当中使用一个直方图来显示当前的进度
-f：强制检查，细化检查 / 被检查的分区务必不可挂载到系统上面！即是需要在卸载的状态！

badblock -[svw] 设备名称
-s：在屏幕列出进度 / -w；使用写入的方式来测试

磁盘挂载与卸载：
在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。我们要访问存储
设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。

挂载的目录，而这个目录是进入磁盘分区（其实是文件系统）的入口。
作为挂载点的目录理论上应该都是空目录才是。

mount -a / mount [-l]                      ―― 默认只有root可以执行
mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点
-a：依照配置文件 /etc/fstab的数据将所有未挂载的磁盘都挂载上来
-l：增列Label名称
-n：使得实际挂载情况不实时写入/etc/mtab中
-L：系统除了利用设备文件名（/dev/hdc6）外，还可以利用文件系统的标卷名称（Label）来挂载
-o：后面接一些挂载时额外加上的参数，比如账号，密码，读写权限等：
    ro，rw：成为只读（ro），可读写（rw） / user，nouser：是否允许吃分区让任何用户执行mount

强调下,修改完/etc/fstab后,务必要测试一下,若有错误发生要赶紧处理。因为这个文件如果修改错误,是会造成
无法开机完全的情况。最好使用vim修改,因为会有语法的检验,就不会让你写错字了。

/etc/filesystems：系统指定的测试挂载文件系统类型
/proc/filesystems：linux系统已经加载的文件系统类型
linux支持的文件系统之驱动程序都卸载如下目录中：/lib/modules/$（uname-r）/kernel/fs/..

在系统里面新增一块硬盘时，应该：
1.对磁盘进行分区，建立可用的分区
2.对该分区进行格式化，以创建系统可用的文件系统
3.创建挂载点（也即使目录），并挂载。
因为每种操作系统所设置的文件属性/权限并不相同,为存放这些文件所需的数据,格式化以成为操作系统能
利用的文件系统格式

如果带有中文文件名的数据，那么在可以在挂载时指定一下挂载文件系统所使用的语言，在man mount找到
vfat文件格式当中可以使用iocharset来指定语系，而中文语系是cp950，所以也可以：
mount -t vfat iocharset=cp950 设备名 挂载点   vfat是windows可读的一种格式

根目录不能被卸载，如果挂载数据要改变或者根目录出现只读，最可能的处理方式就是重新启动，不过也可以
mount -o remount，rw，auto/

我们也可以利用mount来将某个目录挂载到另一个目录去，这并不是挂载文件系统，而是额外挂载某个目录的
方法，虽然下面的方法也可以使用sysboliclink来连接，不过在某些不支持符号链接的程序运行中。。。
mount --bind 目录 挂载点

umount [-fn] 设备文件名或挂载点 （将设备文件卸载）
-f：强制卸载，可以在类似网络文件系统（NFS）无法读取到的情况下 / -n：不更新 /etc/mtab情况下卸载
无法卸载，显示繁忙，可以cd/回到根目录，就能卸载了。

除了使用设备文件名，也可使用卷标名来进行挂载 mount -L "卷标名" 挂载点

磁盘参数修改：主设备代码（major）次设备代码（minor）

某些特定情况需要手动创建设备文件：
mknod 设备文件名 [bcp] [Major] [Minor] 
b：设置设备名称成为一个外部存储设备文件,例如硬盘等；
c：设置设备名称成为一个外部输入设备文件,例如鼠标、键盘等；
p：设置设备名称成为一个FIFO文件 
major：主设备代码 / minjor:次设备代码

卷标(Label):以Windows系统来说明,当打开资源管理器时,C/D等盘不是都有个名称吗？那就是Label(如果没有设置
            名称,就会显示"本机磁盘驱动器"的字样)
修改卷标： e2label 设备名称 新的label名称
tune2fs [-jlL] 设备名称 -j：将ext2的文件系统转换为ext3的文件系统
hdparm [-icdmXTt] 设备名称 ：测试性能

设置开机挂载：
开机挂载/etc/fatab及/etc/mtab
[磁盘设备文件名或Label][挂载点][磁盘分区的文件系统][文件系统参数][能否被dump备份命令作用][是否以fsck检测扇区]
1.根目录/是必须挂载的，而且一定要先于其他mount point被挂载进来
2.所有的挂载点必须为已新建的目录，可以任意指定，但一定要遵循必须的系统目录架构原理
3.所有挂载点在同一时间之内，只能挂载一次
4.如若需要卸载，你必须先将工作目录移到挂载点（及其子目录）之外

注意：利用设备名称（ex>/dev/hda1）来挂载分区时，是被固定死的，所以你的硬盘不可以随便插在任意的插
槽。不过，它还是有好处的。而使用Label name来挂载就应该随时注意你的Label name，可能因为你name的变
导致挂载出现问题，从而导致开机等系统出现问题。  ex>是example>的意思。
测试系统的"/dev/hdc2"卷标名称为/1，所以"LABEL=/1"也可以替代成为"/dev/hdc2"的意思。至于Label可以使
用dumpe2fs查询。

其实/etc/fstab(file system table)就是将我们利用mount命令进行挂载时，将所有的参数写入到这个文件
中就可以了。
cat /etc/fstab
第一列：磁盘设备文件名或该设备的Label / 第二列：挂载点！挂载点是什么？一定是目录
第三列：磁盘分区的文件系统 
第四列：文件系统参数 ：
defaults-同时具有rw，suid，exec，auto，Nouser，async等参数。基本上，默认情况使用defaults设置即可
async/sync：异步/同步。设置磁盘是否以异步方式运行，默认async（性能较佳）。
auto/noauto：自动/非自动。当下达mount -a时，此文件系统是否会被主动测试挂载，默认auto。
rw/ro：可读写/只读     exec/noexec：可执行/不可执行  user/nouser:允许/不允许用户挂载
suid/nosuid：具有/不具有suid权限    usrquota：启动文件设备支持磁盘配额模式
grpquota：启动文件系统对群组磁盘配额模式的支持
第五列：能否被dump备份命令作用  / 第六列：是否以fsck检查扇区

新建一个大文件当做分区进行挂载：
特殊设备loop挂载（镜像文件不用刻录就挂载使用）：mount -o loop   目录名 挂载点
创建大型文件:dd if=/dev/zero of=/home/loopdev bs=1M count=512
if=/dev/zero：if是input file，输入文件，那个/dev/zero是会一直输出0的设备
of=/home/loopdev ：of是output file，将一对零写入到后面接的文件
bs=1M：bs是每个block大小 / count=512 ：count则是总共几个bs的意思

内存交换空间（swap）的构建
swap的功能就是在应付物理内存不足的情况下所造成的内存扩展记录的功能。当内存不足时，为了让后续的
程序可以顺利运行，因此在内存中暂不使用的程序和数据就会被挪到swap中。由于swap是用硬盘来暂时存放
内存中的信息，所以用到swap时，你的主机硬盘灯就会闪烁不停

1.分区：使用fdisk在磁盘分一个分区给系统做swap/或者创建一个大文件（如同loop设备构建方法）
        由于linux默认会将分区的ID设置为Linux的文件系统，所以你还要设置一下system ID就是了。
        linux的ID是83，linux swap的ID是82，Extended的ID是5...
  ====> 添加新的分区后记得让内核更新分区表partprobe命令。       
2.格式化：利用新建swap格式的"mkswap 设备文件名"就能格式化该分区成为swap格式。
3.使用：最后将swap设备启动，方法为"swapon 设备文件名"
4.查看：最终通过free这个命令来查看一下内存的使用情况 	
5.若是使用loop构建方法：使用swapoff关掉swap file，
                        方法为swap off /目标目录/swap ，swap off 设备名
如果block刚好为1k，则boot sector和superblock各会占用一个block，所以boot sector是独立与superblock
外面的，block 0号是留给boot sector用的，superblock讲师block 1号。如果block大于1k(2k，4k)，我们
可以发现第一个（0号）block内含有boot sector和superblock，因此boot sector占有0~1023，superblock
占有1024~2047之间的空间，至于2048bytes以外的空间就真的保留了。

利用GUN的parted进行分区行为： parted [设备] [命令] [参数]
新增分区：mkpart [primary|logical|extended] [ext3|vfat] 开始 结束
分区表：print / 删除分区：rm [partition]

************************************第9章 文件与文件系统的压缩**********************************
*.z compress程序压缩的文件 / *.gz gzip程序压缩的文件 / *.bz2 bzip2程序压缩的文件 
*.tar tar程序打包的数据 / *.tar.gz 或 *.tar.bz2 tar程序打包的文件，其中经过gzip或bzip2的压缩

compress [-rcv] 文件或目录 ：压缩  /  uncompress 文件.Z ：解压缩
-r:连同目录下的子目录也同时压缩； -c:将压缩数据输出成为standard output(输出到屏幕)； -v:可以显示压缩后的文件信息及压缩过程中的一些文件名变化
在默认的情况下,被compress压缩的源文件会不见,而压缩文件会被创建起来,而且扩展名会是*.Z。

gzip [-cdtv#] 文件名 / bzip2 [-cdtv#] 文件名
-c：将压缩的数据输出到屏幕上，可通过数据重定向来处理。
-t：可以检验一个压缩文件的一致性，看文件有无错误。
-v：显示压缩比等信息 / -#：#代表压缩等级，-1最快，但压缩比最差，-9最慢，但压缩比等级最好默认是-6.
-d：解压缩
zcat 文件名.gz  / bzcat 文件名.bz2  ―― 命令用于读取纯文本被压缩后的压缩文件，不真正解压缩文件，
                                         就能显示压缩包中文件。

前面谈的命令大多仅能针对单一文件来进行压缩，虽然gzip与bzip2也能够针对目录来进行压缩，不过这两个
命令对目录的压缩是将目录所有文件分别进行压缩的操作。
tar [-j|-z] [cv] [-f 新建的文件名] filename <==打包与压缩
tar [-j|-z] [xv] [-f 新建的文件名] [-C 目录]  <==解压缩
tar [-j|-z] [tv] [-f 新建的文件名]          <==查看文件名
注意：-c，-t，-x不可同时出现在一串命令行中
-c：新建打包文件，可搭配-v来查看过程中被打包的文件
-t：查看打包文件的内容含有哪些文件名，重点在查看文件名
-j：通过bzip2的支持进行压缩/解压缩，此时文件名最好为.*tar.bz2
-z：通过gzip的支持进行压缩/解压缩，此时文件名最好为.*tar.gz
-x：解打包或解压缩的功能，可以搭配-C在特定目录解开。
-C 目录：这个参数用在解压缩时，若要在特定目录解压缩，可以使用这个参数
-P:保留备份数据的原来权限与属性，常用于备份（-c）重要的配置文件（一般不建议）
-p:保留绝对路径，即允许备份数据中含有根目录存在之意
--exclude=FILE：在压缩过程中，不要将FILE打包
--newer-mtime=时间：仅mtime（文件内容） / --newer=时间：包含mtime和ctime（权限和属性）

压缩： tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查询： tar -jtv -f filename.tar.bz2
解压缩 tar -jxv -f filename.tar.bz2 -C 欲解压缩到的目录    ――到特定目录解压
       tar -jxv -f 打包文件.tar.bz2 待解开文件名           ――仅解开压单一文件
在tar所记录的文件名就是解压后实际的文件名    
压缩 /目录/filename.tar.bz2会将filename.tar2.bz2保留到/目录，即储存在在/目录/压缩文件
解压缩 /目录/filename.tar.bz2只会将filename.tar2.bz2保留下来，即储存在/解压到的目录/文件
想象一下windows系统压缩到/目录/文件名，将/目录/压缩包解压到/新目录。

文件名去除了根目录:主要是为了安全,我们使用tar备份的数据可能会需要压缩回来,在tar所记录的文件名那就是我们
                   解压缩后的实际文件名。如果去掉了根目录,假设你将备份数据在/tmp中解开,那么解压缩的文件名
                   就会变成"/temp/etc/xxx"。但如果没有去掉根目录,解压缩的文件名就会是绝对路径,即压缩后的
                   数据一定会被放置到/etc/xxx去,如此一来,你原本在/etc/下面的数据就会被备份数据所覆盖。

仅解开单一文件的方法：先找到文件:tar -jtv -f /文件名 | grep '单一文件名'
                      解压缩:tar -jxv -f 打包文件.tar.bz2 待解开文件名
打包某文件,但不包含该目录下的某些文件的做法: --exclude=FILE：在压缩过程中，不要将FILE打包
仅备份比某个时刻还要新的文件:--newer-mtime=时间：仅mtime（文件内容） / --newer=时间：包含mtime和ctime（权限和属性）

如果仅打包而已的文件后缀为.tar，如果打包并压缩的后缀名为.tar.bz2

完整备份工具：dump 
这个命令除了能够针对整个文件系统备份之外,也能够进针对目录进行备份,而可以制定等级。
dump [-Suvj] [-level] [-f 备份文件] 待备份文件 / dump -W
-S：仅列出后面待备份数据需要多少磁盘空间 / -u：将这次dump的时间记录到/etc/dumpdates文件中
-W：列出在/etc/fstab里面的具有dump设置的分区是否有备份过

单一文件系统时，那么该文件系统可以使用完整dump功能，包括利用0~9的整个level来备份。
一开始是使用level为0的完整备份，再次备份设置level为1，此时备份的数据就只会记录与第一次备份所差异的
文件而已。

并非单一文件系统且仅能使用level0: dump -0j -f 文件名 目录

待备份的数据只是目录,并非单一文件系统:
例如你想备份/home/someone/，但该目录并非独立的文件系统,此时备份就有限制,包括：
1.所有备份数据都必须要在该目录下面(/home/someone/)；
2.且仅能使用level0,即仅支持完整备份而已；
3.不支持-u参数,即无法创建/etc/dumpdates这个level备份的时间记录文件；


例:使用dump将/home完整的备份到/backupdata上 
    完整备份:dump -0u -f /backupdata/home.dump /home
    第一次进行增量备份:dump -1u -f /backupdata/home.dump.1 /home

用dump备份完整的文件系统 ；用dump备份非文件系统，即单一目录的方法 ； 

用restore恢复dump的备份文件:
restore -t [-f dumpfile] [-h]                           <==用来查看dump文件
restore -C [-f dumpfile] [-D 挂载点]                    <==比较dump与实际文件
restore -i [-f dumpfile]                                <==进入互动模式
restore -r [-f dumpfile]                                <==还原整个文件系统

备份还原：先将备份的目录卸载umount 目录，并重新格式化mkfs -t ext 3 设备，然后重新挂载mount -a，
          可以自行使用df以及ll查阅该目录下的内容，cd切换到目录，将完整备份的level 0的文件还原
          restore -r -f 备份文件 ，将后续的level 1,2..的备份也还原回来cd 目录2，restore -r -f 备份文件2

由于dump是记录整个文件系统的，因此还原时你应该要给予一个全新的文件系统才行。
restore互动模式可以还原部分文件
 
光盘写入工具： -->刻录
1.现将所需要的备份数据构建成一个镜像文件（iso），利用mkisofs命令来处理
2.将该镜像文件刻录至光盘或DVD中，利用cdrecord命令来处理

新建光盘刻录数据：
mkisofs [-rv] [-o 镜像文件] [-m file] 带备份文件..[-V vol] -graft-point isodir=systemdir...
-r:通过Rocky Ridge 产生支持UNIX/Linux的文件数据，可记录较多的信息
-v：显示构建ISO文件的过程 / -m file :-m为排除文件的意思（exclude），后面的文件不备份到镜像文件中
-V vol：新建volume。 / -graft-point :graft有转嫁或移植的意思
所有要被加到镜像文件中的文件都会被放置到镜像文件中的根目录，当你利用-graft-point 这个参数后，
可以利用如下方法来定义镜像文件中的目录：
1.镜像文件中的目录所在=实际linux文件系统的目录所在
2./movies/=/srv/movies/（在linux的/src/movies 内的文件，加至镜像文件中的/movies/目录）
3./linux/etc=/etc（将linux的/etc/内的所有数据备份到镜像文件中的/linux/etc/目录中）

使用cdrecord来写入CD或DVD刻录机
cdrecord：光盘刻录工具
cdrecord -scanbuSdev=ATA                                 <==查询刻录机位置
cdrecord -v dev=ATA：x，y，z blank=[fast|all]            <==抹除重复读写片
cdrecord -v dev=ATA：x，y，z -format                     <==格式化DVD+RW
cdrecord -v dev=ATA：x，y，z [可用参数功能] file.iso

常见的压缩与备份工具
dd可以读取磁盘设备的内容（几乎是直接读取扇区），然后将整个设备备份成一个文件
dd可备份完整的分区或磁盘，因为dd可读取磁盘的扇区表面数据
dd if="input file" of="output file" bs="block size" count="number"
dd if=/dev/zero of=123 bs=1M count=20  创建20M的文件
if ：就是input file，也可以是设备 / of ：就是output file，也可以是设备
bs ：规划的一个block的大小，若未指定则默认是512bytes（一个扇区的大小）
count：多少个bs的意思

你可以说，tar是备份关键数据，而dd则可以用来备份整块分区或整块硬盘（新分区出来的分区不需要格式化）。

cpio可以备份任何东西，包括设备设备文件，不过有个问题就是cpio不会主动去找文件来备份，得配合find等
可以找到文件名的命令来高中cpio该备份的数据在哪里
cpio -ovcB  > [file|device]             <==备份
cpio -ivcdu < [file|device]             <==还原
cpio -ivct  < [file|device]             <==查看

例: find / -print | cpio -ovcB > /dev/st0 备份到磁带机
    cpio -idvc < /dev/st0 还原到磁带机

因为cpio会将数据整个显示到屏幕上，因此我们可以通过将这些屏幕的数据重新导向（>）一个新的文件，
至于还原呢，就是将备份文件读竟来cpio（<）进行处理之意


*****************************************第十章 vim编辑器*********************************************
vi的使用
一般模式、编辑模式（i,l,o,O,a,A,r,R）、命令行模式(q,wq..)
一般模式：ctrl+r：重做上一步   u：复原上一步   $移动到最后    .重复前一个操作
          H:移动到第一个字符  G:移动到最后一个字符 nG：移动到这个文件的n行
          nx/X :连续向后/前删除n个字符  /word :向下寻找一个名称为word的字符串 ？word :向上寻找
          gg :移动到这个文件的第一行 ndd ：删除光标所在向下n行
          n1,n2s/word1/word2/g（c）:在n1,n2行之间寻找word1这个字符，将之替换为word2，加上c代表
                                    替换会一个一个询问。
          nyy：n为数字，复制光标所在的向下的n行 p/P:将已复制的数据在光标下/上一行粘贴
编辑模式：i从目标光标所在处插入，a从目前光标所在的下一个字符处开始插入 
          o在目前光标所在的下一行处插入新的一行，r只会替换光标所在的那一个字符一次
命令行模式：:w!若文件属性为只读，强制写入该文件。不过到底能不能写入，与你对该文件的文件权限有关
            ZZ若文件没有更改，则不保存离开，若文件已经被更改，则保存后离开
	    :w[filename]将编辑的数据保存成另一个文件（类似于另存文件）
            :r[filena		开vi命令到命令行模式执行ls的显示结果
	    :set nu显示行号	 / :set nonu取消行号  

vim 块选择（Visual block）：按下v，V，ctrl+v，这时光标经过的地方就会反白。
v:字符选择，会将光标经过的地方反白选择 V:行选择，会将光标经过的行反白选择
[ctrl]+v:块选择，可以用长方形的方式选择数据
y:将反白的地方复制起来 / d:将反白的地方删除 / p:粘贴

多文件编辑
:n 编辑下一个文件 :N 编辑上一个文件 :files列出目前这个vim的打开的所有文件
vim 文件1 文件2 一个vim打开2个文件 
使用":file"查看下编辑的文件数据有什么，在vim的环境下输入"n"会来到第二个编辑的文件

多窗口编辑
在命令行模式输入":sp{filename}"即可。那个filename可有可无，如果想在窗口启动另一个文件，就加入
文件名，否则仅输入:sp时，出现的则是同一个文件在两个窗口间。
两个文件同时在同一个屏幕上面显示，你可以利用[ctrl]+w+↑↓在两个窗口之间移动：按键的按法是先按下
ctrl不放，再按下w后放开所有的按键，然后在按下j/k（↓/↑），则光标可移到下方的窗口。

vim环境设置与记录:~/.vimrc,~/.viminfo
vim的环境设置参数有很多，如果你想知道目前的设置值，可以在一般模式时输入":set all"来查阅
整个vim的设置值放置在/etc/vimrc这个文件中，不过不建议你修改它，你可以修改~/.vimrc这个文件（默认
不存在，请你手动创建），将你希望的设置值写入

中文编码的问题:LANG=zh_CN.big5

DOS与linux的断行字符
我们可以利用cat -A来查看以DOS（windows系统）建立的文件的特殊格式，也可以发现在DOS中使用的断行字符
为^M$，我们称为CR与LF两个符号。而在linux下面，则是仅有LF（$）这个断行符号。
dos2NUIX [-kn] file [newfile] 修改dos断行  与  NUIX2dos [-kn] file [newfile] 修改为linux断行字符

语系编码装换
inconv --list 与 inconv -f 原本编码 -t 新编码 filename [-o newfile]
--list:列出inconv支持的语系数据

**********************************第十一章 认识与学习bash****************************************
1.管理整个计算机硬件的其实是操作系统的内核（kernel），这个内核是需要进行保护的，所以我们一般用户就
只能通过shell来跟内核通信，以让内核可以控制硬件来达到我们所想要达到的工作。
2.其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要调用其他用户软件才好，包括man，
chmod，vi等命令都是独立的应用程序，但是我们可以通过shell（就是命令行模式）来操作这些命令系统，让
这些应用程序调用内核来运行软件所需的工作。
3.也就是说。只要能够操作应用程序的接口都能称为shell，狭义的shell指的是命令行方面的软件，包括本章要
介绍的bash等。广义的shell包括图形界面的软件，因为图形界面其实也能够操作各种应用程序来调用内核工作

用户->用户界面（shell,KDE,application)->硬件(Hardware)

系统的合法shell与/etc/shell功能：
linux使用的这一版本shell为"Bourne Again SHell（简称bash）"
系统上合法的shell要写入/etc/shells这个文件，因为系统某些服务在运行过程中，回去检查用户能够使用的
shells，而这些shells就是借助/etc/shells这个文件
我这个用户什么时候可以取得shell来工作呢?还有我这个用户默认会取得哪一个shell？当我登陆的时候系统会
给我一个shell来让我工作,而这个登陆取得的shell就记录在/etc/passwd这个文件夹内。

bash shell的功能：
命令记忆功能：只要在命令行按上下键就可以找到前/后一个输入的命令。~/.bash_history
命令与文件补全功能：[Tab]按键的好处
命令别名设置功能:使用alias->你在命令行输入alias就知道目前的命令行别名有哪些了，也可以直接执行命令
 		 来设置别名 alias 别名='原来的命令'
作业控制，前台，后台控制
程序脚本（shell script） / 通配符（wildcard） 

bash shell的内置命令：type 判断每个命令是否为bash的内置命令
type [-tpa] name : -a 会由PATH变量定义的路径中，将所有含name的命令都列出来，包含alias
   
shell的变量功能
环境变量：由于系统需要一些变量来提供它数据的访问或者一些环节的设置参数值（例如是否要显示颜色），
          所以就有了一些所谓的环境变量来读入系统中了。为了区别与自定义变量的不同，环境变量通常
	  以大写字符来表示(PATH,HOME,MAIL,SHELL等)

变量的显示与设置：echo，unset 《=========================================
echo $variable / echo $PATH
利用echo显示变量，但是在变量被显示时，前面必须加上字符$才行。
设置规则：1.变量与变量内容以一个等号"="来连接  2.等号两边不能直接接空格符
          3.变量只能是英文与数字，但是开头字符不能为数字 
          4.变量内容若有空格符，可使用双引号"或者单引号'将变量内容结合起来 
            双引号内的特殊字符入$等，可以保有原本的特性。 例:若var="lang is $LANG"则
            echo $var可得lang is en_US
	    单引号内的特殊字符则仅为一般字符（纯文本）。例:若var=‘lang is $LANG’则
            echo $var可得lang is $LANG
          5.可用转义字符"\"将特殊符号（如[Enter]、$、\、空格、！等）变成一般字符
          6.在一串命令中，还需要通过其他的命令提供的信息，可以使反单引号`命令`或"$(命令)"，特别
            注意的，那个是键盘1左边的那个按键，而不是单引号
             cd /lib/modules/`uname -r`/kernel 在一串命令中`之内的命令将会被先执行
          7.若该变量为了增加变量内容时，则可用"$变量名称"或者$(变量)累加内容 
             变量=$变量累加内容 、 变量="$变量"累加内容 或 变量=${变量}累加内容
  	  8.若该变量需要在其他子程序执行，则需要以export来使变量变成环境变量：export PATH
	  9.通常大写字符为系统默认变量，自行设置变量可以使用小写字符。
	  10.取消变量的方法为unset 变量名称

在变量的设置中,单引号与双引号的用途有何不同？
双引号仍然可以保有变量的内容,但单引号内仅是一般字符,而不会有特殊字符。
例：name=vbird name="$name is me" 表示 name=vbird is me
               name='$name is me' 表示 name=$name is me

在命令执行的过程中,反单引号(`)这个符号代表的意义为何？
在一串命令中,在`之内的命令将会被先执行,而将其执行出来的结果将作为外部的输入信息。

环境变量的功能
1.用env查看环境变量与常见环境变量说明
PATH：就是执行文件查找的路径，目录与目录中间以冒号分隔，由于文件的查找是依序由PATH的变量内的目录
      来查询，所以目录的顺序也是重要的。例如你执行ls这个命令时,系统就是用过PATH这个变量里面的内容
      所记录的路径顺序来查找命令的呢。
RANDOM：这是"随机数"的变量，我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数值

2.用set查看所有变量（含环境变量与自定义变量）
PS1（提示符prompt的设置）：命令提示符 PS1='[\u \h \@ \参数]\$ ' 
例：[root@www home]# PS1='[\u@ \h \w \A #\#]\$ ' 将输出[root@www /home 17:02 #85]#
$关于本shell的PID，想知道我们的shell的PID，用echo $$即可，出现的数字就是你的PID号码
？关于上个执行命令的回传码echo $? 一般来说，如果成功执行了该命令，则会回传一个0，出现错误，回传
  一个执行后的代码
export：自定义变量转成环境变量。后面没有接变量时，会把所有的环境变量显示出来。
export 变量名称                      自变量和环境变量的差异在于该变量是否会被子进程所继续引用。

在你登录linux并取得一个bash之后，你的bash就是一个独立的进程，被称为PID的就是。接下来，你在这个
bash下面执行的任何命令都是由这个bash所衍生出来的，那些被执行的命令就被称为子进程了。
子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量，直到回到原本的父进程。
因此，将自定义变量变成环境变量就可以使该变量继续存在于子程序了。
locale：影响显示结果的语系变量  整体系统默认的语序定义在/etc/sysconfig/i 18n

为什么环境变量（全局变量）可以被子程序引用呢？这是因为内存配置的关系，理论上是这样的：
1.当启动一个shell，操作系统会分配一记忆块给shell使用，此内存内的变量可让子进程取用；
2.若当父进程利用export功能，可以让自定义的内容写到上述的记忆块当中（环境变量）
3.当加载另一个shell时（即启动子进程，而离开原本的父进程），子shell可以将父shell的环境变量所在的
  记忆块导入自己的环境变量块当中。

影响显示结果的语系变量(locale)：整体系统默认的语系定义/etc/sysconfig/il8n
变量的有效范围:基本上你可以这样区别: 环境变量=全局变量 ； 自定义变量=局部变量

变量键盘读取、数组与声明：read，array，declare
read [-pt] variable  让用户由键盘输入内容，将该内容变成名为variable的变量
-p 后面可以接"提示符" ，-t 后面可以接等待的时间
declare/typeset  声明变量的类型 declare [-aixr] variable
-a：将后面名为variable 的变量定义成为数组类型（array）的类型
-i：将后面名为variable 的变量定义成为整数数字（integer）的类型
-x：用法和export一样，就是将后面的variable变成环境变量，设置为+x可以取消的操作
-r：将变量设置成为reaonly类型，该变量不可被更改内容，也不能重设
数组（array）变量类型
var[index]=content ， 目前我们bash提供的是一维数组 读取直接以${数组}来读取

与文件系统及程序的限制关系：ulimit
我们的bash是可以限制用户的某些系统资源的,包括打开的文件数量,可以使用的CPU时间,可以使用的内存总量等。
ulimit [-SHacdfltu] [配额]
-c：当某些进程发生错误时，系统可能会将该进程在内存中的信息写成文件（排错用），这种文件就被称为内
    核文件（core file）。此为限制每个内核文件的最大容量。
-f：此shell可以创建的最大文件容量（一般可能设置为2GB）单位为KB。
-d：进程可使用的最大断裂内存（segment）容量
-u：单一用户可以使用的最大进程（process）数量
想要复原ulimit设置最简单的方法就是注销再登录，否则就是得要重新以ulimit设置才行。不过要注意的是一般
身份用户如果以ulimit设置了-f的文件大小，那么他只能继续减小文件容量，不能增加文件容量。

变量内容的删除、替代与替换
path=${PATH}
#：符合替换文字最短的那一个。代表从前面开始向右删除,仅删除最短的那个。
##：符合替换文字最长的那一个。代表从前面开始向右删除,仅删除最长的那个。   
最短的一般就是第一个变量，最长的一般都是从第一个到最后不删除的那个
%：从后面向前删除变量内容，删除"最短的"
%% 从后面向前删除变量内容，删除"最长的"

例：删除：echo ${variable#/*kerberos/bin:}
variable这个是原本的变量名称 
#这个是重点，代表从变量内容的最前面开始删除，仅删除最短的那个。##则删除最长的那个数据。
/*kerberos/bin:代表被删除的部分，由于#代表从前面开始删除，所以这里便由开始的/写起
指的注意的是我们还可以通过通配符*来替代0到无穷多个字符 删除结果为/user/kerberos/bin:被删除

例：替换：将path的变量sbin替换成大写SBIN，echo ${path/sbin/SBIN}

new_var=${old_var-content}
${变量#关键字}                       若变量内容从头开始的数据符合关键字，则将符合的最短数据删除
${变量##关键字}			     若变量内容从头开始的数据符合关键字，则将符合的最长数据删除
${变量%关键字}			     若变量内容从尾到头的数据符合关键字，则将符合的最短数据删除
${变量%%关键字}                      若变量内容从尾到头的数据符合关键字，则将符合的最长数据删除
${变量/旧字符串/新字符串}            若变量内容符合旧字符串，则第一个旧字符串会被新字符串替换
${变量//旧字符串/新字符串}           若变量内容符合旧字符串，则全部的旧字符串会被新字符串替换

变量设置方法	    str没有设置	          str为空字符串	        str以设置非空字符串	
var=${str-expr}     var=expr              var=                  var=$str
var=${str:-expr}    var=expr              var=expr              var=expr
var=${str+expr}     var=                  var=expr              var=expr
var=${str:+expr}    var=                  var=                  str不变
var=${str=expr}     str=expr              str不变               str不变
                    var=expr              var=                  var=$str
var=${str:=expr}    str=expr              str=expr              str不变
		    var=expr              var=expr              var=$str
var=${str?xpr}      expr输出至stderr      var=                  var=str
var=${str:?expr}    expr输出至stderr      expr输出至stderr      var=str
一般来说，str:代表str没设置或为空的字符串时，至于str则仅表示没有该变量。

命令别名（alisa）是新创一个新的命令，你可以直接执行该命令的，至于变量则需要使用类似"echo"命令才能
够调用变量的内容。取消别名unalias。

历史命令：history
history [n] / history [-c] / history [-raw] histfiles
n:数字，是要列出最近的n条命令行的意思  / -C:将目前的shell中所有history内容全部消除
-a:将目前新增的history命令新增入histfiles中，若没有加histfiles，则默认写入~/.bash_history
-r:将histfiles的内容读到目前这个shell的history记忆中。
-w：将目前的history记忆内容写入histfiles中。

输入history命令得到结果后，可以!+数字执行第n条命令，!+部分命令执行以部分命来开头的命令

Bash Shell的操作环境
命令运行的顺序:1.以相对/绝对路径执行命令 		2.以alias找到该命令来执行
	       3.通过bash内置的（builtin）命令来执行    
               4.通过$PATH这个变量的顺序找到第一个命令来执行   
如果想要了解命令查找的顺序，可以通过type -a 命令查询得到。
                                                                    
bash的登录与欢迎信息:/etc/issue,/etc/motd   <==修改自己喜欢的登录提示，登录后显示欢迎讯息
当使用telnet远程登录程序连接到主机时，主机的登录界面就会显示/etc/issue.net 而不是/etc/issue
如果你想让用户登录后取得一些信息，可以将信息加入/etc/motd里面去。

要注意的是，我们之前谈到的命令别名、自定义的变量在你注销bash后就会失效，所以你想要保留你的设置，
就要将这些配置写入配置文件才行。

bash的环境配置文件：全体系统的配置文件以及用户个人偏好配置文件
(登录)login shell:取得bash时需要完整的登录流程，就称为login shell。举例来说你要由tty1~tty6登录，
		  需要输入账号和密码，此时取得的bash就称为login shell。
non-login shell:取得bash的接口的方法不需要重复登录的举动。举例来说,你以X Window登录Linux后,再以X的
                图形界面启动终端机,此时那个终端接口并没有需要再次输入账号与密码,那个bash的环境就称
                为non-login shell。你在原本的bash环境下再次执行bash这个命令,同样也没有输入账号密码
                那第二个bash(子进程)也是non-login shell。

一般来说，login shell其实只会读取这两个配置文件：
1./etc/profile:这是系统整体的设置，这个配置文件可以利用用户的标识符（UID）来决定很多重要的变量数据，
             这也是每个用户登录取得bash时一定会读取的配置文件，所以如果你想要帮所有用户设置整体环境，
             那就是在这里修改，但是，没事你最好不要修改这个文件。
PATH：会依据UID决定PATH变量要不要含有sbin的系统命令目录
MAIL：依据账号设置好的用户的mailbox到/var/spool/mail账户名
2.~/.bash_profile或~/.bash_login或~/.profile:属于用户个人设置，你要改自己的设置，就写入这里。

3./etc/inputrc：其实这个文件斌没有执行。其会主动判断用户有没有自定义输入的按键功能,如果没有的话,/etc/profile
                就会决定设置"INPUTRC=/etc/inputrc"这个变量。此文件内容为bash的热键,[tab]有没有声音等数据。
4./etc/profile/*.sh：只要在这个目录内且扩展名为.sh,另外用户由r的权限,那么该文件就会被/etc/profile.d/
                     这个目录调用。在CentOS 5.x内,这个目录下面文件规定了bash接口的颜色、语系、ll与ls命令
                     别名等。如果你需要帮所有用户设置一些共享的命令别名时,可以在这个目录下创建.sh的文件。
5./etc/sysconfig/i18n：这个文件由/etc/profile.d/lang.sh调用。这就是我们决定bash默认使用何种语系的重要配置
                       文件。

Source:读入环境配置文件的命令
由于/etc/profile与~/.bash_profile都是在取得login shell的时候才会读取的配置文件，所以如果你将自己的
偏好设置写入上诉的文件后，通常都是得注销再登录后该设置才会生效。那么能不能直接读取配置文件而不注销
登录呢，通常要利用source这个命令。
source（或小数点）:读入环境配置文件的命令   
source 配置文件名或 . 配置文件名

（non-login shell会读）~/.bashrc
1.调用/etc/bashrc文件,/etc/bashrc帮我们的bash定义出下面的数据
a.依据不同的UID规定umask的值；    b.依据不同的UID规定提示符（就是PS1变量）
c.调用/etc/profile.d/*.sh的设置：万一你没有~/.bashrc，你会发现你的bash提示符可能变成-bash-3.25
                                 不要太担心，因为你并没有调用/etc/bashrc来规定PS1变量，而且这样
				 的情况也不会影响你的bash使用。如果你想将命令提示符调回来，那么
				 可以复制/etc/skel/.bashrc到你的主文件夹，在修改你想要的内容，并
				 使用source去调用~/.bashrc,那么你的命令提示符就会回来了。
其他相关配置文件
/etc/man.config :这文件的内容规定了使用man的时候man page 的路径去哪里寻找。如果你是以tarball的方式
                 来安装你的数据，那么你的man page可能会放置在/user/local/softpackage/man里头，那个
                 softpackage是你的套件名称，这个时候你就得手动将该路径加到/etc/man.config，否则使用
		 man的时候就会找不到相关的说明文件。
~/.bash_history:默认情况下，我们的默认历史命令就记录在这里。而这个文件能够记录几条数据则与HISTSIZE
		这个变量有关。每次登陆bash后，bash会先读取这个文件，将所有的历史命令读入内存，因此
		当我们登陆bash后既可以查看上次使用过的哪些命令。
~/.bash_logout:这个文件记录了当我注销bash后系统在帮我做完什么操作后才离开。

终端机的环境设置:stty,set
1.查询目前的按键内容：stty（setting tty终端机的意思），stty也可以帮助设置终端机的输入按键代表意义。
stty [-a] ：列出所有的按键与按键内容。其中几个重要的意义
eof：end of file的意思，代表结束输入； erase：向后删除字符； kill：删除目前命令行上所有的文字；
intr：送出一个interrupt的信号给目前运行的程序  stop：停止目前屏幕的输出；
例：如果你想用ctrl+h来进行字符的删除 stty erase ^h
2.设置整个命令输入/输出的环境，例如记录历史命令，显示错误内容等
set [-uvCHhmBx]
3.组合按键 Ctrl+C终止目前的命令 Ctrl+D输入结束（EOF） Ctrl+M就是Enter Ctrl+S/Q暂停，恢复屏幕的输出

通配符（wildcard）
*代表0到无穷多个任意字符  ？代表一定有一个任意字符 []一定有一个在中括号内的字符（非任意字符）
[-]编码顺序内的所有字符   [^]反向选择
例子：找出/etc/下面文件名含有数字的文件名 ll -d /etc/*[0-9]*
      找出/etc/下面文件名开头非为小写字母的文件名 ll -d /etc/[^a-z]*

特殊字符
#批注符号 \转义符号 |管道 ;连续命令分隔符 ~用户的主文件夹 &作业控制，将命令变成背景下工作
！逻辑运算意义上的"非"的意思  /目录符号,路径分隔的符号 $使用变量前导符
 >,>>数据重定向,输出导向,分别是替换与累加  ''单引号，不具有变量置换的功能  
""双引号，具有变量置换功能  ``反引号，中间为可执行的命令，也可使用$() 

数据流重定向：就是将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方
1.标准输入（stdin）:代码为0，使用<或<<    <就是将原本键盘输入的数据由文件内容替代，<<结束输入
2.标准输出（stdout）:代码为1，使用>或>>   单>将会覆盖原先数据，>>才是累加数据
3.标准错误输出（stderr）:代码为2，使用2>或2>>  命令执行失败后,所回传的错误信息

想要将正确的与错误的数据分别存入到不同的文件中 命令 文件 >list_right 2>list_error（2>会只留下错误）
将正确与错误数据通通写入一个文件: 2>&1或&> 。例:find /home -name .bashrc > list 2> list 。

垃圾桶黑洞设备与特殊写法: 命令 目录 >/dev/null


例：我要用cat直接将输入的信号输出到catfile中，当由键盘输入eof时，这次输入就结束
[root@www~]cat>catfile<<"eof"
>this is a test
>ok now stop
>eof          <==输入eod关键字，立即结束而不需要输入ctrl+d

重定向使用的情况：1.屏幕输出的信息横重要，而且我们需要将它存下来的时候
		  2.后台执行中的程序，不希望它干扰屏幕正常的输出结果时
		  3.一些系统的例行命令的执行结果，希望他可以存下来
		  4.一些执行命令的可能已知错误信息时，想要以2>/dev/null将它丢掉
                  5.错误与正确信息需要分别输出时

命令执行的判断依据: ；&& ||
cmd;cmd(不考虑命令相关性的连续命令执行,两个命令之间没有相关性)
$?(命令回传码)与&&或|| (命令之间具有相依性，这个相依性主要判断的地方就是前一个命令执行的结果是否正确）
命令回传符：若前一个命令执行的结果正确，在linux下面会回传一个$?=0的值。
cmd1&&cmd2：若cmd1执行完毕且正确执行（$？=0），则开始执行cmd2。反之，不执行cmd2.
cmd1||cmd2：若cmd1执行完毕且正确执行（$？=0），则不执行cmd2。反之，开始执行cmd2.
一般来说假设判断式有三个，也就是command1&&command2||command3

管道命令（pipe）
管道命令"|"仅能处理经由前面一个命令传来的正确信息（也就是standard output,对于standard error没有直接
处理的能力）而且这个命令必须要能够接受standard input的数据才行。例如less,more,head,tail等都是可以接
收standard input的管道命令,至于例如ls,cp,mv等就不是管道命令，因为ls,cp,mv并不会接收来自stdin的数据。

选取命令:cut,grep
1.cut -d'分隔字符' -f fields <==用于分隔字符          cut -c 字符范围 <==用于排列整齐的信息
-f:依据-d的分隔字符将一段信息切割成数段，用-f取出第几段的意思
cut是在一行信息当中取出某部分我们想要的，而grep则是分析一行信息，若有我们想要的信息，就将该行拿出来
2.grep [-acinv] [--color==auto] '查找字符串' filename 
-n:顺便输出行号 -v:反向选择 -i:忽略大小写不同

排序命令:sort,wc,uniq
1.sort [-fbMnrtuk] [file or stdin]
-f:忽略大小写的差异，例如A与a视为编码相同 / -b:忽略前面的空格符号 / -r:单向排序 
-t:分隔符，默认是用[tab]键来分隔 / -k:以那个区间来进行排序 / -M,n:以月份,纯数字进行排序
例：/etc/passwd内容是以:来分隔的，我想以第三列来排序，该如何？
    cat /etc/passwd | sort -t ':' -k 3
2.uniq [-ic]  排序完成后想要将重复的数据仅列出一个显示
-i:忽略大小写字符的不同 / -c:进行计数
3.wc [-lwm]   计算输出信息的和整体信息
-l:仅列出行 / -w:仅列出多少字（英文单字） / -m:多少字符

4.双向重定向:tee  会同时将数据流送与文件与屏幕，而输出到屏幕的,其实就是stdout,可以让下个命令继续处理
tee [-a] file    -a:以累加的方式,将数据加入file当中。
tee可以让standard output转存一份到文件内并将同样的数据继续到屏幕去处理，这样除了可以让我们同时分析
一份数据并记录下来之外，还可以作为一份数据的中间暂存盘记录使用。

字符转换命令:tr,col,join,paste,expand
1.tr:可以用来删除一段信息当中的文字，或者进行文字信息的替换。
tr [-ds] SET1 ...   -d: 删除信息当中的SET1这个字符串  -s:替换掉重复的字符

2.col [-xb]  -x:将tab键转换成对等的空格键 -b:在文字内有反斜杠（/）时，仅保留反斜杠最后接的那个字符
[tab]键显示就是^I的符号。此外,col经常被用于将man page 转存为纯文本文件以方便查阅功能。

3.join:处理两个文件之间的数据，主要是要将两个文件当中有相同的数据的那一行加在一起。
join [-ti12] file1 file2
-i:忽略大小写字符的不同 / -t:如果两条文件相同，则将两条数据连成一行，且第一个字符放在第一个、
-1:代表第一个文件要用哪个字段来分析的意思 / -2:代表第二个文件要用哪个字段来分析的意思
例:我们知道/etc/passwd的第四个字段是GID,那个GID记录在/etc/group当中第三个字段，将二者整合
join -t ':' -1 4 /etc/passwd -2 3 /etc/group   
-1 4代表第一个文件要用第4个字段来分析   :字符2加上冒号连接在后面
此外，需要注意的是在使用join之前，你需要将处理的文件应该事先经过排序（sort）处理。

4.paste 直接将两行贴在一起，且中间以tab键隔开而已
paste [-d] file1 file2        -d:后面可以接分隔字符，默认tab分隔   
-:如果file部分写成-，表示来自standard input的数据（管道输入的数据）的意思

5.expand 就是将[tab]按键转化成空格键
expand [-t] 数字 file    数字代表几个字符来表示一个tab的长度

6.切割命令：split [-bl] file PREFIX  将一个大文件依据文件大小或行数切割成为小文件
-b：后面接切割文件的大小  -l:以行数进行切割  PREFIX:代表前导符，可作为切割文件的前导文字
  合并时使用数据流重定向即可:cat xxx* >> xxx

7.参数代换：xargs 产生某个命令参数的意思,xargs可以读入stdin的数据,并且以空格符或断行字符进行分辨,将
                stdin的数据分隔成为arguments（参数）。
xargs [-0epn] command  就是将前面得到的信息通过管道和xargs作为command命令的参数
使用xargs 的原因是很多命令其实并不支持管道命令，因此我们可以通过xargs来提供该命令引用standard input之用
find /sbin -perm +7000 | xargs ls -l 因为ll不是管道命令，只能查看root所在目录，加上xargs就能查看前面
				     find输出的参数

finger account 可以取得该账号(account)的相关说明内容。

关于减号-的用途
在管道命令当中，经常会用到前一个命令的stdout来作为此次的stdin，某些命令需要用到文件名来处理时，该
stdin与stdout可以利用减号-来代替

**********************************第12章 正则表达式与文件格式处理*********************************************
正则表达式（Regular Expression）基本上是一种"表示法"，只要工具程序支持这种表示法，那么该工具程序就可
以作为正则表达式的字符串处理使用。

正则表达式和通配符是完全不一样的东西，因为通配符（wtlcard）代表的是bash槽接口的一个功能，但正则表达式
则是一种字符串处理的表达式。
举例来说,在不支持正则表达式的ls这个工具中,若我们使用"ls -l"代表的是任意文件名的文件,而"ls -l a*"代表的
是以a为开头的任何文件名的文件,但在正则表达式中,我们要找到含有以a为开头的文件,则需要这要(需搭配支持正则表达式的工具)
ls | grep -n '^a.*'

使用grep或其他工具进行正则表达式的字符串比较时，因为编码的问题会有不同的状态，因此，你最好将LANG等
变量设置为C或者en等英文语系！

基础正则表达式:
语系对正则表达式的影响：下面的练习都是使用"Lang=C"这个语系数据。为了避免编码造成的英文与数字选区问题,我们
                        需要了解下一些特殊符号。
[:alnum:]代表英文大小写字符及数字
[:alpha:]代表任何英文大小写字符
[:upper:]代表大写字符
[:lower:]代表小写字符
[:digit:]代表数字而已

grep的高级参数: grep [-A] [-B] [--color=auto] '搜寻字符串' filename
-A:后面可加数字，为after的意思，除了列出该行外，后续的n列也列出来
-B:后面可加数字，为befer的意思，除了列出该行外，前面的n列也列出来

利用[]查找集合字符:
例1: 如果我想查找test或taste这两个单词时，可以发现到，其实它们有共同的‘t?st’存在，
这个时候我们就grep -n 't[ae]st' regular_express.txt
例2: 连续编码使用"-"号。查找非小写字母加上oo开头的文件:grep -n '[^a-z]oo' regular_express.txt
     同样可以使用grep -n '[^[:lower:]]oo' regular_express.txt

行首与行尾字符^$
例1:让the只在行首列出:grep -n '^the' regular_express.txt
例2:不想开头是英文字母:grep -n '^[^a-zA-Z]' regular_express.txt
例3:找出行尾结束为小数点.的那一行:grep -n '\.$' regular_express.txt ,因为小数点具有其他意义，需要
     转义字符（\)来加以删除其特殊意义。
例4:找出空白行:grep -n '^$' regular_express.txt ,因为只有行首和行尾（^$）,所以这样就能找到空白行。
注意到，^符号在字符集合符号（中括号[]）之内与之外是不同的！在[]内代表'反向选择',在[]外则代表定义在
行首的意义。widows的断行字符（^M$）,而linux正常断行字符仅有$。

任意一个字符.与重复字符*
正则表达式当中的"."则代表绝对有一个任意字符的意思,"*"代表重复前一个0到无穷多次的意思,为组合形态；
例:找出g??d的字符串  grep -n ‘g..d’ regular_express.txt
   找出至少两个o的字符串  grep -n ‘ooo*’regular_express.txt 
   第一二个o是必须要存在的o，第三个o则是可有可无的多个o,至少两个o就要写三个o*
零个或多个任意字符: .*,因为.代表任意字符，*代表0个或多个重复前面字符。   <====常用

限定连续RE字符范围{}
因为{与}符号在shell是有特殊意义的，因此我们必须要用\转义字符来让他失去意义。
例:g后面接2到5个o,然后再接一个g的字符 grep -n ‘go\{2,5\}g’regular_express.txt 
   找到8位数字 grep '[0-9]\{8\}'

再次强调:正则表达式的特殊字符与一般在命令行输入命令的"通配符"并不相同,例如,在通配符当中的*代表的是
零到无限多个字符的意思,但是在正则表达式当中,*则是重复0到无穷多个的前一个RE字符的意思。

sed工具:sed本身也是一个管道命令,可以分析standard input的，而且sed还可以将数据进行替换、删除、新增、
        选定特定行的功能。
sed [-nefr] [动作]     -e:直接在命令行模式上进行sed的动作操作
-n:使用安静模式,在一般sed的用法中,所有来自STDIN的数据一般都会被列出到屏幕上,加上-n后，则只有经过sed
   特殊处理的那一行（或者操作）才会被列出。
-f:直接将sed的动作写在一个文件内,-f filename则可以执行filename被的sed动作
-r:sed的动作支持的是扩展型正则表达式的语法（默认是基础正则表达式的语法）
-i:直接修改读取的文件内容,而不是由屏幕输出
动作说明： [n1[,n2]] function   例: 动作需要在10到20行之间进行，则"10,20[动作行为]"
function参数:  a：新增,a的后面可以接字符串,而这些字符串会在新的一行出现（目前的下一行）
               c：替换,c的后面可以接字符串,这些字符串可以替换n1、n2之间的行
               d：删除,因为是删除,所以d后面通常不接任何参数
	       i：插入,i的后面可以接字符串,而这些字符串会在新的一行出现（目前的上一行）
	       p：打印,也就是将某个选择的数据打印出来,通常p会与参数send -n 一起运行
	       s：替换,可以直接进行替换的工作,通常这个s的动作可以搭配
sed后面接的动作，请务必以两个单引号扩住。如果sed后面要接超过两个以上的动作,每个动作前面得加-e才行。
例：仅列出/etc/passwd 文件的第5~7行 ： nl /etc/passwd | sed -n '5,7p'

部分数据的查找与替换：sed 's/要替换的字符串/新的字符串/g'
最后一行添加#This is a test:sed -i '$a # This is a test' regular.txt 。由于$代表最后一行,a是新增。

grep默认支持基础正则表达式，如果要使用扩展型正则表达式，你可以使用grep-E，不过更建议直接使用egrep。

扩展型正则表达式的特殊符号:
 +:重复一个或一个以上的前一个RE字符  例:查找god,good等字符串,'go+d'o+代表一个以上的o。
 ?:零个或一个的前一个RE字符  /  |:用或（or）的方式找出数个字符
（）:找出组字符串 例:查找glad或good这两个字符串,'g（la|oo）d'将非重复的用|分开。
（）+:多个重复组的判别 例:查找AxyzxyzC,egrep 'A（xyz）+C',查找开头是A结尾是C，中间有一个以上xyz字符串

文化的格式化与相关处理
printf '打印格式' 实际内容
\t 水平的[tab]按键   \v 垂直的[tab]按键  \f 清除屏幕 \xNN NN为两位数的数字,可以转化数字成为字符
%ns 那个n是数字,s代表string,即多少个字符  %ni 那个n是数字,i代表integer,即多少整数字数
%N,nf f代表floating(浮点)，假设我要八个位数，小数点后两位（小数点占一位）,即%10.2f：00000.00

awk:好用的数据处理工具,相比于sed常用于一整行的处理,awk则比较倾向于将一行分成数个字段处理。
因此,awk相当适合处理小型的数据处理,而默认的字段的分隔符为空格键或[tab]键。
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
处理流程：1.读入第一行，并将第一行的数据填入$0,$1,$2等变量当中。$1是第一个变量,一般是每一行第一个值。
	  2.依据条件类型的限制,判断是否需要进行后面的动作。
	  3.做完所有的动作与条件类型。
	  4.若还有后续的"行" 的数据,则重复上面1~3的步骤,直到所有的数据都读完为止。
awk怎么知道我到底这个数据有几行和几列呢？这就需要内置变量的帮忙了。
内置变量：NF:每一行($0)拥有的字段总数  / NR:目前awk所处理的是"第几行"数据 
FS:目前的分隔字符,默认是空格键,在第二行开始生效。要第一行生效的话可以预设awk的变量,利用关键字BEGIN,
   awk ‘BEGIN {FS=":"} ’
在awk的动作,即在{}内的动作,如果有需要多个命令辅助时,可以利用分号"；"间隔,或者直接以[Enter]按键来隔开每个
命令。

在每一行的每个字段都是有变量名称的,那就是$1,$2等变量名称。举个例子在last显示中root是$1，因为他是第一
列嘛！还有个变量$0则代表一整行数据的意思。
与bash、shell的变量不同,在awk当中,变量可以直接使用,不需要加上$符号。

文件比较工具
1.diff [-bBi] from-file to-file   比较两个文件之间的区别,以行为单位来比较
-b：忽略一行当中仅有多个空白的区别   -B：忽略空白行的区别   -i：忽略大小写的不同

2.cmp [-s] file1 file2        比较两个文件之间的区别,主要利用"字节"单位比较
-s：将所有的不同点的字节处都列出来,因为cmp默认仅会输出第一个发现的不同

3.patch 将旧文件升级成为新的文件 
例:制作补丁文件 diff -Naul passwd.old passwd.new > passwd.patch 
   更新  patch -pN < patch_file       还原 patch -R -pN < patch_file
-p：后面的N表示取消几层目录的意思     -R：代表还原，将新的文件还原成原来旧的文件

文件打印准备:pr

习题：找到/etc及其下面子目录中含有*的文件 grep '\*' $(find /etc/-type f),注意find找到的变量要连接$.
      如果grep '\*' /etc/*仅代表查找/etc下面第一层子目录的数据。

***********************************第13章  学习shell script********************************************************
shell scroipt是利用shell的功能所写的一个程序,这个程序是纯文本文件,将一些shell的语法与命令(含外部命令)
写在里面,搭配正则表达式，管道命令与数据流重定向等功能,以达到我们想要的处理目的。
Linux系统的服务启动的接口是在/etc/init.d这个目录下,目录下的所有文件都是script另外,包括启动(booting)
过程也是利用shell script来帮忙查找系统的相关设置数据,然后代入各个服务的设置参数。

$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录
下进行搜寻编译链接。
编辑你的 PATH 声明，其格式为：PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH N>

直接执行命令:shell.sh文件必须要具备可读与可执行(rx)的权限,然后：
 1.绝对路径:使用/home/dmtsai/shell.sh来执行命令；
 2.绝对路径:假设工作目录在/home/dmtsai,则使用./shell.sh来执行；
 3.变量"PATH"功能:将shell.sh放在PPATH指定的目录,例如: ~/bin/。
以bash进程来执行:通过"bash shell.sh"或"sh shell.sh"来执行
 
编写第一个script
1.第一行#!/bin/bash声明这个script使用的shell名称为bash(#!是用来声明shell的)
2.程序内容的说明
   read [-pt] variable  让用户由键盘输入内容，将该内容变成名为variable的变量
3.主要环境变量的声明:
   PATH=/bin:/sbin:/user/bin:/user/sbin:/user/local/bin:/user/local/sbin:~/bin
   export PATH
4.主要程序部分
5.告知执行结果。一个命令的执行成功与否可以使用$？这个变量来查看,那么我们也可以利用exit这个命令来让
  程序中断，并且回传一个数值给系统。

简单范例：
1.交互式脚本：变量内容由用户决定
2.随日期变化：利用日期进行文件的创建
3.数值运算:简单的加减乘除,在运算中,我们可以使用"declare -i total=$firstnu$secnu",也可使用var=$("(运算内容)")

script的执行方式区别（source,shscript,./script）
1.利用直接执行的方式来执行script(不论是绝对/相对路径还是$PATH内)，或者是利用bash(或sh)来执行脚本时，
  该script都会使用一个新的bash的环境来执行脚本内的命令。也就是说，使用这些执行方式时，该script都会
  使用一个新的bash环境来执行脚本内的命令。也就是说,使用这种执行方式时,其实script是在子程序的bash内
  执行的。
2.利用source来执行脚本：在父程序中执行   格式：source 脚本名

  		
善用判断式
条件判断：1.通过$?,$$,||来作为前一个命令执行回传值对于后一个命令是否要进行的依据。
          2.test命令

利用test命令的测试功能
test -e filename 表示存在否   (-f:存在且为file -d:directory -P:FIFO文件 -S:Socket文件 -L:连接文件)
test -r filename 表示可读否   (-r -w -x -u:SUID -g:SGID -k:Sticky bit -s:存在且非空白)        
test file1 -nt file2 两文件之间的比较 (-nt:newthan判断n1是否比n2新 -ot:oldthan -ef:判断是否为同一文件)
test n1 -eq n2  关于两整数之间的判定  (-eq:equal -ne -gt:greater than -lt:less -ge:大于等于 -le)
判断字符串的数据:Test -z/n string 判断字符串是否为0,若string为空字符,则为true/false.
                 test str1=str2 判断是否相等，是则返回true
多重条件判断,例如:test -r filename -a -x filename 
test -r filename -a/-o -x filename: -a表示all即filename同时满足-r,-x权限才会回传true，-o表示or。
判断文件类型和属性:
test -f $filename && filetype="regulare file"
test -d $filename && filetype="directory"
test -r $filename && perm="readable"
test -r $filename && perm="$perm writable"
test -r $filename && perm="$perm executable"  加上$perm防止x覆盖w,w覆盖r,产生的rwx只显示一个。

exit0 结束脚本
利用判断符号[]                                 <================================================
(因为[]用到很多地方,包括通配符与正则表达式,如果要在bash的语法当中使用中括号作为shell判断式时,则)
1.在中括号[]内的每个组件都需要有空格键来分隔;
2.在中括号内的变量，最好都以双引号括号起来;
3.在中括号内的常量，做好都以单或者双引号括号起来;

shell script的默认变量（$0,$1...）
脚本文件名后面加参数：/path/to/scriptname opt1 opt2 opt3 opt4
                             $0            $1   $2   $3   $4
执行的脚本用$0这个变量,第一个接的参数是$1.
$#:代表后接的参数的"个数"  
$@:代表$1(opt1),$2,$3,$4之意,每个变量都是独立的(用双引号括起来);
$*:代表$1c$2c$3c$4,其中c为分隔字符,默认为空格键
sh shxx.sh 变量1,2..:使用$0,1,2..等变量可以代替输入read" " 变量1,2..

[ -z "$HOME" ] 其实就等于 test -z "$HOME"可以用来判断$HOME这个变量是否为空。所以 [ ] 里面能用的选项
和test 语句能用的完全一样。 [ "$#" -lt 2 ]相当于test "$#" -lt 2，判断个数是否小于2.

shift:造成参数变量号码偏移
shift后面可以接数字，代表拿掉最前面几个参数的意思。

条件判断式
利用if..then:单层、简单条件判断式 if [ 条件判断式一 ] ；then 判断式一成立时，进行的内容
                                    elif [条件判断式二]；then 判断式二成立时，进行的内容
                                    else 不成立时，进行的内容
                                    fi  <==将if反过来写，结束if之意。

netstat -tuln来取得目前主机有启动的服务
#封包格式  本地IP:端口  远程IP:端口  是否监听
IP的部分说明是该服务位于哪个接口上,若为127.0.0.1则是仅对本机开放,若是0.0.0.0代表对整个Internet开放

几个常见的端口(port)与相关网络服务的关系是:
80:www    22:ssh   21:ftp    25:mail   111:RPC(远程过程调用)   631:CUPS(打印服务功能)

利用case..esac判断：case $变量名称 in
                     "第一个变量内容")
                       程序段
			；；   <==每个类型结尾使用两个连续的分号来处理！
		      "第二个变量内容")
                       程序段
			；；
                     *）       <==最后一个变量结尾内容都会用*来代表所有其他值
                       不包含第一个变量内容与第二个变量内容的其他程序执行段
			exit 1
			；；
		    esac       <==最终的case,结尾！

直接执行式:利用script.sh variable的方式来直接给予$1这个变量内容(variable) / 交互式:通过read命令.

利用函数function功能
在shell script当中的function的设置一定要在程序的最前面,这样才能够在执行时被找到可用的程序段。
function fname(){ 程序段 }


循环(loop)
while do done，until do done（不定循环）
格式 ： while [ condition ]  <==中括号内的状态就是判断式       until [ condition ]
        do			                               do			       
                程序段落 				               段落格式
	done 	             <==是循环的结束                   done

for...do...done（固定循环）
1.for var in con1 con2 con3 ...   第一次循环时，$var的内容是con1，第二次循环时，$var的内容是con2.
  do
        程序段
  done
2.for ((初始值；限制值；执行步长))
  do
        程序段
  done

连续数字1~100,(seq 1 100) seq为sequence(连续)的缩写

shell script的追踪与调试
格式：sh [-nvx] scripts.sh                -x:将使用到的script内容显示到屏幕上.
      -n:不要执行script,仅查询语法的问题; -v:在执行script前,先将script的内容输出到屏幕

在输出的信息中,在加号后面的数据其实都是命令串,由sh -x的方式来将命令执行过程也显示出来,如此用户可以判断
程序代码执行到哪一段时会出现相关的信息。

shell script的执行至少需要有r的权限,若需要直接命令执行,则需要拥有r与x的命令。

显示目前身份（用whoami）,目前所在的目录（用pwd）。

date命令:date(选项)(参数)
<+时间日期格式>：指定显示时使用的日期时间格式。
%s 从1970年1月1日00:00:00到目前经历的秒数 / %y 年的最后两个数字（1999则是99）
date_1=`date --date="$date2" +%s ` 将date2转化为到1970年经历的秒数
date_2=$((date_1/60/60/24)) 将所有秒数除以60秒60分24小时得到天数

*********************************第14章 Linux账号管理与ACL权限设置***************************************
你的主机并不会直接认识你的账号名称,它仅认识ID(ID就是一组号码)。而ID与账号对应关系就在/etc/passwd中。

用户标识符:UID,GID
当我们有要显示文件属性的需求时,系统会依据/etc/passwd与/etc/group的内容,找到UID/GID对应的账号与组名
再显示出来。
用户账号:用户如果需要登录主机来取得shell的环境来工作,首先,它必须要在计算机前面利用tty1~tty7的终端机
提供的login接口,并输入账号和密码后才能登录。如果是用过网络的话,哪要通过ssh功能。当输入密码后,系统:
1.先找寻/etc/passwd里面是否有你输入的账号,如果没有则跳出,如果有的话则将该账号对应的UID和GID读出来,
  另外,该账号的主文件夹与shell设置也一并读出来。
2.再来是核对密码表了！这时Linux会进入/etc/shadow里面找出对应账号的UID,然后核对一下输入的密码与里面
  密码是否相符。
3.如果一切OK的话,就进入shell管控的阶段了。

1./etc/passwd文件结构:
每一行代表一个账号,有几行就代表有几个账号在你的系统中！
[账号名称]:[密码]:[UID]:[GID]:[用户信息说明列]:[主文件夹]:[shell]:[/etc/shadow文件结构]
密码:早期UNIX系统的密码就是放在这个字段上！但是因为这个文件的特性是所有的程序是所有的程序都能够读取,
    这样一来很容易造成密码数据被窃取,因此后来就将这个字段的密码数据改放到/etc/shadow中了,所以这里
    你就会看到一个"x".
UID:用户标识符,id 范围：
               0(系统管理员)，系统管理员不见得只有root，不过不建议有多个账号的UID是0.
               1~499(系统账号):保留给系统使用的ID,其实除了0以外,其他的UID权限与特征并没有不一样。
                               默认500以下的数字让给系统作为保留账号只是一种习惯。
                               1~99:由distributions自行创建的系统账号
			       99~499:若用户有系统账号需求时,可以使用的账号UID
               500~65535(可登陆账号):给一般用户用的ID
GID:这个与/etc/group有关！其实/etc/group与/etc/passwd差不多,只是它是用来规定组名与GID的对应而已。
shell:为何默认shell会使用bash呢？就是在这个字段指定的,但是有一个shell可以用来替代成让账号无法取得
      shell环境的登录操作。那就是/sbin/nologin,这是用来制作纯POP邮件账号者的数据呢！

2./etc/shadow文件结构:
[账号名称]:[密码]:[最近改动密码日期]:[密码不可被更动的天数]:[密码需要重新更改的天数]:[密码需要更改期限前的警告天数]:[密码失效日]:[账号失效日]:[保留]
最近改动的时间:显示的是1970年到改动的日期经历的天数。
密码不可被更动的天数:限制几天内不可更改密码；密码需要重新更改的天数:强制用户更改密码。

有效(effetcive group)和初始用户组(initial group):group,newgrp
每个用户在他的/etc/passwd里面的第四列的GID就是所谓的初始用户组。也就是说当用户登陆系统,立即就拥有这个用户
组的相关权限的意思。但非初始用户组就不同了,举例来说,我将A加入B这个用户组当中,由于B这个用户组并非B的初始用
户组,因此,我必须要在/etc/group这个文件中找到A那一行,并且将B这个账号第四列,这样B才能够加入A这个用户组。

3./etc/group:这个文件就是记录GID和组名的对应
[用户组名称]:[用户组密码]:[GID]:[此用户组支持的账号名称]
密码已经移动到/etc/gshadow去。想要将某个账号加入用户组,将该账号填入这个字段即可。
例:让dmtsai加入root这个用户组,那么在第一行最后加上",dmtsai",注意不要有空格,使其成为"root:x:0:root,dmtsai"就可以
初始用户组第四个字段可以不需要填入字段。
groups:有效与支持用户组的查看,第一个输出的用户组为有效用户组。
newgrp:有效用户组的切换,而且是另外以一个shell来提供这个服务的(exit退出),切换的用户组必须是你已经有
       支持的用户组。
让一个用户加入不同的用户组:1.通过管理员(root)利用usermod帮你加入。
                           2.用户组管理员以gpasswd帮你加入他所管理的用户组。

4./etc/gshadow文件结构: 
[用户组名]:[密码列]:[用户组管理员的账号]:[该用户组的所属账号]
密码列:如果密码列上面是"!"时,表示该用户组不具备用户组管理员。

账号管理
新增与删除用户:useradd,相关配置文件,passwd,usermod,userdel
useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 主文件夹绝对路径] \
> [-s shell] 用户账号名
-m:强制!要创建用户主文件夹(一般账号默认值)/-M:强制!不要创建用户主文件夹(系统账号默认值)
-c:这个就是/etc/passwd的第五列的说明内容,可以随便设置。
-d:指定某个目录成为主文件夹,而不要使用默认值,务必使用绝对路径!
-r:创建一个系统的账号,这个账号的UID会有限制（参考/etc/login.defs）
   由于系统账号主要是用来运行系统所需服务的权限设置,所以系统账号默认都不会主动创建主文件夹的！

useradd参考文件: useradd的默认值可以使用下面的方法调用出来:useradd -D,这个数据其实是由
                 /etc/default/useradd调用出来的,你可以使用vim查看该文件的内容。
useradd命令作用的参考文件:/etc/default/useradd,/etc/login.defs,/etc/skel/等。

私有用户组机制:系统会创建一个与账号一样的用户组给用户作为初始用户组.保密性较强,因为每个用户都有自己
               的用户组,而且主文件夹的权限会设置为700.使用这种机制将不会参考GROUP=100这个设置值.
               代表性的distributions有REHL,Fedora,CentOS等。
公有用户组机制:就是以GROUP=100这个设置值作为新建账号的初始用户组,因此每个账号都属于user这个用户组,
               且默认文件夹通常的权限会是"drwxr-xr-x...dernameusers..."，由于每个账号都属于user用户组
               因此大家都可以互相分享主文件夹内的数据之故.代表的distributions有SuSE等。
系统上面GID为100者即是users这个用户组。由于我们的REHL使用的是私有机制,因此这个设置项目是不会生效的。
用户的主文件夹通常与账号同名的目录,并放在此设置值的目录后面,例vbird的主文件夹会在/home/vbird/中了。
INACTIVE=0/-1:密码过期后是否会失效的设置值。0代表密码过期立即失效,-1代表永不失效，如果是数字，如30
              代表过期30天后失效。
EXPIRE=: 账号失效的日期  
SHELL=/bin/bash: 默认使用的shell程序文件名
SKEL=/etc/skel: 这个就是指定用户主文件夹的参考基准目录。将来如果我想要新增用户时,该用户的环境变量~/.bashrc
                就设置妥当的话,你可以到/etc/skel/.bashrc去编辑一下,也可以新建/etc/skel/www 这个目录,将来
                新增用户后,在他的主文件夹下面就会有www那个目录了。
CREATE_MAIL_SPOOL=yes：创建用户的mailbox。

UID/GID密码参数参考:/etc/login.defs

因此,使用useradd这个程序在创建Linux的账号至少会参考：/etc/default/useradd、/etc/login.defs、/etc/skel/*
这些文件,不过最重要的其实是创建/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow,还有用户主文件夹。

passwd : 使用useradd创建账号后,默认的情况下,该账号是暂时被封锁的,也就是说该账号无法封路,这是就需要
         设置新的密码了。
passwd [--stdin] <==所有人均可以用来改自己的密码
passwd [-l] [-u] [--stdin] [-s] [-n 日数] [-x 日数] [-w 日数] [-i 日数] 账号 <==root功能
-l:是lock的意思,会将/etc/shadow第二列最前面加上！使密码失效 / -u:是Unlock的意思
-S:列出密码相关的参数,即shadow文件的大部分内容. / -n,-x,-w,-i:shadow的第4,5,6,7字段
--stdin:可以通过来自前一个管道的数据作为密码输入。

新的distributions是使用较严格的PAM模块来管理密码,这个管理的机制写在/etc/pam.d/passwd当中。而该文件与密码
有关的测试模块就是使用pam_cracklib.so,这个模块会检验密码相关的信息,并且替代/etc/login.defs内的PASS_MIN_LEN
的设置啦！

查看用户详细的密码参数:chage [-ldEImMW] 账号名
-l:列出该账号的详细参数 / -d,E后面接日期,修改shadow的第3,8字段
-m,M,W,I,E:后面接天数,修改shadow的第4,5,6,7字段
让用户在第一次登录时强制他们更改密码后才能使用系统资源:chage -d 0 账号

账号数据微调: usermod [-cdegGlsuLU] username
-a:与-G合用可增加次要用户组的支持而非设置 
-G:后接次要用户组,修改这个用户组能够支持的用户组,修改的是/etc/group
-c:后接账号的说明,即/etc/passwd第五列说明 / -d:后接账号的主文件夹,即修改/etc/passwd的第六列 
-l:后接账号名称,即是修改账号名称,/etc/passwd的第一列 / -U:将/etc/shadow密码列的!去掉。

删除用户的相关数据: userdel [-r] username 
-r:连同用户的主文件夹也一起删除

用户功能
finger [-s] username :查阅用户相关的信息
chfn [-foph] [账号名] :更改用户相关的信息
chsh [-ls] :chage shell的简写
id [username] :查询某人或自己的相关UID/GID等的信息

新增与删除用户组
groupadd [-g gid] [-r] 用户组名                添加
groupmod [-g gid] [-n group_name] 用户组名     修改
groupdel [groupname]                           删除

gpasswd :用户组管理员功能
1.关于系统管理员（root）做的动作
gpasswd groupname / gpasswd [-a user1,..] [-M user3,..] groupname / gpasswd [-rR] groupname
   若没有任何参数，表示给予groupname一个密码（/etc/gshadow）
-A:将groupname的主控权交由后面的用户管理 / -M:将某些账号加入这个用户组当中
-r:将groupname的密码删除 / -R:让groupname的密码栏失效
2.关于用户组管理员做的动作
gpasswd [-ad] user groupname
-a:将某个用户加入groupname这个用户组当中！ / -d:将某位用户删除出groupname这个用户组当中。

主机的具体权限规划:ACL的使用 (之前是通过文件权限限制所有人的读、写、执行,现在可以针对用户)
ACL是Access Control List的缩写,主要的目的是提供传统的owner,group,others的读、写、执行权限之外的具体
权限设置。ACL可以针对单一用户,单一文件或目录来进行r,w,x的权限设置,对于需要特殊权限的使用状况非常有
帮助。
如果一个文件设置了ACL参数后,它的权限部分就会多出一个+号了！
查看你的文件系统是否支持ACL:mount 查看挂载 ； dumpe2fs -h /dev/xxx 由superblock内容去查询ACL。

ACL的设置技巧:getfacl,setfacl
getfacl:取得某个文件/目录的ACL设置项目；
setfacl:设置某个目录/文件规定；

setfacl:设置某个目录/文件的ACL规定
setfacl [-bkRd] [{-m|-x} acl参数] 目标文件夹
-m:设置后续的acl参数给文件使用,不可与-x合用 / -x:删除后续的acl参数,不可与-m合用
-b:删除所有的ACL设置参数 / -k:删除默认的ACL参数,包括所谓的"默认"参数后于后续范例中介绍
-R:递归设置acl,亦即包括子目录都会设置起来 
-d:设置acl参数！只对目录有效,在该目录新建的数据会引用此默认值

getfacl:取得某个文件/目录的ACL设置项目 
getfacl filename
mask:有效权限,用户或组所设置的权限必须要存在于mask的权限设置范围内才会生效,此即有效权限。我们可以通过使用
     mask来规定最大允许的权限,就能避免不小心开放某些权限给其他用户或用户组了。

ACL的特殊权限:
1.针对特定用户的方法：
设置规定:" u:[用户账号列表]:[rwx] " 例如针对vbird的权限规定rx: setfacl -m u:vbird:rx 文件名
2.针对特定用户组的方法：
设置规范:" g:{用户组列表}:[rwx]" 例如针对mygroup的权限规范rx: setfacl -m g:mygroup:rx 文件名
3.针对有效权限mask的设置方法：
设置规定:" m:[rwx]" 例如针对刚才的文件规定为仅有r: setfacl -m m:r 文件名
4.针对默认权限的设置方法：
设置规范: "d:[ug]:用户列表:[rwx]"

身份切换可使用su,也可使用sudo,但使用sudo则必须先以visudo设置可使用的命令.
su [-lm] [-c 命令] [username]
-:单纯使用-如"su -",代表使用login-shell的变量文件读取方式来登录系统,若用户名称没有加上去,则代表
  切换为root的身份。单纯的"su"切换成为root的身份,读取的变量设置方式为non-login shell的方式。这种
  方式下很多原本的变量不会被改变。
-l:与 - 类似,但后面需要加欲切换的用户账号.也是login-shell的方式。
-c:仅进行一次命令。

exit:可以离开su的环境。

sudo相对于su需要了解新切换的用户密码,sudu的执行则仅需要自己的密码即可！甚至可以设置不需要密码即可
执行sudo呢！由于sudo可以让你以其他用户的身份执行命令,因此并非所有人都能执行sudo,而是仅有/etc/sudoers
内的用户才能够执行sudo这个命令。
sudo [-b] [-u 新用户账号] 命令
-b:将后续的命令让系统自行执行,而不与目前的shell产生影响
使用sh -c的方法来执行一连串的命令。

visudo命令设置将用户、用户组加入到/etc/sudoers:
除了root以外的其他账号,若想要使用sudo执行属于root的权限命令,则root需要先使用visudo去修改/etc/sudoers
让该账号能够使用全部或部分的root命令功能。

一般来说,visudo的设置方法有几种简单方法：
1.单一用户可进行root所有命令与sudoers文件语法
visudo 命令 :其实visudo只是利用vi将/etc/sudoer文件调出来进行修改而已,所以这个文件就是/etc/sudoerds。这个
             文件设置其实很简单,如果你找到76行(有root设置的那行)左右,看到的数据就是：
[用户账号] [登陆者的来源主机=(可切换的身份)]  [可执行的命令]

2.利用用户组以及免密码的功能处理visudo
在最左边加上%,代表后面接的是一个用户组的意思：%group  ALL=(ALL)  ALL
如果组内用户不需要输入密码则：%group ALL=(ALL) NOPASSWD:ALL

3.有限制的命令操作
上面两点都会让用户能够利用root的身份进行任何事情,这样总是不太好。如果我想让用户仅能进行部分系统任务,
例如:user1仅可以使用passwd命令帮忙root修改其他用户密码
user1 ALL=(root) /user/bin/passwd <=最后命令务必使用绝对路径。 
但要注意限制修改root密码:xxx ALL=（root） ！/user/bin/passwd,/user/bin/passwd [A-Za-z]*,!/user/bin/passwd root

4.通过别名设置visudo
User_Alias/账号别名命令 账号别名=实际账号
Cmnd_Alias/命令别名命令 账号别名=实际命令
例:将pro1,pro2,pro3加入上诉的密码管理员的sudo列表,那我可以新建一个账户别名为ADMPW的名称
User_Alias ADMPW=pro1,pro2,pro3
Cmnd_Alias ADMPWCOM= ！/user/bin/passwd,/user/bin/passwd [A-Za-z]*,!/user/bin/passwd root
ADMWP ALL=(root) ADMWPCOM
账号名称一定要用大写字符来处理,包括Host_Alias(来源主机别名),命令别名等。最后一行则写入账号与命令别名
将来要修改时，只要修改上面两行即可！

5.sudo的时间间隔问题
两次执行sudo的间隔在五分钟内,那么在执行sudo时就不需要再次输入密码了。

6.sudo搭配su的使用方法
将大量需要执行的工作一口气将身份转为root,而且还用用户自己的密码来变成root。
例:将pro1,2,3用户只要输入sudo su-,并且输入自己的密码,立刻变成root用户。
User_Alias ADMPW=pro1,pro2,pro3
ADMWP ALL=(root) /bin/su -

特殊的shell,/sbin/nologin
我们所谓的"无法登陆"指的仅是这个用户无法使用bash或其他shell来登录系统而已,并不是说这个账号就无法使
用其他的系统资源。

PAM模块简介/etc/pam.d/*
PAM可以说是一套应用程序编程接口(API),它提供了一连串的验证机制,只要用户将验证阶段的需求告知PAM后，
PAM就能够回报用户验证的结果（成功或失败）。

我们以passwd这个命令调用PAM时,这个程序调用PAM的流程是:
1.用户开始执行/usr/bin/passwd这支程序,并输入密码；
2.passwd调用PAM模块进行验证；
3.PAM模块会到/etc/pam.d/中找寻与程序(passwd)同名的配置文件；
4.依据/etc/pam.d/passwd内的设置,引用相关的PAM模块逐步进行验证分析；
5.将验证结果回传给passwd这个程序；
6.passwd这支程序会根据PAM回传的结果决定下一个操作(重新输入新密码或者通过验证！)；

[验证类型] [控制标准] [PAM模块与该模块的参数]
验证类型分为auth(认证)、account(账号)、session(会议期间)、password(密码)
验证的控制方式分为required、requisite、sufficient、optional

PAM用来进行验证的数据称为模块。
/etc/pam.d/* :每个程序个别的PAM配置文件            /etc/security/* :其他PAM环境的配置文件
/lib/security/* :PAM模块文件的实际放置目录         /user/share/doc/pam-*/ :详细的PAM说明文件

其他相关文件
1. limit.conf /etc/security/limits.conf [账号] [限制依据] [限制项目] [限制值]
   第一字段为账号,或者用户组！若为用户组则前面加上@,例如@projects.
2. /var/log/secure /var/log/messages  出现问题可以在这里面查看！

Linux主机上的用户信息传递
1.查询用户:w,who,last,lastlog
  如果你想知道目前已经登录在系统上面的用户:w,who查询
  如果你想知道每个账户的最近登录的时间:lastlog命令,lastlog会去读取/var/log/lastlog文件,然后将数据输出
2.用户对谈:write,mesg,wall
  write 用户账号 [用户所在终端接口]
  mesg n 不想接受信息
  wall 对所有系统上面的用户传达信息（广播）
用户邮件邮箱:mail

手动新增用户
1.一些检查工具
pwck：这个命令会检查/etc/passwd这个账号配置文件内的信息,与实际的文件夹是否存在等信息,还可以比较
      /etc/passwd /etc/shadow的信息是否一致,另外,如果/etc/passwd内的数据字段错误时,会提示用户修改
pwconv:这个命令主要是将/etc/passwd内的账号与密码移动到/etc/shadow当中！
chpasswd:可以读入未加密前的密码,并且经过加密后,将加密后的密码写入/etc/shadow当中。

2.特殊账号(如纯数字账号)的手工新建
新建一个账号并且属于用户组
1.先新建所需要的用户组(vi /etc/group)   2.将/etc/group与/etc/gshadow同步(grpconv)
3.新建账号的各个属性(vi /etc/passwd)    4.将/etc/passwd与/etc/shadow同步(pwconv)
5.新建该账号的密码(passwd accountname)  6.新建用户主文件夹(cp -a/etc/skel/home/accountname)
7.更改用户文件夹的属性(chown -R accountname.group/home/accountname)

3.批量新建账号模板(适用于passwd--stdin参数): http://linux.vbird.org/linux_basic/0410accountmanager/account1.sh

例题:1.如果我要让test这个账号具有root的权限,应该怎么做？
       答:将/etc/passwd里,test的UID和GID栏位变成0即可。
     2.如果我想让一个账户暂时失效,但不删除,该怎么做?(使用3种不同方法)
       答:1.将/etc/passwd的shell栏位写成/sbin/nologin
	  2.将/etc/shadow内的密码栏位增加一个*号在最前面
	  3.将/etc/shadow的第八个栏位关于账号取消日期的那个,设置小于目前日期的数字
     3.我希望在我设置每个账号的时候(使用useradd),默认的情况中,他们的主文件夹就含有一个名称为www的子
       目录,我应该怎么做?
       答:由于使用useradd的时候,会自动以/etc/skel作为主文件夹,所以,我可以在/etc/skel里面新增加一个
	  名称为www的目录即可。
     4.如果我需要将用户主文件夹以后都放置到/account这个目录下，我该如何做才可以使用useradd时默认的
       主文件夹就指向/account？
       答:最简单的办法,编辑/etc/default/useradd,将里头的HOME=/home改成HOME=/account即可。

***********************************第15章 磁盘配额与高级文件系统管理********************************
磁盘配额(Quota)的应用与实践
限制因素:1.仅针对整个文件系统 2.内核必须支持quota 3.只对一般用户有效 4.Quota的日志文件
规范设置选项:1.容量限制与文件数量限制 2.宽限时间grace time（介于soft与hard之间）

1>.实践Quota流程1:文件系统支持
df -h /home 如果你的sda5是挂载在/home下面,检查/home是否是个独立的文件系统。
mount | grep home   由于VFAT文件系统并不支持Linux Quota功能,所以我们mount查询一下/home文件系统
如果只是想要在这次开机中实验Quota,那么可以使用一下方式手动添加:
mount -o remount,userquota,grpquota /home
mount | grep home  当你重新挂载时,系统会同步更新/etc/mtab这个文件,所以你必须要确定/etc/mtab已经加入
                   userquota,grpquota(用户和用户组的文件系统支持参数)的支持到你所想要设置的文件系统中。
不过手动挂载的数据在下次重新挂载就会消失,因此最好写入配置文件中/etc/fstab。
vi /etc/fstab   ->  LABEL=/home  /home  ext3 defaults,userquota,grpquota 1 2

2>.实践Quota流程2:新建Quota配置文件
其实Quota是通过分析整个文件系统中的每个用户(组)拥有的文件总数与总容量,再将这些数据记录在该文件系统的最
顶层目录,然后在该配置文件中再使用每个账号(或组)的限制值去规定磁盘使用量的。

quotacheck:扫描文件系统并新建Quota的配置文件   quotacheck [-avugfM] [/mount_point]
-a:扫描所有在/etc/mtab内,含有quota支持的文件系统,加上此参数后,/mount_point可不必写,因此扫描所有文件系统
-u/-g:针对用户/用户组扫描文件与目录的使用情况,会新建aquota.user/aquota.grp。
-v:显示扫描过程的信息   -f:强制扫描文件系统,并写入新的quota配置文件(危险) 
-M:强制以读写的方式扫描文件系统,只有在特殊情况下使用。
注:-f,M是在文件系统已经可能启动quota但你还想重新扫描文件系统时，系统会要求你加入那两个参数。一般只
   -avug一起执行即可。

3>.实践Quota流程3:Quota启动、关闭与限制
使用Quotaon启动,Quotaoff关闭:     
①quotaon[-avug]  quotaon[-vug][/mount_point]
-u:针对用户启动quota(aquota.user)  / -g:针对用户组启动quota(aquota.group)
-a:根据/etc/mtab内的文件系统设置启动相关的quota,若不加-a的话,则后面需要加特定的那个文件系统
-v:显示启动过程的相关信息 
②quotaoff [-a]   quotaoff [-ug] [/mount_point]
-a:全部的文件系统的quota都关闭(根据/etc/mtab)   -u:仅针对后面接的那个/mount_point关闭user quota
-g:仅针对后面接的那个/mount_point关闭group quota
③edquota:编辑账号/用户组的限值与宽限时间
edquota [-u username] [-g groupname]  /  edquota -t  <==修改宽限时间
edquota -p 范本账号 -u 新账号   : -p复制范本,将范本账号这个人的quota限值值复制给新账号。
[文件系统][磁盘容量][磁盘容量soft限制值][block的hard限制值][文件数量][inode的soft限制值][inode的hard限制值]
在edquota的界面中,每一行只要保持七个字段就可以了,并不需要排列整齐的！

4>.时间Quota流程4:Quota限制的报表
quota的报表主要有两种模式,一种是针对每个个人或用户组的quota命令,一个是针对整个文件系统的repquota命令
①quota:单一用户的quota报表
quota [-uvs] [username] / quota [-gvs] [groupname]
-u:后面可以接username,表示显示出该用户的quota限制值。若不接username,表示显示出执行者的quota限制值
-g:后面可以接groupname,表示显示出该用户组的quota限制值。
-v:显示每个用户在文件系统中的quota值  / -s:使用1024的倍数来指定单位,会显示如M之类的单位
②repquota:针对文件系统的限额做报表   repquota -a [-vugs]
-a:直接到/etc/mtab查询具有quota标志的文件系统,并报告quota的结果.
-v:输出的数据将含有文件系统相关的详细信息 / -u:显示出用户的quota限制(这是默认值)
-g:显示出个别用户的quota限值 / -s:使用M,G为单位显示结果

5>.实践Quota流程5:测试与管理
①warnquota:对超出限额者发出警告信
  依据/etc/warnquota.conf的设置,然后找出目前系统上面quota用量超过soft(就是有gracetime出现的哪些家伙)
  通过Email的功能将警告信息发送到用户的电子邮箱信箱。
②如何让系统自动执行warnquota
③setquota:直接与命令中设置quota权限
  setquota [-u|-g] 名称 block(soft) block(hard) inode(soft) inode(hard) 文件系统

6.使用Link连接来实现不改动既有系统的Quota进行限制(需要符合SELinux规则)。

软件磁盘阵列(software RAID)
为了将系统可以实时地在坏掉硬盘时重建,因此就需要预备磁盘(spare disk)的辅助。
为何磁盘阵列又分为硬件与软件呢？所谓的硬件磁盘阵列是通过磁盘阵列卡来完成数组的目的。磁盘阵列卡上面
一块专门的芯片在处理RAID的任务，因此在性能方面会比较好。硬件磁盘阵列在linux下面看来就是一块实际的大
硬盘,因此硬件磁盘阵列的设备文件名为/dev/sd[a-p],因为使用到SCSI的模块之故。至于软件磁盘阵列通过软件
来仿真数组的任务,使用的设备文件名是系统的设备文件(/dev/md[0-9]),因此会损耗较多的系统资源。
 
软件磁盘阵列的设置(新建和查看)
mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N --level=[015] --spare-devices=N /dev/sdx .. 
mdadm --detail /dev/md0       --detail:后面接的那个磁盘阵列设备的详细信息
--create:为新建RAID的参数  /  --auto=yes:决定新建后面接的磁盘作为磁盘阵列的设备,即/dev/md0等
--raid-devices=N:使用几个磁盘作为磁盘阵列的设备 / --spare-devices=N:使用几个磁盘作为备用(spare)设备
--level=[015]:设置这组磁盘阵列的等级,支持很多RAID-0、RAID-1等，不过建议只要用0,1,5即可

你也可以查阅以下的文件来看看系统软件磁盘阵列的情况:cat /proc/mdstat

格式化与挂载使用RAID:mkfs -t ext3 /dev/md0   mkdir /mnt/raid   
	             mount /dev/md0 /mmt/raid         df查看

仿真RAID错误的救援模式
mdadm --manage /dev/md[0-9] [--add 设备] [--remove 设备] [--fail 设备]
--add:会将后面的设备加入到这个md中！     --remove:会将后面的设备从这个md中删除。
--fail:会将后面的设备设置成为出错的状态。
1.设置磁盘为错误  
2.将出错的磁盘删除并加入新磁盘:首先我们再新建一个新的分区,这个分区要与其他分区一样才好！然后在利用
  mdadm删除错误的并加入新的！
 
开机自启动RAID并自动挂载
新的distribution大多会自己查询/dev/md[0-9]，然后在开机的时候给予设置好的所需要的功能。不过还是建议
修改配置文件。RAID也是有配置文件的(/etc/mdadm.conf)。文件内容很简单,你只要知道/dev/md0的UUID就能够
设置这个文件了。
madadm --detail /dev/md0 | grep -i uuid   #后面那一串数据就是这个设备向系统注册的UUID标识符
vi /etc/mdadm.conf                        #开始设置madadm.conf
vi /etc/fstab                             #开始设置开机自动挂载并测试

关闭软件RAID(重要!)
umount /dev/md0    vi /etc/fstab          #先卸载且删除配置文件内容与这个/dev/md0有关的设置
madam --stop /dev/md0                     #直接关闭/dev/md0的方法
cat /proc/mdstat                          vi /etc/mdadm.conf                           

逻辑卷管理器（LVM / Logical volume manager）
LVM的重点在于可以弹性调整文件系统的容量！而并非在于性能与数据保全上面。LVM可以整合多个物理分区或将
其从这个LVM管理的磁盘当中删除。

什么是LVM:PV,PE,VG,LV的意义
LVM的作法是将几个物理的分区(或磁盘通过软件组合成为一块看起来是独立的大磁盘VG),然后将这块大磁盘在经过
分成可使用的分区LV,最后就能够挂在使用了。
1.PhysicalVolume,PV,物理卷
  我们实际的分区需要调整系统标识符（system ID）成为8e（LVM的标识符）,然后再经过pvcreate的命令将它转
  成LVM最底层的物理卷（PV）,之后才能够将这些PV加以利用,调整system ID的方式就是通过fdisk。
2.Volume Group,VG,卷用户组
  所谓的LVM大磁盘就是将许多的PV整合成这个VG,所以VG就是LVM组合起来的大磁盘。这个大磁盘的容量与PE有关,
  因为每个VG最多仅能包含65534个PE而已。如果使用LVM默认的参数,则一个VG最大可达256GB容量。
3.Physical Extend,PE,物理扩展块
  PE是LVM最小的储存块,为了方便用户利用LVM来管理系统,因此LV的设备文件名通过指定为/dev/vgname/lvname
  的样式。
  LVM可弹性更改文件系统的容量是通过交换PE来进行数据转换,将原本LV内的PE移动到其他设备中以降低LV容量,
  或将其他设备的PE加到此LV中以加大容量。
4.实现流程
  实际partition阶段->PV阶段->VG阶段->LV阶段->文件系统使用阶段
  利用LV来进行系统的挂载时,数据写入这个LV时,到底它是怎么写入硬盘当中的?依据写入机制不同,有两种方式:
  ①线性模式(linear):假如我将/dev/hda1,/dev/hdb1这两个分区加入到VG当中,并且整个VG只有一个LV时,那么所
                     谓的线性模式就是/dev/hda1的容量用完之后,/dev/hdb1的硬盘才会被使用到。
  ②交错模式(triped):将一条数据拆成两部分,分别写入/dev/hda1与/dev/hdb1的意思。感觉有点像RAID 0。如此
                     一来,一份数据用两块硬盘来写入。

实践阶段:1.分区，设置分区容量,且systemID需要为8e；2.将分区整合成为一个VG,且PE的大小为16MB；
         3.全部的VG容量都丢给LV；                 4.格式化LV为ext3的文件系统,且挂载

PV阶段:pvscan 查询目前系统里面任何具有PV的磁盘；  pvcreate 将物理分区新建成为PV
       pvdisplay 显示出目前系统上面的pv状态；     pvremove 将pv属性删除,让该分区不具有pv属性
VG阶段:vgscan 查找系统上面是否有VG存在；          vgcreate 新建VG的命令
       vgdisplay 显示目前系统上面的VG状态；       vgextend 在VG内增加额外的PV
       vgreduce 在VG内删除PV；                    vgchange 设置VG是否启动(active)
       vgremove 删除一个VG；
       与PV不同的是,VG的名称是可以自定义的！我们知道PV的名称其实就是分区的设备文件名,但VG名称可以随便
       vgcreate [-s N[mgt]] VG名称 PV名称  -s:后面接PE的大小,单位可以是m,g,t
LV阶段:创造出VG这个大磁盘之后,再来就是要新建分区。这个分区就是所谓的LV。（名称必须使用全名）
       lvcreate 新建LV；    lvscan 查询系统上面的LV；    lvdisplay 显示系统上面的LV状态；
       lvextend 在LV里面增加容量；   lvreduce 在LV里面减少容量；    lvremove 删除一个LV；
       lvresize 对LV进行容量大小进行调整；
       lvcreate [-L N[mgt]] -s [-n LV名称] VG名称 / lvcreate [-l N] [-n LV名称] VG名称
       -L:后接容量,大小为PE的倍数   -l:后面接PE的个数  
特别注意的是VG名称可以是vbirdvg，但LV的名称必须使用全名/dev/vbirdvg/vbirdlv（例子）。其实LV的名称构
建成为/dev/vbirdvg/vbirdlv是为了用户直观找到我们所需要的数据,实际上LVM使用的设备是放置在/dev/mapper
目录下的！
 
文件系统阶段
格式化,挂载,查看我们的LV吧！mkfs ->mkdir ->mount ->df
放大LV容量:1.用fdisk设置新的具有8e systemID的分区      2.利用pvcreate构建PV
           3.利用vgextend将PV加入我们的VG中            4.利用lvresize将新加入的PV内的PE加入LV中
           5.通过resize2fs将文件系统的容量确实增加(通过在文件系统增加block group的方式增加文件系统的量)
             resize2fs [-f] [device] [size]   ：-f 强制进行resize的操作
缩小LV容量:先查看需要卸载的磁盘的容量情况pvdisplay、pvscan，然后卸载umount /mnt/lvm ,e2fsck检查磁盘
           然后在resize2fs  [device]  缩减后的size，重新挂载/mnt/lvm与device，并且df查看/mnt/lvm，
           然后lvresize -l -number（缩小磁盘的PE数） [device] 这样就将LV缩小了,lvdisplay查看
           接下来就要将磁盘移出VG之外了,首先需要确定磁盘里面的PE完全不被使用后才能抽离,pvdisplay观察
           是否PE被使用,如果被使用,pvmove将PE移动到另一个磁盘。然后将磁盘移出VG中vgreduce，并pvscan查看
           最后pvremove。
LVM的系统快照:lvcreate [-l N] -s -n 快照区的设备名称 被快照的LV完整文件名
              -s:snapshot快照功能的意思
              快照区的新建:下面操作主要增加需要的VG容量,然后再通过lvcreate -s的功能新建快照区。
LVM的设备的关闭并删除：1.先卸载系统上面的LVM文件系统（包括快照与所有LV）
 		       2.使用lvremove删除LV；3.使用vgchange -an VGname 让VGname这个VG不具有Active标志
                       4.使用vgremove删除VG；5.使用pvremove删除PV；
                       6.最后,使用fdisk将ID修改回来。

************************************第16章 例行性工作***************************************************
Linux工作调度的种类:at,cron
例行性的工作调度:crontab这个命令所设置的工作将会循环一直进行下去。可循环的时间为分钟、小时、每周等,
                 crontab除了可以使用命令执行外,也可以编辑/etc/crontab来支持。至于让crontab生效的服务
                 则是crond这个服务。
突发性的工作调度:at是个可以处理仅执行一次就结束调度的命令,不过要执行at必须要有atd这个服务的支持才行。

常见的例行任务:进行日志文件的替换log rotate,日志文件分析logwatch的任务，新建locate的数据库,
               whatis数据库的建立,RPM软件日志文件的新建,删除临时文件,与网络服务有关的分析行为。

《仅执行一次的工作调度:atd的启动与at运行的方式》
启动atd:/etc/init.d/atd restart,并且设置开机启动chkconfig atd on ；                          
1.我们使用at这个命令来生成所要执行的工作,并将这个工作以文本文件的方式写入/var/spool/at/目录内,该工作
便能等待atd这个服务的取用与执行了。
2.我们可以利用/etc/at.allow与/etc/at.deny这两个文件来进行at的使用限制,防止被黑客程序绑架
  ①先寻找/etc/at.allow这个文件，写在这个文件中的用户才能使用at,没有在这个文件中的用户则不能使用at(即使没
    有写在/etc/at.deny)；
  ②如果/etc/at.allow不存在,就寻找/etc/at.deny这个文件,若写在at.deny的用户则不能使用at,而没有在这个文件中
    的用户就可以使用at；
  ③如果两个文件都不存在,那么只有root可以使用at这个命令；

实际运行单一工作调度
at [-mldv] TIME     /  at -c 工作号码
-m:当at的工作完成后,以email通知用户工作完成。 -l:at -l相当于atq,列出目前系统上面的所有该用户的at调度
-d:at -d相当于atrm，可以取消一个在at调度中的工作  -v:可以使用较明显的时间格式列出at调度中的任务列表
-c:可以列出后面接的该项工作的实际命令内容  TIME:可以定义什么时候要进行at这项工作的时间

最后,输入[ctrl]+d就会出现<EOF>的字样,代表结束！

注:当我们使用at时会进入一个at shell的环境来让用户执行工作命令,此时建议你最好使用绝对路径来执行你的
   命令.由于命令的执行与PATH变量有关,同时与当时的工作目录也有关联。

at的执行与终端机环境无关,而所有standard output/standard error output都会传送到执行者的mailbox去啦!

at有另一个优点就是后台执行的功能！
由于在at工作调度的使用上,系统会将该项at工作独立出你的bash环境中，直接交给系统的atd程序来接管，因此
当你执行at的工作之后就可以立即脱机,剩下的工作就完全交给LINUX管理即可！

at工作的管理:
atq 查询目前主机上面有多少的at工作调度 
atrm 删除at工作调度

如果你是在一个非常忙碌的系统下运行at,能不能指定你的工作在系统较闲的时候才进行？使用batch命令试试。
batch:系统有空时才进行后台任务,会在CPU工作负载小于0.8的时候,才进行你所执行的工作情况。

《循环执行的例行性工作调度:cron控制》
1.与at相似,我们可以利用/etc/cron.allow和/etc/cron.deny这两个文件限制使用crontab的用户账号。
2.当用户使用crontab这个命令来新建工作调度之后,该项工作就会被记录到/var/spool/cron里面去了,而且是以账
  号来作为判别的。但请注意,不要使用vi直接编辑该文件,因为可能由于输入语法错误,会导致无法执行cron.另外,
  cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中,所以你可以查询这个文件来判断主机是否被
  植入木马。
crontab [-u username] [-l|-e|-r]
-u:只有root才能进行这个任务,也即帮其他用户新建/删除crontab工作调度
-e:编辑crontab的工作内容  -l:查询crontab的工作内容  -r:删除所有crontab的工作内容,若只删除一项,-e编辑

[分钟][小时][日期][月份][周][命令]                                   <<<================================ 
特殊符号:*星号代表任何时刻都接受  ,逗号代表分隔时段的意思  -减号代表一段时间范围内 
         /n斜线代表每隔n单位间隔进行一次

系统的配置文件:/etc/crontab
基本上,cron这个服务的最低检测限制是"分钟",所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面
的数据内容,因此,只要你编辑完/etc/crontab这个文件,并且将它保存后,那么cron的设置就自动回来执行了！

/etc/crontab这个文件里面支持两种执行命令的方式:
1.命令类型  例: 01  * * * * dmtsai mail -s "testing" kiki < /home/dmtsai/test.txt
            析: 以dmtsai这个用户的身份,在每小时执行一次mail命令。
2.目录规划  假设你有一个目录,让系统可以每隔一段时间去执行该目录下的所有可执行文件,可以使用run-parts
            这是一个bash script会将目录内的所有文件找出来执行。
            例: */5 * * * * root run-parts /root/runcron
            析: 新建一个/root/runcron的目录,将要每隔五分钟执行的"可执行文件"都写到该目录下,就可以让
                系统每五分钟执行一次该目录下的所有可执行文件。
            例: 01 * * * * root run-parts /etc/cron.hourly
            析:后面的命令你可以使用"which run-parts"看看,其实那是一个bash script。如果你直接进入/usr/bin/run-parts
               去看看,会发现这个命令会将后面接的"目录"内的所有文件找出来执行！也就是说如果你想系统每小时
               主动帮你执行某个命令,将该命令写成script,并将该文件放置到/etc/cron.hourly目录即可。
一些注意事项:
1.资源分配不均的问题；
2..取消不必要的输出选项:使用数据重定向直接以命令重定向将输出的结果输出到/dev/null这个垃圾桶就好了；
3.安全的检测:可以检查/var/log/cron的内容来查看是否有非你设置的cron被执行；
4.周与日、月不可同时并存；

可唤醒停机器件的工作任务
anacron命令在于处理非24小时一直启动的Linux系统的crontab的执行。所以anacron并不能指定何时执行某项任务
而是以天为单位或者是开机后立即进行anacron的操作,它会去检测停机期间应该进行但没有进行的crontab任务,
并将该任务执行一遍,然后anacron就会自动停止了。
anacron运行的时间通常有两个,一个是系统开机期间运行,一个是写入crontab的调度中。这样才能够在特定时间
分析系统未进行的crontab工作。

anacron [-sfn] [job].. / anacron -u [job]..
-s:开始连续执行各项工作(job),会依据时间记录文件的数据判断是否进行
-f:强制进行,而不去判断时间记录文件的时间戳;      -n:立即进行未进行的任务,而不延迟等待时间
-u:仅更新时间记录文件的时间戳,不进行任何工作;    job:由/etc/anacrontab定义的各项工作名称

所以我们发现其实/etc/cron.daily/0anacron仅进行时间戳的更新,而没有进行任何anacron的操作。在我们的CentOS中,
anacron的进行其实是在开机完成后才进行的一项任务,你也可以将anacron排入ceontab的调度中。但是为了担心anacron
误判时间参数,因此/etc/cron.daily/里面的anacron才会在文件名之前加个0,让anacron最先进行,就是为了时间戳先更新
以避免anacron误判crontab尚未进行任何工作的意思。

anacron若执行"anacron -scron.daily"时,它会这样运行:
1.由/etc/anacrontan分析到cron.daily这项工作名称的天数为1天；
2.由/var/spool/anacron/cron.daily取出最近一次执行anacron的时间戳；
3.由上个步骤与目前时间比较,若差异天数为1天以上(含1天),就准备进行命令；
4.若准备进行命令,根据/etc/anacrontab的设置延迟65分钟；
5.延迟时间过后,开始执行后续明理路,即"run-part /etc/cron.daily"这串命令；
6.执行完毕后,anacron程序结束；

举例来说,如果我的主机是在20090315(周末)18:00关机,然后在20090316(周一)8:00开机,由于我的crontab是在早上04:00
左右进行各项任务,由于该时刻系统是关机的,因此时间戳依旧是20090315,但目前时间已经是20090316,因此run-part 
/etc/cron.daily就会在开机过65分钟开始运行。

确定开机执行anacroon: chkconfig --list anacron

系统每天,每周,每月各有进行什么工作可以通过/etc/cron.daily/,/etc/cron.week/,/etc/cron.monthly/这三个
目录内查看。

************************************第17章 程序管理与SELinux初探*******************************************

SELinux全称为Security-Enhanced Linux是美国国家安全局在Linux开源社区帮助下开发的一个MAC强制访问控制的
安全子系统，在红帽RHEL7系统中启用SELinux技术的目的是为了让各个服务进程都受到约束，仅能获取到服务本应
获取到的资源。例如您在自己的电脑上下载了一个美图软件，正在全神贯注得把自己P瘦点的时候，这款软件却在
后台默默监听着浏览器中输入的密码信息，这显然不应该是这款美图软件本应做的事情（即便是访问电脑中的图片
资源都情有可原），SELinux安全系统就是为了杜绝此类情况而设计的，它能够从多方面进行违法行为监控，首先
是对服务进程进行功能限制，SELinux域限制技术让服务程序做不了出格的事情，其次还能够对文件进行资源限制，
SELinux安全上下文让文件只能被所属于的服务程序所获取到。


一个程序被加载到内存当中运行,那么内存内的那个数据就被称为进程。
触发任何一个事件时,系统都会将它定义成为一个进程,并且给予这个进程一个ID,称为PID,同时依据触发这个进程
的用户与相关属性关系，给予这个PID一组有效的权限设置。
fork and exec:过程调用的流程；系统或网络服务:常驻于内存的进程；

工作管理(job control)
由于假设我们只有一个终端,因此在可以出现提示符让你操作的环境就称为前台(foreground),至于其他工作就可
以让你放入后台去暂停或运行。要注意的是,放入后台的工作想要运行时,它必须不能够与用户互动。举例来说,
vim绝对不可能在后台里面执行(running)。因为你没有输入数据它就不会跑。而且放入后台的工作是不可以使用
[ctrl]+c来终止的！
总之,要进行bash的job control必须要注意的限制是:
这些工作所触发的进程必须来自于你shell的子程序（只管理自己的bash）；
前台:你可以控制与执行命令的这个环境成为前台(foreground)工作；
后台:可以自行运行的工作,你无法使用[ctrl]+c终止它,可使用bg/fg调用该工作；
后台中"执行"的进程不能等待terminal/shell的输入(input)；

进行job控制的命令有哪些?              <<< <=======================================================
1.直接将命令丢到后台中"执行"的"&"。     2.将目前的工作丢到后台中"暂停":ctrl-z。+代表最后一个被丢到后台的工作。
3.查看目前的后台工作状态:jobs [-lrs]。  -l列出PID号码,-r仅列出正在后台run的工作,-s仅列出正在后台暂停的工作
4.将后台工作拿到前台来处理:fg %jobnumber。jobnumber为工作号码(数字),那个%可有可无。
5.让工作在后台的状态变成运行中:bg %jobnumber。
6.管理后台当中的工作:kill -signal %jobnumber / kill -l
  -l:列出目前kill能够使用的信号有哪些；
  signal:代表给予后面接的那个工作什么样的指示。用man 7 signal可知:
  -1:重新读取一次参数的配置文件(类似reload)； -2:代表由键盘输入[ctrl]-c同样的操作；
  -9:立即强制删除一个工作；                   -15:以正常的程序方式终止一项工作。

脱机管理问题:
nohup [命令与参数] & <==加上&表示在终端机后台中工作，去掉&表示在前台工作。

进程的查看
ps：将某个时间点的进程运行情况选取下来
ps aux 查看系统所有的进程数据  ps -lA 也是能够查看所有系统的数据  ps axjf 连同部分进程树的状态

ps -l:仅查看自己的bash相关进程
[进程标志][进程状态][UID][PID][PPID][CPU使用率][CPU执行优先级][优先级][所在内存部分][用掉内存][进程运行状态][登陆者终端机位置][使用掉的CPU的时间][触发进程的命令]
F进程标志:说明这个进程的权限,常见号码有,若表示此进程的权限为root,为1则表示此子程序仅可进行复制而无法实际执行
S进程状态:常见的状态有 R:running S:sleep D:不可唤醒的睡眠状态 T:stop Z:zombie,僵尸状态,进程已经终止但无法被删除至室外
PRI/NI:优先级数值越小代表进程越快被CPU执行。
TTY:登陆者的终端机位置,若为远程登录则使用动态终端接口(pts/n)。
TIME:使用掉的CPU时间,注意,是此进程实际花费CPU运行的时间,而不是系统时间。
CMD:就是command的缩写,造成此程序的触发进程的命令为何。

ps aux
%MEN:该进程所占用的物理内存百分比  VSZ:该进程使用掉的虚拟内存量  RSS:该进程占用的固定的内存量
STAT:该进程目前的状态  START:该进程被触发启动的时间  TIME:该进程实际使用CPU运行的时间

top:动态查看进程的变化
top [-d 数字] | top [-bnp]
-d:后面接秒数,就是整个进程界面更新的秒数  
在top执行过程中可以使用的按键命令: ?:显示在top当中可以输入的按键命令 P:以CPU的使用资源排序显示
                                   M:以内存的使用资源排序显示  N:以PID排序显示  T:由该进程使用的CPU时间积累排序
				   K:给予某个PID一个信号 r:给予某个PID重新制作一个nice值 q:离开top软件

我们自己的PID可由$$变量取得,请使用top持续查看该PID。

pstree [-A|U] [-up] ：进程树,寻找进程之间的相关性。
-A:各进程树之间的连接以ASCII字符来连接； -U:各进程树之间的连接以utf8码的字符来连接,在某些终端接口下可能有错误
-p:同时列出每个进程的PID；               -u:同时列出每个进程的所属账号名称。


进程的管理
kill -signal PID
kill可以帮我们将这个signal传送给某个工作(%jobnumber)或者是某个PID(直接输入数字)。
主要信号代号与名称对应
1  SIGHUP  启动被终止的进程,可让该PID重新读取自己的配置文件,类似重新启动
2  SIGINT  相当于用键盘ctrl-c来中断一个进程的进行
9  SIGKILL 代表强制中断一个进程的进行,如果该进程进行到一半,那么尚未完成的部分可能会有半产品产生
15 SIGTERM 以正常的结束进程来终止该进程
17 SIGSTOP 相当于用键盘ctrl-z来暂停一个进程的进行
killall -signal 命令名称
killall [-iIe] [command name]  
-i：交互式的,若要需要删除时,会出现提示符给用户；

关于进程的执行顺序
优先执行序(priority PRI),这个PRI值越低则代表越优先的意思。不过这个PRI值是由内核动态调整的,用户无法
直接调整的PRI值的。由于PRI是内核动态调整的,我们用户也无权去干涉PRI,那如果你想要调整进程的优先执行序
时,就要通过NICE值了！NICE值就是上面的NI。一般来说,PRI与NI的相关性如下:PRI(new)=PRI(old)+nice
nice值的可调整范围:-20~19；
root可随意调整自己与他人进程的Nice值,且范围为-20~19；
一般用户仅可调整自己进程的Nice值,且范围仅为0~19,且仅能越调越高,例本次nice为5,则将来仅能调整大于5；

Nice:新执行的命令即给予新的nice值
nice [-n 数字] command
Renice:已存在进程的nice重新调整
renice [number] PID

系统资源的查看
free:查看内存的使用情况 free [-b|-k|-m|-g] [-t] / -t 在输出的最终结果中显示物理内存与swap的总量
uname:查看统与内核相关信息 uname [-asrmpi] / -a:all -s:系统内核名称 -r:内核版本 -m:系统的硬件名称
uptime:查看系统启动时间与工作负载 
netstat:跟踪网络 netstat -[atunlp] / -a:列出系统上所有连接,监听,Socket等
利用netstat去看看我们的哪些进程有启动哪些网络的"后门"。
dmesg:分析内核产生的信息-系统开机时,内核会去检测系统的硬件,你的某些硬件到底有没有被识别出来就与这个
                         时候的检测有关。
vmstat:检测系统资源变化  vmstat [-a] [延迟[总计检测次数]] <==cpu/内存等信息
		         vmstat [-fs]                     <==内存相关
                         vmstat [-s 单位]                 <==设置显示数据的单位
                         vmstat [-d] / vmstat [-p 分区]   <==与磁盘有关
内存字段(procs)的选项分为r(等待运行中的进程数量)、b(不可唤醒的进程数量)。
内存字段(memory)的选项分为swpd(虚拟内存被使用的量)、free(未被使用的内存容量)、buff(用于缓存储存器)
                          cache(用于高速缓存)。
内存交换空间(swap)的选项可分为si(由磁盘中将程序取出的量)、so(由于内存不足而将没用到的程序写入到磁
                              盘的swap的容量)
磁盘读写(io)的选项分别为bi(由磁盘写入的块数量)、bo(写入到磁盘去的块数量)
系统(system)的项目分别为:in(每秒被中断的进程次数)、cs(每秒钟进行的事切换次数)
CPU的选项分为us(非内核层的cpu使用状态)、sy(内核层的cpu状态)、id(闲置的状态)、wa(等待I/O所耗费的CPU状态)、
             st(被虚拟机所盗用的CPU使用状态)

特殊文件与程序
内存当中的数据都是写入到/proc/*这个目录下，基本上目前主机上面的各个进程的PID都是以目录的类型存在于
/proc当中。举例来说,我们开机所执行的第一个进程init它的PID是1,这个PID的所有相关信息都写入在/proc/1/*当中。

查询已打开文件或已执行程序打开的文件

fuser：通过文件(或文件系统)找出正在使用该文件的程序 / fuser [-umv] [-k [i] [-signal]] file/dir
-u:除了进程的PID之外,同时列出该进程的所有者 / -m:后面接的那些文件名会主动上提到该文件系统的所顶层,对umount不成功很有效
-v:可以列出每个文件与程序还有命令的完整相关性 / -k:找出使用该文件、目录的PID,并试图以SIGKILL这个信号给予该PID
-i:必须与-k配合,在删除PID之前会先询问用户意愿 / -signal:例如-1 -15等,不加的话默认为SIGKILL(-9)
ACCESS选项:  c-此进程在当前的目录下(非子目录)；e-可被触发为执行状态；f-是一个被打开的文件；
             r-代表顶层目录(root directory)；F-该文件被打开了,不过在等待回应中；
             m-可能为分享的动态函数库。

lsof:列出被进程所打开的文件名 / lsof [-aUu] [+d]
-a:多项数据需要"同时成立"才显示出结果时！          -U:仅列出Unix like系统的socket文件系统；
-u:后面接username,列出该用户相关进程所打开的文件； +d:后接目录,即找出某个目录下面已经被打开的文件！
例:仅列出关于root的所有进程打开的socket文件。      析:lsof -u root -a -u

pidof:找出某个正在执行的进程的PID / pidof [-sx] program_name
-s:仅列出一个PID而不列出所有的PID  / -x:同时列出该program name可能的PPID那个进程的PID

SELinux(Security Enhanced Linux)初探
SELinux是整合到内核的一个模块,其实SELinux是在进行程序、文件等权限设置依据的一个内核模块。由于启动
网络服务的也是程序,因此刚好也是能够控制网络服务能否访问系统资源的一道关卡。SELinux使用的是MAC委任
访问设置。

主体如何取得目标的资源访问权限：主体程序必须要通过SELinux策略内的规则放行后,就能与目标资源进行安全
                                上下文的比较,若失败则无法访问目标,成功则可以访问目标。但最终能否访
			        问目标还是与文件系统的rwx权限设置有关。
主体(Subject)也就是进程--要求->SELinux-->安全上下文-->目标(object)数据访问 
                                   |         |                |
                              策略(poliy)   AVC       能否访问最终还是要参考rwx的权限设置
策略:一个文件进程能否读取到目标文件资源的重点在于SELinux的策略以及策略内的各项规则,然后在通过该规则
的定义去处理各目标文件的安全上下文。预设值以_t结尾。

查看安全上下文可使用"ls -Z"（你必须已经启动了SELinux） / 安全上下文是放置到文件的inode内的
安全上下文主要用冒号分为三个字段:Identify(身份识别):role(角色):type(类型)
类型:基本上,一个主体进程能不能读取到这个文件资源与类型字段有关。而类型字段在文件与进程的定义不太相同
     type：在文件资源(Object)上面称为类型(type)；
     domain：在主体程序(Subject)中称为域(domain)；
     domain需要与type搭配,则该程序才能够顺利读取文件资源；

/user/sbin/httpd(http_exec_t)--触发执行->>http domain<<--可读写-->>/var/www/html(http_sys_content_t)
                                           |__>subject，就是httpd进程

http属于http_exec_t这个可执行的类型,而/var/www/html则属于http_sys_content_t这个可以让http域(domail)
读取的类型:
首先,我们触发一个可执行的目标文件,那就是具有httpd_exec_t这个类型的/user/sbin/httpd文件；
该文件的类型会让这个文件所造成的主体进程(subject)具有httpd这个域,我们的策略针对这个域已经制定了许多
规则,其中包括这个域可以读取的目标资源类型；
由于httpd domain被设置为可以读取http_sys_content_t这个类型的目标文件(object),因此你的网页放置到/var/
www/html目录下,就能被httpd那个进程所读取了；
但最终能否读取到正确的数据，还是与文件系统的rwx权限设置有关。

SELinux的启动、关闭与查看
目前SELinux支持三种模式:enforcing-强制模式,代表SELinux正在运行中,且已经正确开始限制domain(域)/type了。
                        permissive-宽容模式,代表SELinux正在运行中,不过仅会有警告信息并不会实际限制domain/type的访问,这种模式可以用来作为SELinux的调试之用。
			disabled-关闭,SELinux并没有实际运行。
查看目前的SELinux模式: getenforce
查看目前的SELinux策略: sestatus [-vb] / -v:检查列于/etc/sestatus.conf内的文件与程序的安全上下文内容
                                        -b:将目前策略的规则布尔值列出,即某些规则(rule)是否要启动(0/1)之意

SELinux的配置文件:/etc/selinux/config
内核有无关闭SELinux配置文件:/boot/grub/menu.lst

SELinux网络服务运行规范
一般服务启动的脚本会在/etc/init.d下面。启动http服务:/etc/init.d/httpd start
首页是放置在/var/www/html,且文件名应该要是"index.html"

重设安全上下文:chcon [-R] [-t type] [-u user] [-r role] 文件
               chcon [-R] --reference=范例文件 文件
-R:连同该目录下子目录也同时修改 / -t:后面接安全上下文的类型字段 / -u:后面接身份识别 / -r:后面接角色
--reference=范例文件:拿某个文件当范例来修改后续接的文件的类型；
例：将index.html类型改为http_sys_content_t类型 ：chcon -t http_sys_content_t /var/www/html/index.html
    以/etc/passwd为依据,将index.html类型改为该类型：chocn --reference=/etc/passwd /var/www/html/index.html

使用默认的安全上下文来还原:restorecon [-Rv] 文件或目录
-R:连同该目录下子目录也同时修改 / -v:将过程显示到屏幕

SELinux所需的服务
setroubleshoot:这个服务会将错误信息与克服方法写入/var/log/messages里面。设置开机启动:chkconfig --list setroubleshoot
               我们linux运行模式是在3或5号,因此这两个设置为on；chkconfig setroubleshoot on。
auditd:将详细数据写入/var/log/audit/audit.log中。设置开机启动:chkconfig --list auditd；chkconfig auditd on。
AVC是access vector cache的缩写,目的是记录所有与SELinux有关的访问统计数据。

SELinux的策略与规则管理
查看策略提供的规则:seinfo [-Atrub]     
查找某进程的安全上下文的类型 seinfo -t|grep subject
-A:列出SELinux的状态,规则布尔值,类型等信息 / -t:列出SELinux的所有类型种类
-r:列出SELinux的所有角色种类 / -u:列出SELinux的所有身份标识种类 / -b:列出所有规则的种类(布尔值)

查看详细的规则:sesearch [-a] [-a 主体类型] [-t 目标类型] [-b 布尔值]
-a:列出该类型或布尔值的所有相关信息 / -t:后面还要接类型 / -b:后面还要接布尔值的规则。
#allow   主体程序安全上下文类型    目标文件安全上下文类型
如上,说明这个类型可以被那个主体程序的类型所读取,以及目标文件资源的格式。

实际的策略数据都是放置在/etc/selinux/targeted/policy/下面，事实上所有与targetd相关的信息都是放置
到/etc/selinux/taegeted里面的呢！包括安全上下文相关的信息。

布尔值的查询与修改
其实,主体(subject)与目标(object)能否有访问的权限是与布尔运算有关的,我们可以通过seinfo -b查询系统有
多少布尔值，但每个布尔值是启动还是关闭可以使用:
getsebool [-a] [布尔值条款] / -a:列出目前系统上面的所有布尔值条款设置为开启或关闭值。
setsebool [-P] 布尔值=[0|1] / -P:直接将设置值写入配置文件,该设置数据将来会生效的。

默认目录的安全上下文查询与修改
semanage {login|user|port|interface|fcontext|translation} -l
semanage fcontext -{a|d|m} [-frst] file_spec
fcontext:主要用在安全上下文方面的用途,-l为查询的意思。 /  -m:修改的意思。 /  -d:删除的意思。
-a:增加的意思,你可以增加一些目录的默认安全上下文类型设置

***********************************第18章 认识系统服务daemons******************************************
service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。

实现循环型例行工作调度服务(service)的程序为crond这个daemon。你不比区分什么是daemon与service,事实上,
你可以将这两者视为相同！因为达成某个服务是需要一个daemon在后台运行,没有这个daemon就不会有service。

xinetd（extended internet daemon）
linux有许多网络服务,是通过xinetd进行总体管理的,比如说大名鼎鼎的telnet服务,就是通过xinetd进行管理的。
就是说,这个服务,用来管理多个小型的网络服务。但是,由于采用这种统一管理的方式,导致了效率的降低,所以现
在的大型网络服务都是自己管理自己,比如httpd等。所以说，xinetd有一些过时了,但是经典的网络服务还是需要由它进行统一管理的。

daemon的分类:
①以启动与管理方式区分:
stand_alone  此daemon可以自行单独启动服务,常见的stand_alone daemon有WWW的deamon(http)、FTP的daemon(vsftpd)等。
super daemon 一个特殊的daemon来统一管理,常见的super daemon有xinetd。
             Client-PI请求->Super daemon-触发->Program-载入->Daemon
                      |_______________提高连线_________________↑
             super daemon又可以分为multi-threaded(多线程),single-threaded(单线程)。
②以工作类型区分:
signal-control:这种daemon通过信号来管理,只要有任何客户端的请求进来,它就会立即启动去处理。
interval-control:这种daemon主要是每隔一段时间就主动执行某项工作,所以你要做的是在配置文件指定服务的
 		 名称被创建后,被挂上Linux使用时,通常在服务的名称之后会加上一个d,例如例行性命令的新
                 建的at与cron这两个服务,它的程序文件名会被取为atd与crond,这个d代表的就是daemon的意思。
                                ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

服务与端口对应
系统上面让服务与端口号对应的设置/etc/services。第一列为daemon的名称,第二列为该daemon所使用的端口号
与网络数据包协议,数据包协议主要为可靠连接的TCP数据包以及较快速但为非面向连接的UDP数据包。

/etc/init.d/* :启动脚本放置处           /etc/init.d/服务文件名{start,stop}服务的启动
/etc/sysconfig/* :各服务的初始化环境配置文件
/etc/xinetd.conf,/etc/xinetd.d/* :super daemon配置文件
/etc/* :各服务各自的配置文件
/var/lib/* :各服务产生的数据库
/var/run/* :各服务的程序的PID记录处

service [service name] (start|stop|restart|...) / service --status-all
service name:需要启动的服务名称,需与/etc/init.c对应；
--status-all:将系统所有的stand alone的服务状态全部列出来；

解析super daemon的配置文件
前面我们知道super daemon是一个总管进程,这个super daemon是xinetd这一个进程所实现的。而且由前面的图示
我们知道这个xinetd可以进行安全性或者是其他管理机制的控制,也能够控制连接的行为。由于super daemon可以
做这样的管理,因此一些对客户端开放较多权限的服务或者本身不具有管理机制或防火墙机制的服务就可以通过
xinetd来管理。

默认值配置文件:xinetd.conf
socket_type数据包类型:stream为连接机制较为可靠的TCP数据包,若为UDP数据包则使用dgram机制,raw代表server
                      需要与IP直接互换。

我们知道通过super daemon管理的服务可以多一层管理的手续来达成类似防火墙的机制,那么该如何设置这些类似
防火墙机制的设置参数呢？我们可以使用rsync进行远程镜像(mirror)的服务来说明。rsync可以让两部主机上面
的某个目录一模一样,在远程异地备份系统上面是挺好用的一个机制。

默认的rsync配置文件/etc/xinetd.d/rsync
由于/etc/services当中规定rsync使用的端口号码为873,这个端口小于1024,所以理论上启动这个端口的身份一定
是root才行！

服务的防火墙管理xinetd,TCP Wrappers套件
防火墙分析主要可以通过数据包过滤或者是通过软件分析。
管理某些进程能否接受或者拒绝来自因特网的连接的配置文件:/etc/hosts.deny和/etc/hosts.allow。
其实我们修改/etc/xinetd.d/rsync也可以进行防火墙设置,不过使用/etc/hosts.deny和/etc/hosts.allow则更容易
集中管理,在设置与查询方面也较为方便！

其实/etc/hosts.deny和/etc/hosts.allow也是/etc/sbin/tcpd的配置文件,而这个文件则是用来分析进入系统的
TCP网络数据包的一个软件,TCP是一种面向连接的网络连接数据包,包括www,email,ftp等都是使用TCP数据包来实现
连接的。所以顾名思义,这个套件本身的功能就是分析TCP数据包。而TCP数据包的文件头主要记录了来源与目的主机
的IP与port,因此通过分析TCP数据包并搭配/etc/host.{allow,deny}的规则比较,就可以决定该连接是否能够进入我
们的主机。

/etc/hosts.{allow，deny}
写在hosts.allow当中的IP与网段则默认为deny,第三列的allow也可省略。而写在hosts.deny当中的IP与网段则默
认为deny,第三列的deny可省略。通常我们允许进入的写在/etc/hosts.allow当中,不允许进入的写在/etc/hosts.deny

查询某个程序动态函数库支持状态: ldd $ (which 程序 程序 ..)

TCP Wrappers特殊功能
spawn(action):可以利用后续的shell来进行额外的工作,且具有变量功能,主要的变量内容有:%h(hostname),%a(address)
              %d(daemon)等。
twist(action):立即以后续的命令进行,且执行完后终止该次连接的请求(DENY)

查看系统开启的服务
netstat -tulp 找出目前系统开启的网络服务  netstat -lnp 找出所有的有监听网络的服务
service --status-all 查看所有的服务状态

设置开机后立即启动服务的方法
chkconfig:管理系统服务默认开机启动与否
chkconfig --list [服务名称] / chkconfig [--level [012356]] [服务名称] [on|off]
--list:仅将目前的各项服务状态栏显示出来  --level:设置某个服务在该level下启动或关闭
chkconfig:设置自己的系统服务
chkconfig [--add|--del] [服务名称] / --add:增加一个服务名称给chkconfig来管理,该服务名称必须在/etc/init.d/内
chkconfig: [runlevel][启动顺序][停止顺序]


使用stand alone的启动方式查看program目前是否启动:/etc/init.d/program status
使用super daemon的管理方式查看program目前是否启动:netstat -tlup | grep program

ntsysv:类图形界面管理模式 / ntsysv [--level <levels>]   

*************************************第19章 认识与分析日志文件*********************************************

Linux常见的日志文件名
/var/log/cron:记录关于crontab例行性调度的各项信息。
/var/log/dmesg:记录系统在开机的时候内核检测过程所参数的各项信息。
/var/log/lastlog:记录系统上面所有的账号最近一次登录系统时的相关信息。
/var/log/maillog或/var/log/mail/*:记录邮件的往来信息。
/var/log/messages:记录系统发生的错误信息(或者重要信息)。
/var/log/secure:记录账号密码等登录信息。
/var/log/wtmp或/var/log/faillog:记录正确登录系统者的账户信息与错误登录时所使用的账户信息。
/var/log/httpd/*或/var/log/new/*或/var/log/samba/*:个别服务所指定的日志文件。

日志文件所需相关服务(daemon)与进程

①syslogd:主要登录系统与网络等服务的信息。syslogd针对各种服务与信息记录在某些文件的配置文件就是
           /etc/syslogconf,里面规定了什么服务的什么等级信息以及需要被记录在哪里(设备或文件)。  
          服务名称[.=!]信息登记 信息记录的文件名或设备或主机 
          " ."代表比后面还要高的等级(含该等级)都被记录下来,例如mail.info代表只要mail的信息,而该信息
               等级高于info时,就会被记录下来的意思。
          ".="代表所需要的等级就是后面接的等级而已 ".!"代表不等于,即除了该等级外的其他等级都记录                            
②klogd:主要登录内核参数的各项信息；
③logrotate:主要进行日志文件的轮替功能。syslog利用的是daemon的方式来启动的,当有需求的时候就会立即执行
            但是logrotate却是在规定的时间到了之后才来进行日志文件的轮替,所以这个logrotate程序当然就是
            挂在cron下面进行的。仔细看一下/etc/cron.daily/里面的文件,/etc/cron.daily/logrotate就是记录
            了每天要进行的日志文件轮替的行为。
logrotate的配置文件:/etc/logrotate.conf /etc/logrotate.d/
prerotate:在启动logrotate之前进行的命令,例如修改日志文件的属性等操作；
postrotate:在做完logrotate之后启动的命令,例如重新启动(kill-HUP)某个服务；
logrotate [-vf] logfile / -v启动显示模式,会显示logrotate运行的过程  -f不论是否符合配置文件的数据,强制每个日志文件都进行rotate的操作

日志文件的安全性设置 / 日志服务器的设置 
syslog的日志文件只要"被编辑过"就无法继续记录,如果用vim打开了日志文件并且用":wq"退出导致日志文件不能
记录的问题,需要重启syslog让他继续提供服务/etc/init.d/syslog restart

***********************************第20章 启动流程、模块管理与Loader*************************************
启动过程:
1.加载BIOS的硬件信息与进行自我测试,并依据设置取得第一个可启动的设备；
2.读取并执行第一个启动设备内的MBR的boot Loader(即是grub,spfdisk等程序)；
3.依据boot loader的设置加载kernel,Kernel会开始检测硬件与加载驱动程序；
4.在硬件驱动成功后,kernel会主动调用init进程,而init会取得run-level信息；
5.init执行/etc/rc.d/rc.sysinit文件来准备软件执行的操作环境(如网络、时区等)；
6.init执行run-level的各个服务的启动(script方式)；
7.init执行/etc/rc.d/rc.local文件；
8.init执行终端机模拟程序mingetty来启动login进程,最后就等待用户登录；

内核模块放置在/lib/modules目录内
虚拟文件系统(InitialRAM Disk)一般使用的文件名为/boot/initrd,这个文件的特点是,它可能够通过boot loader
来加载内存中,而且这个文件会被解压缩并且在内存当中仿真成一个根目录,且此仿真在内存当中的文件系统能够提
供一个可执行的程序,通过该程序来加载启动过程中所需要的内核模块,通常这些模块就是USB,RAID,LVM,SCSI等文件
系统与磁盘接口的驱动程序。

ls --format=single-column -F /boot 查看内核文件

第一个进程init及配置文件/etc/inittab与/runlevel
/sbin/init最主要的功能就是准备软件执行的环境,包括系统的主机名,网络设置,语系处理,文件系统格式及其他服务的
启动等。而所有的操作都会通过init的配置文件/etc/inittab来规划,而inittab内还有一个很重要的设置选项,那就是
默认的run level。

run level ：执行等级                             <=================================================
0-halt(系统直接关机) / 1-single user mode(单用户维护模式) / 2-Multi-user,without NFS(与3类似,但无NFS)
3-Full multi-user mode(完整含有网络功能的纯文本模式) / 4-unuser(系统保留功能)
5-X11(与3类似,但加载使用X windows) / 6-reboot(重新启动)

/etc/inittab  [设置选项]:[run level]:[init的操作模式]:[命令选项]
Run level的查看与切换 - 查看:runlevel 切换:init [level]

init的处理系统初始化流程(/etc/rc.d/rc.sysinit）
在不同的distribution当中都不相同,最好自行到/etc/inittab去查看一下系统的工作。
用户自定义模块的加载:/etc/sysconfig/modules/*.modules
加载内核的相关设置:/etc/sysctl.conf       初始化软件磁盘阵列:/etc/mdadm.conf
如果你想要知道到底启动过程中发生了什么事,那么就执行"dmesg"吧。

启动系统服务与相关启动配置文件(/etc/rc.d/rc.N & /etc/sysconfig)
/etc/rc.d/rc[0-6].d里面有Sxxname与Kxxname可以设定开机启动和关机启动时事项。

用户自定义开机启动程序(/etc/rc.d/rc.local)
启动过程会用到的主要配置文件:
1.启动过程会用到的配置文件大多放置在/etc/sysconfig/目录下
2.由于内核还需要加载一些驱动程序(内核模块),此时系统自定义的设备与模块对应文件/etc/modprobe.conf就显得
  十分重要了。

关于模块:/etc/modprobe.conf 这个文件大多在于指定系统内的硬件所使用的模块。

/etc/sysconfig/* 启动过程中,服务的配置文件,其中包括-
1.authconfig这个文件主要设置用户的身份认证的机制,包括是否使用本机的/etc/passwd,/etc/shadow等,以及/etc/shadow
密码记录使用何种加密算法,还有是否使用外部密码服务器提供的账号验证等。
2.clock文件用于设置Linux主机的时区,在clock文件内的设置选项"ZONE"所参考的时区位于/user/share/zoneinfo
目录下的相对路径中,而且要修改时区的话,还得将/user/share/zoneinfo/Asia/shanghai这个文件复制成为/ert/localtime
i18n用于设置一些语系的使用方面 / keyboard & mouse用于设置键盘和鼠标的形式。
3.i18n用于设置一些语系的使用方面。

Run level的切换
事实上,与run level有关的启动其实是在/etc/rc.d/rc.sysinit执行完毕后。也就是说,其实run level的不同仅是
/etc/rc[0-6].d里面启动的服务不同而已。不过依据启动是否进入不同run level的设置,我们可以说:
1.要每次启动都执行某个默认的run level,则需要修改/etc/inittab内的设置选项,即是"id:5:initdefault:"里头的数字
2.如果仅只是暂时更改系统的run level时,则使用init[0-6]来进行run level的更改,但下次重新启动时,依然会是以
  /etc/inittab的设置为准。

内核(kernel)与内核模块
内核:/boot/vmlinuz或/boot/vmlinuz-version；  内核解压所需RAMDisk:/boot/initrd(/boot/initrd-version)；
内核模块:/lib/modules/version/kernel或/lib/modules/$(uname-r)/kernel；
内核源码:/user/src/linux或/user/src/kernels(需安装才有！默认不安装)；   内核版本:/proc/version
系统内核功能/proc/sys/kernel； 内核模块依赖性:/lib/modules/$(uname-r)/modules.dep

内核模块里面主要还分了几个目录:
1.arch：  与硬件平台有关的选项,例如CPU的等级等；
2.crypto：内核所支持的加密的技术.例如md5或者是des等；
3.drivers：一些硬件的驱动程序,例如显卡,网卡,PCI相关硬件；
4.fs：    内核所支持的文件系统,例如vfat,reiserfs,nfs等；
5.lib:    一些函数库；
6.net:   与网络有关的各项协议数据,还有防火墙模块(net/ipv4/netfilter/*)等；
7.aound：与音效有关的各项模块；

内核模块依赖性文件的创建:
depmod [-Ane] / -A:不加任何参数时,depmod会主动去分析目前内核的模块,并重新写入/lib/modules/$(uname-r)/modules.dep
                   若加入-A参数时,则depmod会查找比modules.dep还要新的模块,如果真找到新模块,才更新。
                -n:不写入modules.dep,而是将结果输出到屏幕上；   -e:显示出目前已加载的不可执行的模块名称
例:若我做好一个网卡驱动程序,文件名为a.ko,该如何更新内核依赖性？
   # cp a.ko /lib/modules/$(uname -r)/kernel/drivers/net
   # depmod

内核模块的查看 ：lsmod
显示内容: 模块名称(Module)  此模块是否被其他模块所使用(user by) 
modinfo [-adln] [module_name|filename] ：查询模块信息
-a:仅列出作者名称 | -d:仅列出该module的说明 | -l:仅列出授权 | -n:仅列出该模块的详细路径

内核模块的加载与删除:
 模块无依赖性加载与删除： 
 insmod [/full/path/module_name] [parameters] 后面接的模块必须是完整的"文件名":/lib/modules/$(uname-r)/kernel/..
 rmmod [-fw] module_name  -f:强制将该模块删掉,不论是否正被使用 / -w:若该模块正被使用,使用完毕后删除
 模块有依赖性加载与删除：
 modprobe [-lcfr] module_name  -c:列出目前系统所有的模块 / -l:列出目前在/lib/modules/`uname -r`/kernel当中的所有模块完整文件名
                               -f:强制加载该模块 / -r:删除某个模块
 modprobe会主动去查找modules.dep的内容,先克服依赖性后,才决定需要加载的模块有哪些,很方便。

内核模块的额外参数设置:/etc/modprobe.conf

目前主流的Boot loader：Grub
grub的配置文件/boot/grub/menu.lst与菜单类型
(hd0,0) 代表 第一块查找到的硬盘代号0的第一个分区代号0；
编写内核文件位置 / 扇区(boot sector)

/boot/grub/menu.lst配置文件
title以前的四行都是属于grub的整体设置,包括默认的等待时间与默认的启动选项,还有显示的界面特征等。
1.default=0 代表使用第一个启动菜单(title)选项来启动。
2.timeout=5 如果在5秒内没有按下任何按键,就会使用上面提到的default后面接的那个title选项来启动。
3.splashimage=(hd0,0)/grub/splash.xpm.gz 代表的是(hd0,0)这个分区内的最顶层目录下的grub/splash.xpm.gz那个文件
4.hiddenmenu 这个说的是启动时是否要显示菜单。

title CentOS （2.6.18-92e15） <==第一个菜单的内容
其中root、kernel、initrd后面接的内容的含义:
root:代表的是内核文件放置的那个分区,而不是根目录。
kernel:后面接的则是内核的文件名,而在文件名后面接的则是内核的参数。由于启动过程中需要挂载根目录,因此
       kernel后面接的那个root=LABEL=/1指的是Linux的根目录在哪个分区的意思。至于rhgb是色彩显示而quiet
       则是安静模式(屏幕不会输出内核检测的信息)。
initrd:就是initrd制作出RAM Disk的文件名。

利用chain loader的方式转交控制权
menu.lst内设置loader控制权移交时,最重要的为chainloader+1这个选项。

initrd的重要性与创建新initrd文件
initrd的目的在于提供启动过程中所需要的最重要内核模块，以让系统启动过程可以顺利完成。会需要initrd的
原因是因为内核模块放置于/lib/modules/$(uname -r)/kernel/当中，这些模块必须要根目录(/)被挂载时才能被
读取。但如果内核本身不具备磁盘的驱动程序时,当然无法挂载根目录,也就无法取得驱动程序,通过initrd可以将
/lib/modules/..内的启动过程中一定需要的模块打包,然后启动时通过主机的INT13硬件功能将文件读出来,并且
initrd在内存内会仿真成为根目录,由于此虚拟文件系统(Initial RAM Disk)主要包含磁盘与文件系统的模块,因此
我们的内核最后就能够认识实际的磁盘,那就能进行实际根目录的挂载。
一般来说.需要initrd的时刻: 根目录所在磁盘为SATA、USB或SCSI等连接接口；
                           根目录所在文件系统为LVM、RAID等特殊格式；
			   根目录所在文件系统为非传统Linux"认识"的文件系统时；
                           其他必须要在内核加载时提供的模块；
mkinitrd [-v] [--with=模块名称] initrd文件名 内核版本                   <-- 重制initrd文件
mkinitrd -v/boot/initrd-2.6.30.3vbird.img  2.6.30.3vbird

测试与安装grub
grub-install[--root-directory=DIR] INSTALL_DEVICE
--root-directory=DIR 那个DIR为实际的目录,使用grub-install默认会将grub所有的文件复制到/boot/grub/*,
如果想要复制到其他目录与设备去,就要使用这个参数。
INSTALL_DEVICE 安装的设备代号

如果是从其他boot loader转成grub，得先使用grub-install安装grub配置文件，接着开始编辑menu.lst这个重要
的配置文件，最后通过grub来将主程序安装到系统中，如MBR的(hd0)或boot sector的(hd0,0)等。
grub shell:更多信息可以info grub查阅
 1.用root(hdx.x)选择含有grub目录的那个分区代号；
 2.用"find/boot/grub/stage1"看看能否找到安装信息文件；
 3.用"find/boot/vmlinuz"看看能否找到内核文件l； 
 4.用"setup(hdx.x)"或者"setup (hdx)"将grub安装在boot sector或MBR中；
 5.用"quit"离开grub shell；

启动前的额外功能修改
调整终端机分辨率:前提:支持FRAMEBUFFER_CONSOLE这个内核参数 grep ‘FRAMEBUFFER_CONSOLE’/boot/config-2.6.18-92.e15

BIOS无法读取大硬盘的问题:BIOS无法读取大容量硬盘内的kernel与initrd文件。
                         解决办法:由于DIOS至少可以读到大磁盘的1024柱面的数据,将kernel与initrd文件放置
                          	  在大硬盘的最前头就能读取内核与虚拟文件系统的文件。
为某个菜单加上密码:grub-md5-crypt将密码转换为md5编码

启动过程的问题解决:进入runlevel 1(单用户维护模式/救援模式)
忘记root密码:重新启动,启动进入grub菜单后,在你要进入的菜单上面点e进入详细设置,将鼠标移动到kernel上方
             并点e进入编辑界面，在grub edit这行最后加上single,然后按下enter后再按下b就能够启动进入单
             用户维护模式,进入单用户维护模式后,系统会以root的权限直接给你一个shell,此时你就能执行Passwd
             命令来重建root密码,然后直接执行init 5就可以切换成为X窗口界面。
init配置文件错误:重新启动,启动进入grub菜单后,在你要进入的菜单上面点e进入详细设置,将鼠标移动到kernel上方
                 并点e进入编辑界面，在grub edit这行最后加上init=/bin/bash。
BIOS磁盘对应的问题(device.map)
因文件系统错误而无法启动
利用chroot切换到另一块硬盘工作：可以暂时将根目录移动到某个目录下,然后去处理某个问题,最后在离开该root
                                而回到原本的系统当中。

**********************************第21章 系统设置工具与硬件检测*********************************************

centos系统设置工具:setup
用户身份验证设置：Authentication configuration
网络配置选项(手动设置IP与自动获取) / 防火墙设置(Firewall configuration) / 键盘形式设置(Keyboard configuration)
系统时钟的时区设置(Timezone configuration) / X窗口界面分辨率设置(X configuration)
利用CUPS设置Linux打印机:当启动IPP时,打印机会启动port631. 浏览器地址栏输入http://localhost:631
nmap是个可以扫描主机端口的软件(port scan)
手动设置打印机:/etc/cups/printers.conf 打印机的设置值文件
               /etc/cups/cupsd.conf CPUS的主要配置文件,包括作为服务器用途的设置
               /etc/cups/ppd/*.ppd 打印机的驱动程序(PPD配置文件)
使用Ipadmin进行打印机的新建与删除及打印机状态的查看
lpadmin [-p 自定义队列名] [-v URI] [-m PPD] [-E] <==建立打印机
lpadmin [-d 已存在的队列名] <==设置成为默认打印机 / lpadmin [-x 已存在的队列名] <==删除此一打印机队列  
lpatat [-adprt]
利用lpr与lp来产生打印操作
lpr [-p printer 队列] [-# 打印份数] -U [username] file
打印作业的查看(lpq)与删除(lprm)
lpr [-al] [-P 打印队列] / lprm [-P printer队列] job id

硬件数据收集与驱动及Im_sensors
lspci:列出整个PC系统的PCI接口设备！ lspci [-vvn]   
lsusb:列出目前系统上面各个USB端口的状态与连接的USB设备； lsusb [-t]  
iostat:列出整个CPU与接口设备的I/O状态； iostat [-c|-d] [-k|-m] [-t] [间隔秒数] [检测次数]
/user/share/hwdata/pci.ids:PCI标准ID与品牌名称的对应表

驱动USB设备 / 使用Im_sensors取得温度、电压等信息:sensors_detect与sensors命令
udev与hal简介

IP地址（ipv4）是由网络地址+主机地址组成，四段每段八位共32位（二进制），网络地址到哪一位，由掩码告诉你
(网络中的某台计算机)(这就是掩码的作用),后面的叫主机位。当主机位全为0时，它是一个不可用的IP地址(网络中
的计算机不能以此作为身份识别），通常用它来表示网络号，即一个网段。也就是这个网段的“最小”IP地址。主机
位全为1时，也是一个不可用的IP地址（不特指哪一台计算机，而是大家）,就是这个网段的“最大”IP地址叫直接广
播地址，可以穿过路由器。
给你一个（含掩码的）IP地址149.88.160.58/18，你就知道该地址的网络号与主机位各是多少。
掩码是18，那前18位都是网络号，那149与88都可以不管它，只管160就行了。
160换成二进制是：10100000。掩码是18位，这是第三段，所以左边两位即1和0属于网络地址位，不能动，你求网络号
把这两位后面的全改成0就OK了，即10000000，即128，第四段当然也全是0，所以网络号是：149.88.128.0/18，广播
地址就是把这两位以后的全改成1就成了，160换成二进制是：10100000，左两位不能动，后面的改成1，即10111111，
即191，第四段也全改为1，即255，所以广播地址是：149.88.191.255/18，注：这是直接广播地址。

**************************************第22章 软件安装:源码与Tarball*******************************************

查看是否文件为二进制：file 文件目录
如果是二进制程序而且可以执行的时候,它就会显示可执行文件类(ELF 32-bit LSB executable),同时会说明是否使用
共享库(shared libs),而如果是一般的script,那它就会显示出text executables 之类的字样。

开放源码:就是程序代码,写给人类看的程序语言,但机器并不认识,所以无法执行；
编译程序:将程序代码转译成为机器看得懂的语言；
可执行文件:经过编译程序变成二进制程序后机器看得懂所以可以执行的文件；

1.什么是函数库
2.什么是make与configure:当执行make时,make会在当前的目录下搜索Makefile这个文本文件,而Makefile里面则记录了
  源码如何编译的详细信息。make会自动判别源码是否经过变动了而自动更新执行文件。
  通常软件开发商都会写一个检测程序来检测用户的操作环境,以及该操作环境是否有软件开发商所需要的其他功能,
  该检测程序检测完毕后,就会主动新建这个Makefile的规则文件。通常这个检测程序的文件名为configure或config。
  执行configure来新建Makefile,成功之后再以make来调用所需要的数据来编译即可。
3.什么是Tarball的软件:所谓的Tarball文件,其实就是将软件的所有源码文件先以tar打包,然后再以压缩技术来压缩。
                      所以tarball文件一般的扩展名就会写成*.tar.gz或者*.tgz。
4.如何安装与升级软件: 1.将Tarball由厂商的网页下载下来。
		 2.将Tarball解压缩,生成很多的源码文件。
                      	 3.开始以gcc进行源码的编译(会生成目标文件)。
		 4.然后以gcc进行函数库、主程序、子程序的链接,以形成主要的二进制文件。
                                 5.将上诉的二进制文件以相关的配置文件安装至自己的主机上面。

使用传统程序语言进行编译的简单范例
1.在默认的状态下,如果我们直接以gcc编译源码,并且没有加上任何参数,则执行文件的文件名会被自动设置为a.out
  这个文件名,所以你就能直接执行./a.out这个执行文件。如果我想要产生目标文件(object file)来进行其他的操作
  而且执行文件的文件名也不要默认的a.out呢？

2.主程序、子程序链接:子程序的编译 
  为什么要制作目标文件:由于我们的源码文件有时并非仅只有一个文件(需要调用其他文件内容),所以我们无法直接
  进行编译,这时候就需要先生成目标文件,然后再以链接制作成二进制可执行文件。
  链接目标文件:gcc -o 生成的执行文件名称 目标文件1.o  目标文件2.o
  如果有一天,你更新了文件1的文件内容,则你只需要重新编译文件1来产生新的目标文件1,然后再以链接制作成新的
  二进制可执行文件即可,而不必重新编译其他没有改动过的源码文件。

3.调用外部函数库:加入链接的函数库
  编译时加入额外函数库链接的方式：gcc 执行文件 -l -L/path
   例1:gcc sin.c -lm -L/lib -L/user/lib；-l:是加入某个函数库的意思 m:则是libm.so这个函数库,所以-lm表示使用
      libm.so(或libm.a)这个函数库的意思。至于-L后面接的路径表示我要的函数库libm.so请到/lib或/user/lib里面搜索。
  定义要读取的include文件放置的目录:gcc 执行文件 -l -I/path
   例2:gcc sin.c -lm -I/user/include
  -I/path 后面接的路径就是设置要去搜索相关的include文件的目录，默认放置在/user/include下面。  
  
  即-L后面接的路径是函数库的搜索目录,-I后面接的是源码内的include文件的所在目录；

gcc的简易用法(编译、参数与链接)
#仅将源码编译成为目标文件，并不制作链接等功能:gcc -c hello.c
#在编译的时候,依据操作环境给予优化执行速度:gcc -O hello.c -c
#在进行二进制文件制作时,将链接的函数库与相关路径填入:gcc sin.c -lm -L/user/lib -I/user/include
#将编译结果输出成某个特定文件名:gcc -o hello hello.c
#在编译的时候,输出较多的信息说明:gcc -o hello hello.c -Wall

用Make进行宏编译：make的功能是简化编译过程里面执行的命令，同时还具有很多很方便的功能。
1.先编辑makefile这个规则文件,内容只要制作出main这个可执行文件；
  vim makefile
  main: main.o haha.o sin.o cos.o
  	gcc -o main main.o haha.o sin.o cos.o -lm
2.尝试使用makefile制作的规则进行编译的行为；
  make main
makefile的基本语法与变量
  目标(target): 目标文件1 目标文件2
  <tab>	   gcc -o 欲新建的可执行文件 目标文件1 目标文件2    #命令行必须要以tab按键作为开头才行！ 

执行输入命令: main 目标
用变量简化makefile: 1.变量与变量内容以"="隔开,同时两边可以具有空格；
		    2.变量左边不可以有<tab>；            3.变量与变量内容在"="两边不能具有":"；
                    4.在习惯上,变量最好以大写字母为主；  5.运用变量时,以${变量}或$(变量)使用；
                    6.在该shell的环境变量是可以被套用的；7.在命令行模式也可以定义变量；
环境变量取用的规则是这样的:1.make命令行后面加上的环境变量为第一优先；
                                          2.makefile里面指定的环境变量为第二优先；
 		          3.shell原本具有的环境变量为第三优先；
$@：代表目前的目标(target)

Tarball的管理与建议
Tarball的安装时可以跨平台的,因为C语言的程序代码在各个平台上面是可以互通的,只是需要的编译程序可能并不相同
而已。
Tarball安装的基本步骤
1.取得源文件:将tarball文件在/user/local/src目录下解压缩；
2.取得步骤流程:进入新建立的目录下,去查阅INSTALL与README等相关帮助文件内容(很重要的步骤)；
3.相关属性软件安装:根据INSTALL/README的内容查看并安装好一些相关的软件(非必要)；
4.建立makefile:以自动检测程序(configure或config)检测操作环境,并建立Makefile这个文件；
5.编译:以make这个程序并使用该目录下的Makefile作为它的配置文件,来进行make(编译或其他)的操作；
6.安装:以make这个程序,并以Makefile这个配置文件,依据install这个目标(target)的指定来安装到正确的路径；

大部分的tarball软件安装的命令执行方式:
1. ./configure configure检测程序找到所需函数库、编译器及其他资料,并主动建立Makefile这个文件(厂商会写入到tarball)。
               检查configure支持的参数 ./configure --help | more <==查询可用的参数有哪些
2. makeclean   去除目标文件(主要去除上次编译过的目标文件*.o)。
3. make        依据Makefile当中的默认工作进行编译的行为。编译的工作主要是进行gcc来将源码编译成为可以被
               执行的目标文件,但是这些目标文件通常还需要一些函数库之类的链接后,才能生成一个完整的可执行
               文件！使用make就是将源码编译成为可以被执行的可执行文件,而这个文件会放置在目前所在的目录
               下,尚未被安装到预定安装的目录中。
4. make install通常这就是最后的安装步骤,make会依据Makefile这个文件里面关于install的选项,将上一个步骤所
               编译完成的数据安装到默认的目录中,就完成安装！
如果安装成功,并且是安装在独立的一个目录中,那么你就必须手动将这个软件的man page写入/etc/man.config

一般Tarball软件安装的注意事项(如何删除、升级)
基本上,在默认的情况下,原本的Linux distribution发布安装的软件大多是在/user里面的,而用户自行安装的软件则
建议放置在/user/local里面,这是考虑到管理用户所安装软件的便利性。因为每个软件都会提供在线帮助的服务,那就
是info与man的功能。在默认的情况下,man会去搜索/user/local/man里面的说明文件,因此如果我们将软件安装在/user/local
下面的话,那么自然安装完成之后,该软件的说明文件就可以被找到了。
为了方便Tarball的管理,通常鸟哥会这样建立用户:
1.最好将tarball的原始数据解压缩到/user/local/src当中；
2.安装时,最好安装到/user/local这个默认的路径下；
3.考虑将来的反安装步骤,最好可以将每个程序单独安装在/user/local下面；
4.为安装到单独目录的软件的man page加入man path搜索(/etc/man.config)；
例:如果你安装的软件放置到/user/local/software/中,那么在man page搜索的设置中可能就要在/etc/man.config内
   写上一行: MAN PATH /user/local/software/man

利用patch更新源码
patch的基本语法: patch -p 数字 < patch_file 
                 -p xx那个数字代表拿掉几个斜线(/)的意思！

函数库管理
1.动态与静态函数库： 
  A:静态函数库的特色-扩展名(为.a),这类的函数库通常拓展名为libxxx.a类型；
                     编译行为,这类函数库编译的时候会直接整合到执行程序当中,所以利用静态函数库编译的文件
                              会比较大一些；
     		     独立执行的状态,这类函数最大的优点就是编译成功的可执行文件可以独立执行,而不需要再向
                                    外部要求读取函数库的内容。
                     升级难易度,因为函数库是直接整合到可执行文件中,因此若函数库升级时,整个可执行文件必须
                                要重新编译才能将新版的函数库整合到程序当中。也就是说,在升级方面,只要函数库
                                升级了,所有将此函数库纳入的程序都需要重新编译。 
 B:动态函数库的特殊-扩展名(为.so),这类的函数库通常拓展名为libxxx.so类型；
       		    编译行为,与静态函数库被整个捕捉到程序中不同,动态函数库在编译的时候,在程序里面只有一个
                             "指向"(Pointer)的位置而已。也就是说,动态函数库的内容并没有整合到可执行文件
                              当中,而是当可执行文件要使用到函数库的机制时,程序才会去读取函数库来使用。
                    独立执行的状态,这类型的函数库所编译出来的程序不能被独立执行,因为当我们使用到函数库的
                                   机制时,程序才会去读取函数库,所以函数库必须要存在才行,而且,函数库的所在
                                   目录也不能改变,因为我们的可执行文件里面仅有"指标",亦即当要取用该函数库
                                   时,程序会主动去某个路径下读取,所以函数库可不能随意移动与删除,会影响很多
                                   相关的程序软件。
                    升级难易度,虽然类型的可执行文件无法独立运行,然而由于具有指向的功能,所以,当函数库升级
                               后,可以执行文件根本不需要重新编译的行为,可执行文件会直接指向新的函数库文件
                               当然,前提是函数库新旧版本的文件名相同。
绝大多数的函数库放置在/user/lib,lib目录,此外,linux系统里面很多的函数库其实kernel就提供了,并存放在/lib/modules里面。
2.ldconfig与/etc/ld.so.conf:
  增强函数库的读取性能:我们知道内存访问速度是硬盘的好几倍,所以,如果我们将常用到的动态函数库先加载内存当中
                       (缓存,cache),如此一来,当软件要使用动态函数库时,就不需要从头由硬盘里面读出了,这样不就增进动态函数库的读取速度了！
                       这时候就需要ldconfig与/etc/ld.so.conf的协助了。
  如何将动态函数库加载高速缓存当中呢？
  1.首先,我们必须要在/etc/ld.so.conf里面写下想要读入高速缓存当中的动态函数库所在的目录,注意是目录而不是文件；
  2.接下来则是利用ldconfig这个可执行文件将/etc/ld.so.conf的数据读入缓存当中。
  3.同时也将数据记录一份在/etc/ld.so.cache这个文件当中。
  ldconfig [-f conf] [-C cache] / ldconfig [-p]
  -f conf:那个conf指的是某个文件名,也就是说,使用conf作为libarary函数库的取得路径,而不以/etc/ld.so.conf为默认值；
  -C cache:那个cache指的是某个文件名,也就是说,使用cache作为缓存暂存的函数库资料,而不以/etc/ld.so.conf为默认值；
  -p:列出目前的所有函数库数据内容(/etc/ld.so.conf内的数据)；
3.程序的动态函数库解析: ldd
  ldd [-vdr] [filename] / -v:列出所有内容信息 -d:重新将数据有丢失的link点显示出来 -r:将ELF有关的错误内容显示出来

检验软件的正确性
镜像文件、MD5指纹编码、SHA1指纹编码 
md5sum/sha1sum [bct] filename                        
md5sum/sha1sum [--status|--warn] --check filename
-b:使用二进制的读取方式,默认为windows/Dos文件类型的读取方式 / -c:检验文件指纹 / -t:以文件类型来读取文件指纹
基本上,你必须要在你的Linux系统上为你的重要的文件进行指纹数据库的创建,将这些文件新建数据库:
/etc/passwd , /etc/shadow , /etc/group , /user/bin/passwd , /sbin/portmap , /bin/login , /bin/ls , /bin/ps , /user/bin/top
如果你可以为这些文件新建指纹数据库(就是使用md5sum检查一次,将该文件指纹记录下来,然后经常以shell script的
方式由程序自行来检查指纹表是否相同),那么对于文件系统会比较安全。

例题：将/etc/{passwd,shadow,group}以及系统上面所有的SUID/SGID文件创建文件列表,文件列表名为"important.file"
      并通过该文件列表,以md5.checkfile.sh的文件名去新建指纹码,并将该指纹码文件"finger1.file"设置为不可修改
      的属性,通过相同的机制去新建后续的分析数据为空finger_new.file，并将两者进行比较,若有问题则提供email
      给root查阅。
步骤: 1.# ls /etc/{pass,shadow,group} >important.file
      2.# find /bin /sbin /user/sbin /user/bin -perm +6000 >>important.file
      3.# vim md5.checkfile.sh
        #!/bin/bash
        for filename in $ (cat important.file)
        do 
          md5sum $filename >> finger1.file
        done
      4.# sh md5.checkfile.sh
      5.# chattr +i finger1.file
      6.# vim md5.checkfile.sh
        #!/bin/bash
        if [ "$1" == "new" ] ; then
           for filename in $ (cat important.file)
           do 
	     md5sum $filename >> finger1.file
           done
 	   echo "new file finger1.file is created ."
           exit 0
        fi [ ! -f finger1.file ] ; then
           echo "file: finger1.file NOT exist ."
           exit1 
        fi 
        [ -f finger_new.file ] && rm finger_new.file
        for filename in $(cat important.file)
        do 
           md5sum $filename >> finger_new.file
        done
        testing=$(diff finger1.file finger_new.file)
        if [ "$testing" != "" ] ; then
           diff finger1.file finger_new.file | mail -s 'finger trouble..' root
        fi    
      7.#vim /etc/crontab
        30 2 * * * root cd /root; sh md5.checkfile.sh

************************************第23章 软件安装:RPM、SRPM与YUM功能*********************************************
利用厂商发布的Tarball来进行软件的安装每次安装都需要检测操作系统与环境、设置编译参数、实际的编译,最后还需要
依据个人喜好的方式来安装软件到定位。这个过程太麻烦了。那么如果我的Linux系统和厂商的系统一模一样,那么在厂商
系统上面编译出来的可执行文件自然也可以在我系统上面跑,所以厂商将这个编译好可直接执行的软件发布给用户来安装
如同Windows的安装方式,由程序开发者直接在已知的系统上面编译好,再将程序直接给用户安装此称为软件管理器,常见的
两大主流软件管理器有RPM与DPKG。

RPM类型的软件中,所有的软件时经过编译的二进制程序，所以可以直接安装在用户端的系统上,SRPM内含的文件为源代码
而非为二进制文件,所以安装SRPM时还需要经过编译,不过SRPM优点是可以让用户自行修改设置参数。
SRPM 它是Source RPM的意思，也就是RPM文件里面含有的源代码。通常扩展名为***.src.rpm这种格式来命名。
 如果我们下载的是SRPM,那么安装该软件时,你必须要:
 0.修改SRPM内的参数设置文件(需要时进行)；
 1.先将该软件以RPM管理的方式编译,此时SRPM会被编译成RPM文件；
 2.然后将编译完成的RPM文件安装到Linux系统当中；

系统版本: 软件名称-软件的版本信息-发布的次数.适合的硬件平台.扩展名
      例: rp-pppoe-3.1           -5         .i386          .rpm

CentOS先将发布的软件放置到YUM服务器内,然后分析这些软件的依赖属性问题,将软件内的记录信息写下来(header),
然后再将这些信息分析后记录成软件相关性的清单列表。这些列表数据与软件所在的位置可以称为容器(repository)。
其在YUM服务器内,是一个网址类似于http://mirrors.163.com/centos/7/os/x86_64/Packages/

yum设置文件内的容器设置(/etc/yum.repos.d/*.repo)

RPM软件管理程序: rpm
RPM默认安装的路径: /var/lib/rpm/ 里面记录了软件的版本、名称、文件与目录配置、系统需求等
RPM安装(install) ：rpm -ivh package_name  
-i:install的意思 -v:查看更详细的安装信息画面 -h:以安装信息栏显示安装进度
其他可执行参数: --nodeps ：当发生软件属性依赖问题而无法安装,当你执意强制安装时。
                --replacefiles ：已经安装或者版本不和时,覆盖之前文件。
                --replacepkgs ：重新安装某个已经安装过的软件。
                --test ：测试一下软件是否可以被安装到用户的Linux环境中,可找出是否有属性依赖的问题。
                ...
RPM查询(query)
rpm -qa                             <==已安装软件 /    rpm -q[licdR] 已安装软件名       <==已安装软件
rpm -qf 存在于系统上面的某个文件名  <==已安装软件 / rpm -qp[licdR] 未安装的某个文件名称 <==查阅RPM文件
 参数:
 查询已安装软件的信息:
 -q:仅查询,后面接的软件名称是否有安装 / -qa:列出所有的已安装在本机Linux系统上面的所有软件名称
 -qi:列出该软件的详细信息  / -ql:列出该软件所有的文件与目录所在完整文件名 / -qc:列出该软件的所有配置信息
 -qd:列出该软件的所有帮助文件 / -qR:列出与该软件有关的依赖软件所含的文件 / -qf:由后面接的文件名称找出该文件属于那一个已安装软件
 查询某个RPM文件含有的信息:
 -qp[icdlR]:与上基本一致,但用途仅在于找出某个RPM文件内的信息,而非已安装的软件信息。

RPM验证与数字证书（Verify/Signature）
 验证的功能主要在于提供系统管路员一个有用的管理机制,其作用的方式是使用/var/lib/rpm下面的数据库内容来比较
 目前Linux系统的环境下的所有软件文件,也就是说,当你有数据不小心丢失,被修改就用这个简单方法验证原来的文件系
 统。好让你了解这一阵子到底是修改到哪些文件数据了！
  rpm -Va / rpm -V 已安装的软件名称 / rpm -Vp 某个RPM文件的文件名 / rpm -Vf 在系统上面的某个文件
  -Va:列出目前系统上面所有可能被修改过的文件； -Vp:列出该软件内可能被改动的文件 / -Vf:列出某个文件是否被改动过
 [文件容量][文件类型、属性][MD5指纹码][设备的代码][Link路径][文件的所有者][文件的所属用户组][文件的创建时间]
 上面显示哪个数据代表哪个数据被改变了；
 数字证书(digital signature)
 当你要安装一个RPM文件时:
 1.首先你必须要安装原厂发布的公钥文件；
 2.实际安装原厂的RPM软件时,rpm命令会去读取RPM文件的证书信息,与本机系统内的证书信息比较；
 3.若证书相同则予以安装,若找不到相关的证书信息时,则给予警告并且停止安装；
 CentOS的数字证书位于:/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5

卸载RPM与重建数据库(erase/rebuilddb)
rpm --rebuilddb <==重建数据库

SRPM的使用:rpmbuild
1.利用默认值安装SRPM文件(--rebuild/--recompile)
  --rebuild:这个选项会将后面的SPRM进行编译与打包的操作,最后会生成RPM的文件,但是产生的RPM文件并没有安装
            带系统上。你需要将RPM安装时,请加绝对路径来安装。
  --recompile:这个动作会直接编译、打包并且安装。与rebuild不同,其只进行了编译并打包,而recompile在此基础上
              还进行了打包。
2.SRPM使用的路径与需要的软件
  /user/src/redhat/SPECS ：这个目录放置的是该软件的设置文件,例如这个软件的信息参数、设置项目等
  /user/src/redhat/SOURCES ：这个目录放置的是该软件的源文件(*.tar.gz的文件)以及config这个设置文件
  /user/src/redhat/BUILD ：编译的过程中,有些暂存的数据会放置在这个目录当中
  /user/src/redhat/RPMS ：经过编译后,并且顺利编译成功之后,将打包完成的文件放置在这个目录当中。
  /user/src/redhat/SRPMS ：与RPMS内相似,这里放置的就是SRPM封装的文件。
3.设置文件的主要内容(*.spec)
  rpm -i XX.rpm安装软件包,切换至cd /user/src/redhat/SPECS目录,编辑vi xxx.spec文件。
  注意到的是xxx.sepcpec这个文件,这里主要是将SPRM编译成RPM的设置文件,它的基本规则可以这样看:
  1.整个文件的开头以Summary为开始,这部分的设置都是最基础的说明内容；
  2.然后每个不同的段落之间都以%来作为开头,例如%prep与%install等；
  系统整体信息方面:
  Summary ：本软件的主要说明
  BuildRoot ：设置作为编译时,该使用哪个目录来临时存放中间文件(如编译过程的目标文件/链接文件等)
  Requires ：如果你这个软件还需要其他的软件的支持,那么这里就必须写上来,则当你制作成RPM之后,系统就会自动
             去检查。这就是"依赖属性"的主要来源。
  根据上面的设置,最终的文件名就是"{Name}-{Version}-{Release}.{ExclusiveArch}.rpm"的样子。
  %description:将你的软件做一个简短的说明。
  %prep:尚未进行设置或安装之前你需要编译完成的RPM帮你事先做的事情,就是prepare的缩写,它的工作事项主要有:
        1.进行软件的补丁(patch)等相关工作；
        2.寻找软件所需的目录是否已经存在,确定用的；
        3.事先新建你的软件所需目录,或者事先需要进行的任务；
        4.如果带安装的Linux系统内已经安装的时候可能会被覆盖掉的文件时,那么就需要进行备份(backup)的工作了；
  %setup:这个选项就是在进行类似解压缩之类的工作。这个选项一定要写。不然你的taball源代码是无法解压缩的；
  %build:这个段落就是在谈怎么编译成为可执行的程序。这部分的程序代码方面就是./configure、make等选项；
  %install:编译完成就是安装。安装就是写在这里,也就是类似Tarball里面的makeinstall的意思；
  %clean:编译与安装完毕后,必须要将一些暂存在BuildRoot内的数据删除才好。这有点像make clean的感觉；
  %file:这个软件安装的文件都需要写到这里来,当然包括了"目录"。
  %changelog:这个选项主要则是记录这个软件曾经的更新记录。*星号后面应该要以时间、修改者、email与软件版本
             来作说明,-减号后面则是你要做的详细说明；
4.SRPM的编译命令(-ba/-bb)
  要将在/user/src/redhat下面的数据编译或者是单纯打包成为RPM或SRPM时,就需要rpmbuild命令与相关选项的帮忙了!
  rpmbuild -ba XXX.spec <==编译并同时生成RPM与SRPM文件
  rpmbuild -bb XXX.spec <==仅编译成RPM文件
  这个时候系统就会这样做:
  1.先进入到BUILD这个目录,即/user/src/redhat/BUILD这个目录；	
  2.依据*.spec文件内的Name与Version定义出工作的目录名称,以我们上面例子为例,那么系统就会在BUID目录先删除
    xxx-x.x的目录，再重新建立一个xxx-x.x的目录,并进入这个目录；
  3.在新建的目录里面,针对SOURCES目录下面的源文件,也就是*.spec里面的Source设置的那个文件,以tar进行解压缩；
  4.再来开始%build及%install的设置与编译；
  5.最后将完成打包的文件放置到该放置的地方去；
5.一个打包自己软件的范例
  制作源代码文件tarball生成:将xx.tgz放置在/root下面,并且在/user/local/src下面新建一个目录进行解压。cd切换
                            到新建目录,新建源代码所需的make规则(vim Makefile)，cd ..切换到上层目录,将新建
                            目录打包tar到上层目录,并将其cp复制到/user/src/redhat/SOURCES。
  新建*.spec的设置文件:cd切换到/user/src/redhat/SPECS，编辑 vim main.spec
  编译成为RPM与SRPM:rpmbuild -ba main.spec
  安装/测试/实际查询:rpm -ivh /user/src/redhat/RPMS/xxx/xxx.rpm
                     rpm -ql main
                     rpm -qi main

YUM在线升级机制
1.利用yum进行查询、安装、升级与删除功能
  查询功能:yum [list|info|search|provides|whatprovides] 参数
           yum [option] [查询工作项目] [相关参数]
  安装/升级功能:yum [install|update] 软件
                yum [option] [查询工作项目] [相关参数]
  删除功能:yum [remove] 软件
2.yum的设置文件
  repodata目录:分析RPM软件后所产生的软件属性依赖数据放置处。

  vi /etc/yum.repos.d/xxx.repo 设置容器的网站
  [容器名]
  name=：只是说明一下这个容器的意义。
  mirrorlist=：列出这个容器可以使用的镜像站点,可以不使用。
  baseurl=：容器的实际网址。mirrorlist是由yum程序自行去找镜像站点,baseurl则是指向固定的一个容器网址。
  enable=1：就是让这个容器被启动。
  gpgcheck=1：指定是否需要查阅RPM文件内的数字证书。
  gpgkey=：就是数字证书的公钥文件所在位置。使用默认值即可。

  修改容器产生的问题与解决之道:yum clean [package|headers|all] 清除本机上面的旧数据
3.yum的软件组功能
  yum [组功能] [软件组] 
  参数:grouplist-列出所有可用的组列表；  groupinfo-后面接group name,则可以了解group内含的所有组名称；
       groupinstall-安装一整组软件；     groupremove-移除某个组；
4.全系统自动安装
  yum -y update 如果需要每天检查自动升级 vim /etc/crontab  0 3 * * * root /user/bin/yum -y -update
  此外你还得分析登录文件与收集root的信件的,因为如果升级的是内核软件(kernel),那么你还是得要重新开机才会
  让系统的软件顺利进行。所以还是得分析日志文件,若有新内核安装,就重新开机,否则就让系统自动维持在最新较安全的环境吧。
5.管理的抉择:RPM还是Tarball
  1.优先选择原厂的RPM功能；
  2.选择软件官网发布的RPM或者是提供的容器网址；
  3.利用Tarball来安装特殊软件；
  4.用Tarball测试新版软件；

****************************************第24章 X Windows设置介绍**************************************************************************
1.主要组件:X Server/X Client/Windows Manager/Display Manager
  X Server:硬件管路、屏幕绘制与提供字体功能
  X Client:负责X Server要求的"事件"的处理
  X Windows Manager:特殊的X Client,负责管理所有的X Client软件。类型有KDE、GNOME、SFCE还有twm等。
  Display Manager:提供登录需求

2.X Windows的启动流程
 1.在文字界面启动X : 通过startx命令
   startx [X client 参数] -- [X server 参数]
 
 2.startx最重要的任务是找出用户或者系统默认的X Servr/X Client的设置文件,而用户也可以使用startx外接参数来取
  代设置文件内容。事实上启动X的是xinit这支程序,startx仅是帮忙找出设置值而已！那么startx找到的设置值可用顺
  序是什么呢？
  X Server的参数方面:1.使用startx 后面接的参数；
                     2.若无参数,则查找用户根目录的文件,亦即~/.xserverrc；
                     3.若无上述两者,则以/etc/X11/xinit/xserverrc；
                     4.若无上述三者,则单纯执行/user/bin/X(此即X server可执行文件)；
  X Client的参数方面:1.使用startx 后面接的参数；
                     2.若无参数,则查找用户主文件夹的文件,亦即~/.xinitrc；
                     3.若无上述两者,则使用/etc/X11/xinit/xinitrc；
                     4.若无上述三者,则单纯执行xterm(此即X下面的终端机软件)；

 3.由startx调用执行的xinit:实际上,当startx找到需要的设置值后,就调用xinit实际启动X的。
                          xinit [client option] -- [server or display option]
  那么为什么不直接执行xinit而使用startx来调用xinit呢？这是因为我们必须要取得一些参数！start可以帮我们快速
  找到这些参数而不必手动输入。

 4.启动X Server的文件:xserverrc-在启动X Server时,Xorg会去读取/etc/X11/xorg.conf这个设置文件。<===========
   事实上我们的Linux可以同时启动多个X。各个X显示的位置使用-display来处理,显示位置为:0、:1等；
   第一个X的界面是:0即是tty7,第二个X则是:1即是tty8。                                         <===============
   启动了X Server后,接下来就是加载X Client到这个X Server上面

 5.启动X Client的文件:xinitrc 
   最终在X Client文件当中会有两个命令的查询,包括startkde与gnome-session这两个,这也是CentOS默认会提供的两
   个主要的Window Manager。而你也可以通过修改/etc/sysconfig/desktop内的DESKTOP=GNOME或DESKTOP=KDE来决定
   默认使用哪个窗口管理器。如果你没有安装这两个,那么X就会去使用twm这个窗口管理器来管理你的环境。

   另外,如果有特殊需求,你当然可以自定义X Client的参数！这就得要修改你的主文件夹下的~/.xinitrc。不过要注意
   如果你的..xinitrc设置文件里面有启动的X Client很多的时候,千万注意将除了最后一个Window Manager或X Client
   之外,都放在后台里面去执行(后面加&)。

 6.无论怎么说,鸟哥还是希望大家通过解析startx这个script的内容去找到每个文件,再根据分析每个文件来找到你distrubutions
   上面的X相关文件。另外需要注意的是,如果你的.xinitrc设置文件里面有启动X client很多的时候,千万注意将除了
   最后一个Window Manger或X Client之外,都放到后台里面去执行(方法是在最后面加上&)。

 7.X启动的端口:在X Window System的环境下,我们称port 6000为第0个显示接口,也即hostname:0,那个主机名通常可以
               不写,所以就成了:0即可。在通常情况下,第一个启动的X(无论是启动在第几个port number)是在tty 7，
               亦即按下[ctrl]+[alt]+[F7]那个界面,而启动的第二个X(注意到了,可以有多个X同时启动在你的系统)，
               默认在tty8。

3.X启动流程测试

4.我是否需要启用X Window System
  X Window仅是Linux上面的一个软件，鸟哥不建议对Internet开放的服务器启动X Window的。

5.X Server设置文件解析与设置
  X Server的设置文件都是默认放置在/etc/X11目录下,而相关的显示模板或上面提到的显示模板则主要放置在/usr/lib/xorg/modules下面。
  比较重要的是字体文件与芯片组:提供的屏幕字体(/user/share/X11/fonts/)、显卡的芯片组(/user/lib/xorg/modules/drivers/)

6.解析xrog.conf设置
  本书使用的测试机使用的X Server是Xorg基金会提供的X11R7版,因为是Xorg这个X Server,因此我们的设置文件名为/etc/X11/xorg.conf
  X version查看X Server版本；注意在修改这个文件之前,务必备份一份,防止导致X Server无法启动。
  内容: Section "section name"
        ...     <===与这个section name有关的设置值
        ...     
        EndSection
  至于常见的section name主要有:
  Moudule:被加载到X Server当中的模块(某些功能的驱动程序)
  InputDevice:包括输入的键盘的格式、鼠标的格式、以及其他相关输入设备
  Files:设置字体所在的目录位置等
  Monitor:监视器的格式,主要是设置水平、垂直的更新频率，与硬件有关
  Device:这个重要，就是显卡芯片组的相关设置
  Screen:这个是在屏幕上显示的相关分辨率与色彩深度的设置项目，与显示的行为有关
  ServerLayout:上述的每个选项都可以重复设置,这里则是此X Server要选用的那个选项值的设置

7.X Font Server(XFS)与加入其它中文字体
  这个XFS的主设置文件在/etc/X11/fs/config中,而字体文件则在/usr/share/X11/fonts/中,字型一般放置在/usr/lib/xorg/modules/fonts/当中
  至于启动的脚本则在/etc/init.d/xfs中。
  mkfontdir 这个命令生成font.dir这个文件,提供字体文件目录的说明
  chkfontpath 查看xfs支持的目录                  |          xlsofnts 在X Window下面启动终端机
  fc-cache -f -c 将上诉字体加入字体的支持        |          fc-list 列出已被使用的字体文件

8.设置文件重建与显示器参数微调
 1.Xorg -configure :1 使用Xorg重新制作出设置文件
   此时X会主动以内置的模块进行系统硬件的探索,并将将硬件与字体检测结果写入/root/xorg.conf.new这个文件里面去
   这就是xorg.conf的重置结果。不过这个新建的文件不见得真的能够启动X Server,所以我们需要测试。
   X -config /root/xorg.conf.new :1  测试上面新的设置文件能否顺利运行
 2.关于屏幕分辨率与更新率
   gtf 水平像素 垂直像素 更新频率 [-xv]
   -x:使用xorg设置文件的模式输出,这是默认值；    |          -v:显示检测结果
   更改后记得将数据写入xorg..conf内的Monitor项目中。

9.显卡驱动程序安装范例
  
***************************************第25章 Linux 备份策略*********************************************************

1.备份哪些Linux数据
  具有备份意义的文件通常可以粗分为两大类,一类是系统基本设置信息,一类则是类似网络服务的内部数据。

  1.操作系统本身需要备份的文件
    这方面的文件主要跟账号与配置文件有关系。/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow、/home下面
    的用户文件夹等,而由于Linux默认的重要参数文件都在/etc/下面,所以只要将这个目录备份下来啊的话,那么几乎所有的配置文件都可以被保存的！
    至于/home目录是一般用户的文件夹,自然也需要备份！如果你曾经修改过内核,那么/boost里面的信息也很重要。
    所以以下目录:/etc/整个目录、/home 整个目录、/var/spool/mail、/boot、/root,以及如果你自行安装过其他软件
                 那么/usr/local或/opt也最好备份以下。
  2.网络服务的数据库方面
    如果你的网络配置文件安装都是以原厂提供的为主,那么你的配置文件大多是在/etc下面,但如果你的套件大多是来自
    自行的安装,那么/usr/local这个目录就相当重要了。
    假设我们提供的服务软件都是使用原厂的RPM安装的,所以需要备份的数据文件有:
     1.软件本身的配置文件,例如:/etc/整个目录,/usr/local/整个目录；
     2.软件服务器提供的数据,以WWW及MYSQL为例: WWW数据:/var/www 整个目录或/src/www 整个目录、及系统的用户主文件夹
                                              MySQL  :/var/lib/mysql 整个目录
  3.推荐需要备份的目录:/boot、/etc、/home、/root、/us/local(或者/opt及/srv等)、/var 。                                   
  4.不需要备份的目录:/dev、/proc、/mnt与/media、/tmp 。    
  5.选择备份设备

2.备份的种类、频率与工具的选择
  1.完整备份的增量备份:与在完整备份基础上的上一次备份进行比较
    完整备份的常用工具有dd,cpio,dump/restore等。dd可以直接读取磁盘的扇区(sector)而不理会文件系统,不过缺点
    是很慢。cpio是能够备份所有的文件名,不过要配合find或其他找文件名的命令才能够处理得当。以上两个都能够进
    行完整备份,但增量备份就得额外使用脚本程序来处理。也可以直接进行增量备份的就是dump这个命令咯!
  
  2.完整备份的差异备份:与原始的完整备份进行比较
    rsync进行镜像备份。这个rsync可以对两个目录进行镜像,其简单的语法为: rsync -av 源目录 目标目录
  
  3.关键数据备份
    例：依据日期来备份mysql的数据库 tar -jpcvf mysql.`date +%Y-%m-%d`.tar.bz2 /var/lib/mysql
   
    备份是非常重要的工作,如果我们需要自动备份的话,需要自己编写script,配合crontab去执行！

3.鸟哥的备份策略
  1.每周系统备份的script
    包括/home,/var,/etc,/boot,/usr/local等目录与特殊服务的目录；
    http://linux.vbird.org/linux_basic/0580backup/backupwk-0.1.sh
  2.每日备份数据的script
    目前仅备份MySQL数据库
    http://linux.vbird.org/linux_basic/0580backup/backupday.sh
  3.将script加入crontab自动处理
    vi /etc/crontab
    30 3 * * 0 root /back/backupwk-0.1.sh
    30 2 * * 0 root /back/backupday.sh
  4.远程备份的script
     1.使用FTP上传备份数据
     2.使用rsync上传备份数据  

4.灾难恢复的考虑 

************************************第26章 Linux内核编译与管理**************************************************************

1.编译前的任务:认识内核与取得内核源码
  1.什么是内核(Kernel)
    内核就是系统上面的一个文件而已,这个文件包含了驱动主机各项硬件的检测程序与驱动模块。
    内核模块:现在硬件更新速度太快,如果我内核比较旧,但我换了新硬件,需要重新编译一个内核吗？因此,Linux早就
             开始使用所谓的模块化设置了！即是将一些不常用的类似驱动程序的内容独立出内核,编译成模块,然后
             内核可以在系统正常运行的过程当中加载这个模块到内核的支持。如此我不需要改动内核只要编译适当
             内核模块并加载它,我的Linux就能使用这个硬件了。
    内核编译:内核由源代码编译而成!也就是说,我们必须要取得内核的源代码,然后利用Tarball安装方式提到的编译
             概念来实现内核的编译。
  
  2.更新内核的目的
  3.内核的版本
  4.内核源码的取得方式
  5.内核源代码的解压缩/安装/观察

2.内核编译的前处理与内核功能选择
  1.硬件环境查看与内核功能要求
  2.保持干净的源代码:make mrproper - 清理临时文件与设置文件。/
                                     这个操作会将你以前进行的内核功能选择文件也删除掉,所以几乎只有第一次
                                     执行内核编译前才进行这个操作,其余时刻,你想要删除前一次编译过程的残留
                                     数据,只要执行make clean。因为make clean仅会删除类似目标文件之类的编译
    				     过程生成的中间文件,而不会删除设置文件。
  3.开始挑选内核功能:make XXconfig
    内核功能列表文件:/boot/config-xxx
    make menuconfig：最常用,在文字模式下面显示类似图形界面的方式,不需要启动X Window就能够挑选内核功能菜单。
    make oldconfig：通过使用已存在的./config文件内容,使用该文件内的设置值为默认值,只将新版本内核内的新功能
                    选项列出让用户选择,可以简化内核功能的挑选过程。
    make xconfig：通过以Qt为图形界面基础功能的图形化界面显示,需要具有X Window的支持。
    make gconfig：通过以Gtk为图形接口基础功能的图形化界面显示,需要具有X Window的支持。
    make  config：最老式的功能挑选方式,每个选项都以条列式一条一条列出让你选择,如果设置错误只能再次选择,很不人性化。
    
    若为[*]、<*>则表示编译进内核；若为<M>则表示编译成模块。如果不知道该选项为何时,且有模块可以选,那么就直接
    选择为模块。  
    建议:"肯定"内核一定要的功能,直接编译进内核内；
         可能在将来会用到的功能,那么尽量编译成模块；
         不知道那个东西要干嘛,看帮助也看不懂的,那么就保留默认值,或者将它编译成模块；
  
  4.内核功能细项选择

3.内核的编译与安装
  1.编译内核与内核模块: 你可以先使用"make help"去查阅一下所有可用编译参数就会知道以下基本功能
                        make vmlinux <==为经压缩的内核     make modules <==仅内核模块
                        make bzImage <==仅压缩的内核(默认) make all     <==进行上述的三个操作

    bzImage可以制作出压缩后的内核,也就是一般我们拿来进行系统开机的信息。所以,基本上我们会进行的操作是:
            make clean <==先清除临时文件  make bzImage <==先编译内核  make modules <==再编译模块
    最后制作出来的数据是被放置在/usr/src/kernels/linux-2.6.30.3/这个目录下,还没有被放到系统的相关路径中。
  
  2.实际安装模块: 模块是放置到/lib/modules/$ (uname -r)目录下
                  安装模块 make modules_install
  
  3.开始安装新内核与多重内核菜单(grub)
    内核的安装过程中,需要移动bzImage文件、创建initrd文件、编辑/boot/grub/menu.lst等操作。
    现在我们知道内核文件放置在/usr/src/kernels/linux-2.6.30.3/arch/x86/boot/bzImage下,但是其实系统内核理论
    上都是摆在/boot下面且为vmlinuz开头的文件名。
    1.移动内核到/boot且保留旧内核文件
    2.新建相对应的Initial Ram Disk(initrd): mkinitrd -v/boot/initrd-2.6.30.3vbird.img 2.6.30.3vbird
    3.编辑开机菜单(grub): vim /boot/grub/menu.lst

4.额外(单一)内核模块编译
  1.编译前注意事项: 如果我们想要自行使用硬件开发商提供的模块来进行编译时,就需要使用到内核所提供的源文件
                    当中所谓的头文件(header include file)来取得驱动模块所要需要的一些函数库或头的定义。
   
   在2.6版本以后,内核使用比较有趣的方法来设计它的原代码放置文件目录,那就是/lib/modules/$(uname r)/build
   及/lib/modules/$(uname -r)/source这两个链接文件来指向正确的内核源代码放置目录。    
   
   其中modules.dep文件记录了内核模块的相依属性的地方,依据该文件,我们可以简单实用modprobe这个指令来加载
   模块。
   
   如果你想要在默认的内核下面添加模块的话,那么就得找到kernel对的SRPM文件了！安装该文件并且取得source code
   后,才能顺利编译。
  
 2.单一模块编译
   如果后来发现忘记加入某个功能了,那么如果你仅是重新编译模块的话,我们可以先到目前的内核源代码所在目录执行
   make menuconfig,然后将NTFS的选项设置成为模块,之后执行make fs/ntfs/,那么ntfs的模块(ntfs.ko)就会自动编译
   出来了！然后将该模块复制到/lib/modules/2.6.30.3vbird/kernel/fs/ntfs/目录下,再执行depmod -a,就可以在原来
   的内核下面新增某个想要加入的模块功能。

 3.内核模块管理

5.例题
  1.简要说明内核编译的步骤
    1.先下载核心原始码,可以从www.kernel.org或者是distributions的SRPM来着手；
    2.以下以Tarball来处理,解开原始码到/usr/src/kernel目录下；
    3.先进行旧资料删除的动作:[make mrproper]；
    4.开始挑选核心功能,可以利用[make menuconfig]、[make oldconfig]、[make gconfig]等；
    5.清除过去的中间暂存挡资料:[make clean]；
    6.开始核心文件与核心模块的编译:[make bzImage]、[make modules]；
    7.开始核心模块的安装:[make modules_install]；
    8.开始核心文件的安装,可以使用的方式有[make install]或者通过手动的方式复制核心文件到/boot/grub当中；
    9.建立initrd档案；
   10.修改/boot/grub/menu.lst档案；
=======
《鸟哥的linux私房菜》http://linux.vbird.org/linux_basic/centos5.php
***********************************第1章 linux是什么***********************************************************************
硬件->内核->系统调用->应用程序   内核和系统调用两者组成操作系统
linux distribution：Redhat Fedora Centos 等
其实Linux是指的系统的内核，不能认为是一个系统。有人在内核的基础上增加一些软件，就成了一个操作系统了。

***********************************第3章 磁盘分区**********************************************************************************
主分区P、扩展分区E（最多有一个扩展分区，扩展分区又可以分出逻辑分区L号码由5号开始）
扩展分区的目的是使用额外的扇区来记录分区信息,扩展分区本身并不能被拿来格式化。
逻辑分区的数量依据操作系统而不同,在Linux系统中,IDE硬盘最多有59个逻辑分区(5号到63号),SATA硬盘则有11个逻辑
分区(5号到15号)。

/dev/hda[1-4]前四个号码都是保留给主分区或扩展分区使用,所以逻辑分区的设备名称号码就由5号开始。

两者最多有四个,分区最小单位是柱面
扇区为最小物理存储单位，每个扇区为512bytes
将扇区组成一个圆，那就是柱面（cylinder），柱面是分区（partition）的最小单位
/dev/sd[a-p][1-15]：为SCSI，SATA,USB,Flash等接口的磁盘文件名
/dev/hd[a-d][1-63]: 为IDE接口的磁盘文件名

各硬件设备在Linux中的文件名:
IDE硬盘:/dev/hd[a-d]      CD ROM/DVD ROM:/dev/cdrom    25针打印机:/dev/lp[0-2]、USB打印机:/dev/usb/lp[0-15]
SCSI/SATA/USB硬盘/U盘:/dev/sd[a-p]   软盘:/dev/fd[0-1]   USB鼠标:/ddev.usb/mouse[0-15]、PS2鼠标:/dev/psaux
IDE磁带机:/dev/ht0、SCSI磁带机:/dev/st0

文件系统通常会将权限与属性放置到inode中，而实际数据则放置到data block块中，还有一个超级块
会记录整个文件系统的整体信息，包括inode与block的总量、使用量、余额量等

所谓的磁盘分区就是指告诉操作系统"我这块磁盘在此分区可以访问的区域是由A柱面到B柱面之间的块"
通常我们可以称呼一个可以挂载的数据为一个文件系统而不是分区

CMOS是记录各项硬件参数且嵌入在主板上面的存储器，BIOS则是一个写入主板的一个韧体（韧体就是写入到
硬件的一个软件程序）接下来BIOS会去分析计算机里面有哪些存储设备，并取得能够开机的硬盘，并到该硬
盘里面去读取第一个扇区的MBR,MBR这个仅446bytes容量里会放置最基本的引导加载程序，这个程序目的是
加载内核文件。

BIOS->MBR（主引导分区）->引导加载程序（boot loader）->内核文件
BIOS和MBR都是硬件本身支持的功能，boot loader是MBR上面的一套软件

***********************************第4章 安装小技巧**************************************************************************
swap:内存交换空间。由于swap并不会使用到目录树的挂载，所以swap就不需要指定挂载点
磁盘阵列（saftware RAID） /dev/md[0-15]
引导装载程序grub，安装时最好选择安装在设备MBR中
若笔记本安装失败，可以尝试在开机时加入"inux nofb apm=off acpi=off"来关闭省电功能
设置时不要选择启动kdump，那是供开发者查阅司机数据的。kdump就是当内核发送错误时,是否要将当时的内存内的信息
写到文件中,而这个文件就能够给内核开发者研究为什么会宕机。

新主机仅有一块硬盘：使用windows XP光盘启动安装，安装分区，再将XP安装到C盘，再来安装linux
旧主机有两块以上硬盘
旧主机仅有一块硬盘：window和linux不能共存在同一个分区，所以要清出来一块分区

GMT时间:格林尼治时间,比上海时间晚了8个小时。

***********************************第5章 在线求助**********************************************************************************
目前,CentOS默认至少提供GNOME/KDE这两种图形界面(我们称窗口管理员,Window Manager)。
注销并不是关机,只是让你的账号离开系统而已。

X Window与命令行模式的切换:
Linux默认情况下会提供6个Terminal终端界面来让用户登录，切换方式是Ctrl+Alt+F1~F6
Ctrl+Alt+F1~F6 为tty1~tty6的操作界面环境（运行等级run level 3）
Ctrl+Alt+F7 为图形界面桌面（运行等级run level 5）
tty7 就是开机完成后默认等待登录的图形环境
tty也就是teletypewriter。tty1～6六个文字界面终端,tty7图形界面终端,tty8系统信息。

如果你是以纯文本环境启动Linux的,默认tty7是没有东西的,万一如此的话,那怎么启动X窗口界面呢？你可以在tty1~tty6
的任意的一个终端界面使用你的账号登录后,然后执行如下命令:startx
不过startx生效必须要以下事情的配合:1.你的tty7并没有其他的窗口软件正在运行；
                                   2.你安装了X Window系统,并且X Server是能够顺利启动的；
                                   3.你最好有窗口管理员；
                                   4.启动X窗口所必须的服务,例如字型服务器(XFS)必须要先启动；

显示日期的命令: date +%Y/%m/%d 年月日   date +%H:%M:%s 时分秒

command [-options] parameter1 parameter2 ...

Tab键具有"命令补全"和"文件补全"的功能，可以避免我们打错命令或文件名。
例：命令（cat）[Tab][Tab] 即Tab接在一串命令的第一个命令后面，则为"命令补全"，可以查看以命令
   （cat）开头的命令。
    命令（ls) [-options选项 例：-al]  parameterl（参数 例:~/.bash ）[tab][tab] 即Tab接在一串
    命令的第二个命令以后时，则为"文件补全"，表示在该目录下面所有以.bash为开头的文件名都被显
    示出来了。

ctrl+c中断目前程序； ctrl+d键盘输入结束代替exit ；ctrl+z挂起,fg返回；
man page ： 在线求助         显示内容的文件放在/user/share/man 与 /user/local/man
	NAME         这个命令完整全名
                SYNOPSIS     这个命令的基本用法
	DESCRIPTION  详细说明刚才语法谈到的参数的用法
	ENVIRONMENT  这个命令相关的环境参数说明

man -k 命令 :为查询关键字  
man -K 命令 :则是整个系统的man page查询，每个被检查到有关键字的man page file都会询问是否有要显示,你可以
             输入[ynq],y表示显示到屏幕,n表示不显示,q结束man的查询。
man -f  命令         查询与命令有换的说明文件 也可写whatis
man -k  命令         查询含有命令关键字的文件 也可以apropos
两个特殊命令要使用需要创建whatis数据库，必须以root身份执行makewhatis命令。
帮助文件放在/user/share/doc目录
如果你想知道某些关键字的话,那么可以在任何时候输入"/word"来主动查找关键字。

在man page显示的内容中，指令后面接一组章节数字（1/5/8/...）
1表示的是一般用户可使用的命令；3表示一些常用的函数与函数库；5表示的是配置文件或某些格式文件 ；
7表示惯例与协议；              8表示的是系统管理员可用的指令...
例如你执行了"man date",会出现在第一行的是DATE(1),则代表的是一般用户可使用的命令。

也可以这样输入命令：“man [章节号] 手册名称”
例如：
man 1 time （或 man time） 就是查看 time 系统命令；
man 2 time 就是查看C函数 time_t time(time_t *t); 的定义
查询crontab指令可以使用man crontab,至于查询/etc/crontab则可以使用man 5 crontab.

whatis [命令或者数据] <==相当于 man -f [命令或者数据]
apropos [命令或这数据] <==相当于man -k [命令或者数据]

info page：linux中额外的在线求助方法

当输入命令后出现乱码：默认中文编码无法输出数据，输入LANG=en_US，echo $LANG查看更改

超简单文本编辑器：nano
^代表ctrl键  M代表ALT键
^G	取得在线帮助 
^X	离开nano软件，若有修改过文件会提示是否保存
^O	保存文件，若有权限的话就能保存文件
^R	从其他文件读入数据，可以将摸个文件的内容粘贴在本文件中。
^W	查询字符串。
^C	说明目前光标所在处的行数和列数等信息
^_	可以直接输入行号，让光标快速移动到该行
M+Y 	校正语法功能开启或关闭
M+M	可以支持鼠标来移动光标的功能

*的用法：比如当前目录下有abc.c、abdd.c、abeff.c。可以用ls ab*.c来查看。
\的用法：比如一行不够没有打完，在后面打上\接enter，在下一行就能继续输入。

数据同步写入磁盘：sync(将内存中尚未被跟新的数据写入硬盘,防止不正常关机导致的数据丢失)

X window重启而不是linux重启ctrl+alt+backspace

正确的关机方法：
如果查看目前有谁在线，可以执行who命令，如果要查看网络的联机状态，可以执行netstat -a命令，
而要看后台执行的程序可以执行ps -aux命令。
将数据同步写入硬盘的命令：sync 
惯用的关机命令：shutdown
重启，关机：reboot，halt，poweroff

惯用的关机命令:/sbin/shutdown [-t秒] [-arkhncfF] 时间 [警告信息]

切换执行等级：init
linux共有七个执行等级，下面是其中五个：
run level 0 关机
run level 1 单用户模式,与Win9x下的安全模式类似
run level 2 基本多用户模式，没有 NFS 支持
run level 3 纯命令行模式,完整的多用户模式,是标准的运行级
run level 4 一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。
run level 5 含有图形界面模式,就是X11,进到XWindow系统了
run level 6 重启

开机过程的问题排解
 如果根目录没有损坏:输入"fsck/错误分区位置"
 如果根目录损坏了：将硬盘拔掉，接在另一台linux上，不要挂载，以root身份执行"fsck/dev/sdb1 "
 （dev/sdb1指的是硬盘设备文件名）

忘记root密码:你只要以单用户维护模式登录即可更改你的root账号密码。

例题:1.由于反斜杠(\)的英文为"escape",因此在上个步骤的man环境中,你可以使用"/escape"来查询各反斜杠后面接的
       字符所代表的意义。
     2.如果我想要在/etc/issue文件内表示时间与tty好吗的话,应该找到哪个字符来表示(通过反斜杠功能)?答案:\t与\l
     

***************************************第6章 文件权限与目录配置**************************************************************
[权限][连接][所有者][用户组][文件容量][修改日期][文件名]                 所有者 用户组 其他

ls -al：表示列出所有文件详细权限与属性
[权限]：-rwxrwx---      rwx为读、写、执行 4 2 1
     ①第一个字符代表这个文件是"目录、文件、或链接文件等"。
      若是[d]则是目录，若是[-]则是文件，若是[L]则是链接文件linkfile，若是[b]则表示设备文件里面
      的可供存储的接口设备，若是[c]则表示设备文件里面的串行端口设备，例如键盘、鼠标。
     ②接下来的字符以三个为一组，第一组为文件所有者的权限，
                                 第二组为同用户组的权限，
                                 第三组为其他非本用户组的权限。
[连接]：表示有多少文件名连接到此节点（i-node） 连接文件相当于快捷方式的作用，但文件名又有不同
[文件名]：如果文件名之前多了一个"."表示为隐藏文件。      

chgrp [-R] dirname/filename....             <==改变文件所属用户组
要改变的组名必须要在/etc/group文件内存在才行

chown [-R] 账号名称:组名 文件或目录         <== 改变文件所有者
例：将install.log所有者改为bin这个账号  chown bin install.log
    将install.log所有者与用户组改回root chown root:root install.log 
    将install.log所有组改为sshd这个组   chown .sshd install.log
chmod [-R] xyz 文件或目录                   <==改变文件的权限
cp 源文件 目标文件 
chomd a代表all u代表user g代表group o代表others
      添加权限 例:增加.bashrc这个文件么每个人均可写入的权限chmod a+w .bashrc
      权限针对文件的重要性：其中的w不具备删除文件本身的权限。
      权限针对目录的重要性：r具有读取目录结构列表的权限。
                            w具有更改目录结构列表的权限,可以删除已经存在的文件与目录(无论该文件权限为何)。
                            x代表用户能否进入该目录成为工作目录的用途。如果只开放了r权限，将会
			    导致无法到目录下读取文件（最多只能看到文件名），无法查阅到文件的内
			    容。要注意，要开放目录给任何人浏览，至少应该要给r及x的权限，w不可随
                            便给。
工作目录（用cd进入该目录）			   

设备与设备文件： 块（block）设备文件：存储数据，以提供系统随机访问的接口设备，例如硬盘，软盘。
    		 字符（character）设备文件：串口的接口设备，例如键盘，鼠标。
套接字（sockets）：既然被称作数据接口文件，这种数据文件通常被用在网络的数据连接。
管道（FIFO，pipe）：主要解决多个程序同时访问一个文件造成的错误问题。

linux目录配置标准:FHS标准---主要目的是希望让用户可以了解到已安装软件通常放置于哪个目录下
/（root，根目录）：与开机系统有关； 越小越好，且应用程序所安装的软件最好不要与根目录放在同一个
				    分区。
/usr（UNIX software resource）：UNIX操作系统软件资源所放置的目录，与软件安装/执行有关
				 而不是用户目录
/var（variable）：与系统运作过程有关
/lost+found  这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发
             生错误时，将一些丢失的片段放在这个目录下。
/proc   这个目录本身是一个虚拟文件系统。它放置的数据都是在内存当中。例如系统内核、进程、外部设备
        的状态及网络状态等。
/sys    这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。

.：代表当前目录，也可以用./来表示
..：表示上一层目录，也可以../来表示   你常常会看到cd..或./command就是代表上一层与目前所在目录的
                                      工作状态。
例子：如何先进入/var/spool/mail目录在进到/var/spool/cron/目录内？
      1.cd/var/spool/mail 
      2.cd../cron              相对路径的应用

查看linux标准与内核   uname -r
                      lsb_release -a

目录的相关操作： 比较特殊的目录： . 代表此层目录  .. 代表上层目录 -代表前一个工作目录
				  ~ 代表目前用户身份 ~account 代表account这个用户的主文件夹

例题:1.FHS制定出来的四种目录特色为shareable、unshareable、staric、variable。
     2.FHS所定义的三层主目录为/、/var、/usr。
     3.有五个目录不可与根目录放在不同的分区,分别为/etc、/bin、/lib、/dev、/sbin五个。
     4./bin放置的是一般使用者惯用的指令,至于/sbin则是系统管理员才会使用的指令。

***************************************第7章 文件与目录管理*********************************************************************************
1.目录的相关操作:
  . 代表此层目录 ； .. 代表上一层目录 ； - 代表前一个工作目录 ； ~ 代表"目前用户身份"所在的主文件夹 ；

pwd 显示目前所在目录 [-p]显示当前目录而非用连接路径

创建/删除一个目录：
mkdir [-mp] 目录名称 -m：配置文件案的权限 mkdir -m 711 test2
                     -p：帮助你直接将所需的目录（包含上层目录）递归创建起来/即可以创建多层目录
                         mkdir -p text1/text2/text3
rmdir [-p] 目录名称  删除空的目录 仅能删除空的目录
echo 显示、打印  $表示后面接的是变量

2.执行文件路径的变量 ：$PATH 
环境变量PATH这个变量内容是由一堆目录所组成的！
各个命令相当于在PATH内创建了快捷方式，随着目录的更改，这些快捷方式会失效，因此也可以在PATH添加这些
"快捷方式"，输入PATH="$PATH"/命令所在位置。因此使用绝对路径直接指定某个命令的文件名来执行会比查询
PATH来得正确。
例:将/root目录加入PATH当中: PATH="$PATH":/root

查看文件和目录：
ls [-aAdfFhilnrRSt] 目录名称   /   ls [--color={never,auto,always}] 目录名称 
ls [--full-time] 目录名称
-F：根据文件、目录等信息给予附加数据结构，例如：*代表可执行文件   /：代表目录 
					        =：代表socket文件 |：代表FIFO文件
-l：列出长数据串，包含文件属性与权限等数据 ll命令相当于 ls -l
-i：列出inode号码  /  -d：列出目录本身，而不是列出目录内的文件数据
蓝色显示目录，白色显示一般文件

复制文件或目录：
cp [-adfilprsu] 源文件（source） 目标文件（destination）
-a：相当于下面-p+d+r的意思 
-d: 若源文件为连接文件的属性（link file），则复制连接文件属性而非文件本身
-p：连同文件属性一起复制过去，而非使用默认属性（备份常用）
-u：在目标文件与源文件有差异时才会复制（备份常用）
-r：递归持续复制，用于目录的复制行为 
-s：复制成为符号链接（symbolic link）/软连接文件,即"快捷方式"文件；
-l：进行硬链接（hard link）的连接文件的创建，而非复制文件本身。与i-node节点有关。
要想复制到当前目录（先cd到目录），最后的"."不要忘

移除目录或文件：rm命令
rm [-fir] 文件或目录
-r：递归删除，最常用在目录的删除。
如果确定要删除目录而不要询问，在命令前加上反斜杠，可以忽略alias的指定参数。

移动文件或目录，或更名：mv命令
mv [-fiu] 源文件（source） 目标文件（destination）

取得路径的文件名与目录名称
basename：取得最后的文件名   dirname：取得最后的目录名

cat：由第一行开始显示文件内容 cat[-AbEnTv] /  tac：从最后一行开始显示
-A:相当于-v+E+T的整合参数，可列出一些特殊字符，而不是空白而已
-b：列出行号，仅针对非空白行做行号显示，空白行不标行号
-E：将结尾的 [断行字符$] 显示出来
-n: 打印出行号，连同空白行也会有行号
-T：将 [Tab键] 以^I显示出来
-v： 列出一些看不出来的特殊字符

nl：添加行号打印  nl[-bnw] 文件

more/less:一页一页地显示文件内容，less可以向前翻页
Enter ：代表向下滚动一行  /   空格键 ：代表向下翻一页
/字符串 ：代表在显示的内容当中，向下查询字符串这个关键字，重复前一个查询n
?字符串 ：代表向上查询字符串，反向重复前一个查询N
:f :立即显示文件名一级目前显示的行数 /  q ：代表立即离开more，不在显示该文件内容
b或ctrl+b ：代表往回翻页，不过这操作只对文件有用，对管道无用

head：取出前面几行  head [-n number] 文件
tail：取出后面几行  tail [-n number] 文件 

od：以二进制的方式读取文件内容   od [-t TYPE] 文件
TYPE: a: 利用默认字符输出 / c:使用ASCII字符输出 / d：利用十进制来输出 / f：利用浮点数来输出
      o：利用八进制来输出数据 / x：利用十六进制来输出数据

修改文件时间或创建新文件:touch
--time=mtime （modification time）内容数据（指的是文件的内容）更改时，就会更新这个时间
--time=ctime （status time）文件的状态（权限与属性）更改时，就会更新这个时间
--time=atime （access time）文件内容被取用（被命令读取）时，就会更改这个时间

touch [-acdmt] 文件
-a：仅修改访问时间 / -c：仅修改文件时间 
-d：后面可以接欲修改的日期而不用目前的日期 也可使用 --date="日期或时间"
-t：仅修改mtime / t：后面可以接欲修改的时间而不用目前的时间 格式为：[YYMMDDhhmm]

；代表连续命令的执行，可以在一行命令当中写入多条命令

文件默认权限-- umask [-s]  / umask的分数指的是该默认值需要减去的权限 /修改默认 umask 数字
用户创建文件默认没有可执行（x）权限，创建目录默认所有权限开放
例：022代表 user没有被拿走任何权限，group与others的权限被拿走了2（也就是w这个权限）
    新建文件时：（-rw-rw-rw-）-（-----w--w-）==>-rw-r--r--

3.文件与目录的默认权限与隐藏属性
设置文件隐藏属性（只能在Ext2/Ext3的文件系统上面生效）
chattr [+-=] [Asacdistu] 文件或目录名称
a：当设置a之后，这个文件将只能增加数据，不能修改和删除数据，只有root才能设置这个属性
i: 使文件不能被删除，改名，设置连接也无法写入或添加数据，只有root才能设置这个属性
lsattr [-adR] 文件或目录  显示文件隐藏属性

4.文件特殊权限: SUID、SGID、SBIT
当s这个标准出现在文件所有者的x权限上，此时就被称为Set UID。基本SUID有这样的限制和功能：
1.SUID仅对二进制程序(binary program)有效
2.执行者对于该程序需要具备x的可执行权限
3.本权限仅在执行该程序的过程中（run-time）有效
4.执行者将具有该程序所有者（owner）的权限

当s这个标准出现在用户组的x权限上，此时就被称为Set GID。基本SGID有这样的限制和功能：
1.SGID仅对二进制程序(binary program)有效
2.程序执行者对于该程序来说需要具备x的权限
3.执行者在执行过程中将会获得该程序用户组的支持
目录具有SGID的特殊权限时，代表用户在这个目录下新建的文件用户组都会与该目录用户组名相同。

Sticky Bit目前只针对目录有效，对于文件已经没有效果了，SBIT对于目录的作用是：
1.当用户对于此目录具有w,x权限，即具有写入的权限时；
2.当用户在该目录下创建文件或目录时，仅有自己与root才有权利删除改文件

在三个数字之前再加上一个数字，4代表SUID,2代表SGID,1代表SBIT  《==========================
例：将一个文件权限改为"-rwsr-xr-x"，由于s在用户权利中，所以是SUID，因此还要在原先755之前加上4
    也就是用"chmod 4755 filename"来设置

SUID不是用在目录上,SBIT不是用在文件上
S,T代表原先没有x可执行标注，所以S,T代表空的。
符号法： SUID为u+s，SGID为g+s，SBIT为o+t

查看文件类型：file   ――ASCLL或者data或者binary且又没有用到动态函数库（share library）

5.命令与文件查询
which [-a] command  ：寻找执行文件（binary），默认查找PATH内所规范的目录
alias 就是所谓的"命令别名",即输入前面的会等于后面接的命令，页码p188

要查找文件的完整文件名,可以使用whereis或locate到数据库文件去查找，而不实际查找文件系统。
whereis [-bmsu] 文件或目录名  ：寻找特定文件，但是会以数据库的结果去查找文件
-m：找出说明文件manual路径下的文件
locate [-ir] keyword :可以通过部分文件名称查找

updatedb:手动更新数据库的命令updatedb命令读取/etc/updatedb.conf，再去硬盘里面查找文件名的操作，最后就
更新/var/lib/mlocate内整个数据库文件咯~
寻找的数据是通过查找已创建的数据库/var/lib/mlocate，数据库的创建默认是每天执行一次

find [PATH] [option] [action]   利用find可以加入很多参数来直接查询文件系统,以获得自己想知道的文件名
-mtime n :n为数字，意义为在n天之前的"一天以内"被更改过的文件
-mtime +n:列出在n天之前（不含n天本身）被更改过的文件名
查找系统不属于任何人的文件：find / -nouser
查找/home下面属于vbird的文件：find /home -user vbird
-name filename：查找文件名为filename的文件
-type TYPE：查找文件的类型为TYPE的,一般正规文件(f),设备文件(b,c),目录(d),连接文件(l),socket(s),FIFO(p)等属性
-perm mode：查找文件权限刚好等于mode的文件
-exec command：command为其他命令，-exec后面再接其他命令来处理查找到的结果

例：找出/etc底下，文件容量大于50K，且文件所属人不是root的文件名，并且将权限完整的列出
find /etc -size +50k -a！-user root -exec ls -l{}\;
{}代表由find找到的内容，-exec一直到\是关键字，代表find额外的命令的开始（-exec）到结束（\），
在中间的就是find命令内的额外命令，在本例中就是ls -l{}，因为;在bash环境是具有特殊意义的，因此
利用反斜杠来转义。注意到-a，那个-a是and的意思为符合两者才算成功。！代表的是反向选择，亦即不是
后面的项目之意。-o就是or的意思。

权限与命令间的关系:
让用户能够进入某目录成为可工作目录的基本权限是什么
1.可使用的命令：例如cd等切换工作目录的命令
2.目录所需权限：用户对这个目录至少需要x的权限
3.额外需求：如果用户想要在这个目录利用ls查阅文件名，则用户对此目录还需要r的权限

用户在某个目录读取一个文件的基本权限是什么
1.可使用的命令：例如cat、more、less等
2.目录所需的权限：用户对于这个目录至少需要的x的权限
3.文件所需的权限：用户对于文件至少需要具有r的权限才行

让用户可以修改一个文件的基本权限是什么
1.可使用的命令：例如nano、vi编辑器
2.目录所需要的权限：用户在该文件所在目录至少需要x的权限
3.文件所需权限：用户对改文件至少需要r,w的权限

让一个用户可以创建一个文件的基本权限是什么
1.目录所需权限：用户在该目录需要具有w,x的权限，重点在w

让用户进入某目录并执行该目录下的某个命令的基本权限是什么
1.目录所需权限：用户在该目录至少需要x的权限
2.文件所需权限：用户在该目录至少需要x的权限

************************************第8章 文件系统管理*******************************************  
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性
读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。
启动扇区（boot sector） 数据块（data block）
文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、
文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。

inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，
存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。
每个inode大小固定为128bytes，block大小有1K,2K,4K

传统的磁盘与文件系统的应用中，一个分区就只能被格式化为一个文件系统，所以我们可以说一个文件系统
就是一个分区，但是由于新技术的利用，LVM与软磁盘阵列的应用，可以将一个分区格式化为多个操作系统
（例如LVM），也能将多个分区合为一个文件系统（LVM,RAID）
通常我们可以称呼一个可挂载的数据为一个文件系统而不是一个分区

super block：记录文件系统的整体信息，包括inode/block总量，使用量，剩余量以及文件系统的格式与
             相关信息
inode：记录文件的属性，一个文件占用一个inode（单可能有连接文件占用同一个inode），同时记录此文件
       的数据所在的block号码
block：记录实际文件的内容，若文件太大，会占用多个block

data block是用来放置文件内容的地方，在Ext2文件系统中所支持的block大小有1kb，2kb，4kb三种
每个block内最多只能放置一个文件的数据

inodetable（inode表格）
inode要记录的数据非常多，单偏偏只有128bytes，而inode记录一个block号码要花掉4bytes，那么至少
也要10万条block号码的记录，为此我们系统聪明的将inode记录block号码的区域定义为12个直接，一个
间接，一个双间接与一个三间接记录区。
第一层block会指定256个第二层，每个第二层可以指定256个第三层，每个第三层可以指定256个号码。

superblock（超级块）
一个validbit数据，若此文件系统已被挂载，则valid bit为0，若未挂载，则valid bit为1
一个文件系统应该仅有一个superblock，事实上除了第一个block group内会含有superblock之外，后续
的block group不一定含有superblock，而若含有superblock则该superblock主要是作为第一个blockgroup
内的super block的备份，这样就可以进行损害后的救援。

File system Description（文件系统操作说明）
block bitmap（块对照表）
inode bitmap（inode对照表）

dumpe2fs [-bh] 设备文件名  （查看文件系统） -h：仅列出superblock的数据，不会列出其他区段的内容
df 查看目前挂载的设备

每个文件（不管是一般文件还是目录文件）都会占用一个inode，可依据文件内容的大小分配多个block
给该文件使用。同一个文件系统是不会重复inode。

要想读取该文件，必须要经过目录记录的文件名来指向正确的inode号码才能读取。
也就是说，其实文件名只有目录有关，但文件内容则与inode有关。

数据不一致（inconsistent）状态：通过super block当中记录的valid bit（是否有挂载）与文件系统的
                                sate（clean与否）等状态强制进行数据一致性的检查。
日志文件系统（journaling file system）

异步处理（asynchronously）：如果文件没有被改动过，则内存区段的文件数据会被设置为clean
			    如果文件被改动过，此时内存中数据会被设置为Dirty
数据Dirty时,此时所有的操作都还在内存中执行,并没有写入到磁盘中,系统会不定时地将内存中设置为Dirty的数据
写回磁盘,以保持磁盘与内存数据的一致性。

手动使用sync命令来强迫内存中设置为Dirty的文件回写到磁盘中，若正常关机，关机命令会主动调用sync
来将内存的数据回写入磁盘中

挂载点的意义：将文件系统和目录树结合的操作我们称为挂载。挂载一定是目录，该目录为进入文件系统的
  	      入口。
挂载之前一定记得格式化。

查看你的Linux支持的文件系统有哪些，可以查看ls -l /lib/modules/$（umane -r）/kernel/fs
系统目前已加载到内存中支持的文件系统则有，cat /proc/filesystems

linux VFS：Virtual Filesystem Switch 的内核功能去读取文件系统，整个linux认识的文件系统其实都是
           VFS在进行管理，我们用户并不知道每个分区上面的文件系统是什么,VFS会主动帮我们做好读取
 	   的工作
		
磁盘与目录的容量:df、du
df [-ahikHTm] 目录或文件名： 列出文件系统的整体磁盘使用量
df / ：重点在找出磁盘文件名而已
-h：以人们较易阅读的GB,MB,KB等格式自行显示 / -i：不用硬盘容量，而以inode的数量来显示
-T：连同该分区的文件系统名称（例如ext3）也列出。

[Filesysterm][1k-blocks][Used][Available][Use%][Mounted on]

Filesysterm:代表该文件系统是在哪个分区，所以列出设备名称
1k-block：说明下面的数字单位是1KB，可以利用-h，-m来改变容量
Mounted on：磁盘挂载目录所在（挂载点）

/dev/shm ：利用内存虚拟出来的磁盘空间，在每部主机都不一样，而且新建的东西在下次开机时就消失了

du [-ahsSkm] 文件或目录名称： 评估文件系统的磁盘使用量（常用于评估目录所占容量）
-s：列出总量而已，而不列出每个各别的目录所占容量
-S：不包括子目录下的总计

连接文件：ln
hard link（硬连接或实际连接）：每个文件都会占用一个inode，有没有可能有多个文件名对应同一个inode
                               号码呢？hard link是在某个目录下新建一条文件名，将两个文件名连接
                               到同一个inode（与两文件不同的inode real），自然这两个文件名的相关
			       信息就会一样。
实际连接的文件读取示意图:
被连接文件->被连接文件所在目录的block->inode real->文件实际内容（block）
硬连接文件->硬文件所在目录的block->inode real->文件实际内容（block）
			       
hard link是有限制的：不能跨文件系统；不能连接到目录；

symbolic link（符号连接，也即是快捷方式）：由快捷方式inode读取到的连接文件的内容仅有文件名，
                                           根据文件名连接到正确的目录（原文件的目录）去取得
					   目标的inode，最终就能够得到正确的数据了。
符号连接的文件读取示意图:
快捷方式->连接文件的block->inode 文件->目录的block->inode real->文件实际内容（block）

ln [-sf] 源文件 目标文件
-s：如果不加任何参数就是hard link，至于-s就是symbolic link
-f：如果目标文件存在时，就主动将目标文件直接删除后再创建

关于目录的连接数量：新建一个新的目录，新的目录连接数量为2，上层目录的连接上则增加1.

磁盘分区：   包含安装分区，删除分区等命令
fdisk [-l] 设备名称
-l：输出后面接的设备所有分区内容    
-n:新增一个分区  /  -t:修改系统ID
注意：逻辑分区是会随着拓展分区消失而消失的。显示的分区是按照主分区，拓展分区，逻辑分区排序。
分区是由n1到n2的柱面号码，但柱面的大小每块磁盘都不相同。
拓展分区最好能够包含所有为分区的区间。

partprobe命令更新分区表信息,将内核的partition table 更新。

磁盘格式化：
mkfs [-t 文件系统格式] 设备文件名
-t：可以接文件系统格式，例如ext3，ext2,vfat等（系统有支持才会生效）
mkfs -t vfat /dev/sda1 将sda1格式化为windows可读的vfat格式

mke2fs [-b block大小] [-i block大小] [-L:卷标] [-cj] 设备               / 卷标（label）
-b：可以设置每个block的大小，目前支持1024,2048,4096 bytes
-i：多少容量给予一个inode呢？ / -c:检查磁盘错误 
-j：本来mke2fs是EXT2，加上-j后，会主动加入journal成为EXT3

fsck [-t 文件系统] [-ACayf] 设备名称
-a/-y：自动修复有问题的扇区，有些系统仅支持-y
-C：可以在检验的过程当中使用一个直方图来显示当前的进度
-f：强制检查，细化检查 / 被检查的分区务必不可挂载到系统上面！即是需要在卸载的状态！

badblock -[svw] 设备名称
-s：在屏幕列出进度 / -w；使用写入的方式来测试

磁盘挂载与卸载：
在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。我们要访问存储
设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。

挂载的目录，而这个目录是进入磁盘分区（其实是文件系统）的入口。
作为挂载点的目录理论上应该都是空目录才是。

mount -a / mount [-l]                      ―― 默认只有root可以执行
mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点
-a：依照配置文件 /etc/fstab的数据将所有未挂载的磁盘都挂载上来
-l：增列Label名称
-n：使得实际挂载情况不实时写入/etc/mtab中
-L：系统除了利用设备文件名（/dev/hdc6）外，还可以利用文件系统的标卷名称（Label）来挂载
-o：后面接一些挂载时额外加上的参数，比如账号，密码，读写权限等：
    ro，rw：成为只读（ro），可读写（rw） / user，nouser：是否允许吃分区让任何用户执行mount

强调下,修改完/etc/fstab后,务必要测试一下,若有错误发生要赶紧处理。因为这个文件如果修改错误,是会造成
无法开机完全的情况。最好使用vim修改,因为会有语法的检验,就不会让你写错字了。

/etc/filesystems：系统指定的测试挂载文件系统类型
/proc/filesystems：linux系统已经加载的文件系统类型
linux支持的文件系统之驱动程序都卸载如下目录中：/lib/modules/$（uname-r）/kernel/fs/..

在系统里面新增一块硬盘时，应该：
1.对磁盘进行分区，建立可用的分区
2.对该分区进行格式化，以创建系统可用的文件系统
3.创建挂载点（也即使目录），并挂载。
因为每种操作系统所设置的文件属性/权限并不相同,为存放这些文件所需的数据,格式化以成为操作系统能
利用的文件系统格式

如果带有中文文件名的数据，那么在可以在挂载时指定一下挂载文件系统所使用的语言，在man mount找到
vfat文件格式当中可以使用iocharset来指定语系，而中文语系是cp950，所以也可以：
mount -t vfat iocharset=cp950 设备名 挂载点   vfat是windows可读的一种格式

根目录不能被卸载，如果挂载数据要改变或者根目录出现只读，最可能的处理方式就是重新启动，不过也可以
mount -o remount，rw，auto/

我们也可以利用mount来将某个目录挂载到另一个目录去，这并不是挂载文件系统，而是额外挂载某个目录的
方法，虽然下面的方法也可以使用sysboliclink来连接，不过在某些不支持符号链接的程序运行中。。。
mount --bind 目录 挂载点

umount [-fn] 设备文件名或挂载点 （将设备文件卸载）
-f：强制卸载，可以在类似网络文件系统（NFS）无法读取到的情况下 / -n：不更新 /etc/mtab情况下卸载
无法卸载，显示繁忙，可以cd/回到根目录，就能卸载了。

除了使用设备文件名，也可使用卷标名来进行挂载 mount -L "卷标名" 挂载点

磁盘参数修改：主设备代码（major）次设备代码（minor）

某些特定情况需要手动创建设备文件：
mknod 设备文件名 [bcp] [Major] [Minor] 
b：设置设备名称成为一个外部存储设备文件,例如硬盘等；
c：设置设备名称成为一个外部输入设备文件,例如鼠标、键盘等；
p：设置设备名称成为一个FIFO文件 
major：主设备代码 / minjor:次设备代码

卷标(Label):以Windows系统来说明,当打开资源管理器时,C/D等盘不是都有个名称吗？那就是Label(如果没有设置
            名称,就会显示"本机磁盘驱动器"的字样)
修改卷标： e2label 设备名称 新的label名称
tune2fs [-jlL] 设备名称 -j：将ext2的文件系统转换为ext3的文件系统
hdparm [-icdmXTt] 设备名称 ：测试性能

设置开机挂载：
开机挂载/etc/fatab及/etc/mtab
[磁盘设备文件名或Label][挂载点][磁盘分区的文件系统][文件系统参数][能否被dump备份命令作用][是否以fsck检测扇区]
1.根目录/是必须挂载的，而且一定要先于其他mount point被挂载进来
2.所有的挂载点必须为已新建的目录，可以任意指定，但一定要遵循必须的系统目录架构原理
3.所有挂载点在同一时间之内，只能挂载一次
4.如若需要卸载，你必须先将工作目录移到挂载点（及其子目录）之外

注意：利用设备名称（ex>/dev/hda1）来挂载分区时，是被固定死的，所以你的硬盘不可以随便插在任意的插
槽。不过，它还是有好处的。而使用Label name来挂载就应该随时注意你的Label name，可能因为你name的变
导致挂载出现问题，从而导致开机等系统出现问题。  ex>是example>的意思。
测试系统的"/dev/hdc2"卷标名称为/1，所以"LABEL=/1"也可以替代成为"/dev/hdc2"的意思。至于Label可以使
用dumpe2fs查询。

其实/etc/fstab(file system table)就是将我们利用mount命令进行挂载时，将所有的参数写入到这个文件
中就可以了。
cat /etc/fstab
第一列：磁盘设备文件名或该设备的Label / 第二列：挂载点！挂载点是什么？一定是目录
第三列：磁盘分区的文件系统 
第四列：文件系统参数 ：
defaults-同时具有rw，suid，exec，auto，Nouser，async等参数。基本上，默认情况使用defaults设置即可
async/sync：异步/同步。设置磁盘是否以异步方式运行，默认async（性能较佳）。
auto/noauto：自动/非自动。当下达mount -a时，此文件系统是否会被主动测试挂载，默认auto。
rw/ro：可读写/只读     exec/noexec：可执行/不可执行  user/nouser:允许/不允许用户挂载
suid/nosuid：具有/不具有suid权限    usrquota：启动文件设备支持磁盘配额模式
grpquota：启动文件系统对群组磁盘配额模式的支持
第五列：能否被dump备份命令作用  / 第六列：是否以fsck检查扇区

新建一个大文件当做分区进行挂载：
特殊设备loop挂载（镜像文件不用刻录就挂载使用）：mount -o loop   目录名 挂载点
创建大型文件:dd if=/dev/zero of=/home/loopdev bs=1M count=512
if=/dev/zero：if是input file，输入文件，那个/dev/zero是会一直输出0的设备
of=/home/loopdev ：of是output file，将一对零写入到后面接的文件
bs=1M：bs是每个block大小 / count=512 ：count则是总共几个bs的意思

内存交换空间（swap）的构建
swap的功能就是在应付物理内存不足的情况下所造成的内存扩展记录的功能。当内存不足时，为了让后续的
程序可以顺利运行，因此在内存中暂不使用的程序和数据就会被挪到swap中。由于swap是用硬盘来暂时存放
内存中的信息，所以用到swap时，你的主机硬盘灯就会闪烁不停

1.分区：使用fdisk在磁盘分一个分区给系统做swap/或者创建一个大文件（如同loop设备构建方法）
        由于linux默认会将分区的ID设置为Linux的文件系统，所以你还要设置一下system ID就是了。
        linux的ID是83，linux swap的ID是82，Extended的ID是5...
  ====> 添加新的分区后记得让内核更新分区表partprobe命令。       
2.格式化：利用新建swap格式的"mkswap 设备文件名"就能格式化该分区成为swap格式。
3.使用：最后将swap设备启动，方法为"swapon 设备文件名"
4.查看：最终通过free这个命令来查看一下内存的使用情况 	
5.若是使用loop构建方法：使用swapoff关掉swap file，
                        方法为swap off /目标目录/swap ，swap off 设备名
如果block刚好为1k，则boot sector和superblock各会占用一个block，所以boot sector是独立与superblock
外面的，block 0号是留给boot sector用的，superblock讲师block 1号。如果block大于1k(2k，4k)，我们
可以发现第一个（0号）block内含有boot sector和superblock，因此boot sector占有0~1023，superblock
占有1024~2047之间的空间，至于2048bytes以外的空间就真的保留了。

利用GUN的parted进行分区行为： parted [设备] [命令] [参数]
新增分区：mkpart [primary|logical|extended] [ext3|vfat] 开始 结束
分区表：print / 删除分区：rm [partition]

************************************第9章 文件与文件系统的压缩**********************************
*.z compress程序压缩的文件 / *.gz gzip程序压缩的文件 / *.bz2 bzip2程序压缩的文件 
*.tar tar程序打包的数据 / *.tar.gz 或 *.tar.bz2 tar程序打包的文件，其中经过gzip或bzip2的压缩

compress [-rcv] 文件或目录 ：压缩  /  uncompress 文件.Z ：解压缩
-r:连同目录下的子目录也同时压缩； -c:将压缩数据输出成为standard output(输出到屏幕)； -v:可以显示压缩后的文件信息及压缩过程中的一些文件名变化
在默认的情况下,被compress压缩的源文件会不见,而压缩文件会被创建起来,而且扩展名会是*.Z。

gzip [-cdtv#] 文件名 / bzip2 [-cdtv#] 文件名
-c：将压缩的数据输出到屏幕上，可通过数据重定向来处理。
-t：可以检验一个压缩文件的一致性，看文件有无错误。
-v：显示压缩比等信息 / -#：#代表压缩等级，-1最快，但压缩比最差，-9最慢，但压缩比等级最好默认是-6.
-d：解压缩
zcat 文件名.gz  / bzcat 文件名.bz2  ―― 命令用于读取纯文本被压缩后的压缩文件，不真正解压缩文件，
                                         就能显示压缩包中文件。

前面谈的命令大多仅能针对单一文件来进行压缩，虽然gzip与bzip2也能够针对目录来进行压缩，不过这两个
命令对目录的压缩是将目录所有文件分别进行压缩的操作。
tar [-j|-z] [cv] [-f 新建的文件名] filename <==打包与压缩
tar [-j|-z] [xv] [-f 新建的文件名] [-C 目录]  <==解压缩
tar [-j|-z] [tv] [-f 新建的文件名]          <==查看文件名
注意：-c，-t，-x不可同时出现在一串命令行中
-c：新建打包文件，可搭配-v来查看过程中被打包的文件
-t：查看打包文件的内容含有哪些文件名，重点在查看文件名
-j：通过bzip2的支持进行压缩/解压缩，此时文件名最好为.*tar.bz2
-z：通过gzip的支持进行压缩/解压缩，此时文件名最好为.*tar.gz
-x：解打包或解压缩的功能，可以搭配-C在特定目录解开。
-C 目录：这个参数用在解压缩时，若要在特定目录解压缩，可以使用这个参数
-P:保留备份数据的原来权限与属性，常用于备份（-c）重要的配置文件（一般不建议）
-p:保留绝对路径，即允许备份数据中含有根目录存在之意
--exclude=FILE：在压缩过程中，不要将FILE打包
--newer-mtime=时间：仅mtime（文件内容） / --newer=时间：包含mtime和ctime（权限和属性）

压缩： tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查询： tar -jtv -f filename.tar.bz2
解压缩 tar -jxv -f filename.tar.bz2 -C 欲解压缩到的目录    ――到特定目录解压
       tar -jxv -f 打包文件.tar.bz2 待解开文件名           ――仅解开压单一文件
在tar所记录的文件名就是解压后实际的文件名    
压缩 /目录/filename.tar.bz2会将filename.tar2.bz2保留到/目录，即储存在在/目录/压缩文件
解压缩 /目录/filename.tar.bz2只会将filename.tar2.bz2保留下来，即储存在/解压到的目录/文件
想象一下windows系统压缩到/目录/文件名，将/目录/压缩包解压到/新目录。

文件名去除了根目录:主要是为了安全,我们使用tar备份的数据可能会需要压缩回来,在tar所记录的文件名那就是我们
                   解压缩后的实际文件名。如果去掉了根目录,假设你将备份数据在/tmp中解开,那么解压缩的文件名
                   就会变成"/temp/etc/xxx"。但如果没有去掉根目录,解压缩的文件名就会是绝对路径,即压缩后的
                   数据一定会被放置到/etc/xxx去,如此一来,你原本在/etc/下面的数据就会被备份数据所覆盖。

仅解开单一文件的方法：先找到文件:tar -jtv -f /文件名 | grep '单一文件名'
                      解压缩:tar -jxv -f 打包文件.tar.bz2 待解开文件名
打包某文件,但不包含该目录下的某些文件的做法: --exclude=FILE：在压缩过程中，不要将FILE打包
仅备份比某个时刻还要新的文件:--newer-mtime=时间：仅mtime（文件内容） / --newer=时间：包含mtime和ctime（权限和属性）

如果仅打包而已的文件后缀为.tar，如果打包并压缩的后缀名为.tar.bz2

完整备份工具：dump 
这个命令除了能够针对整个文件系统备份之外,也能够进针对目录进行备份,而可以制定等级。
dump [-Suvj] [-level] [-f 备份文件] 待备份文件 / dump -W
-S：仅列出后面待备份数据需要多少磁盘空间 / -u：将这次dump的时间记录到/etc/dumpdates文件中
-W：列出在/etc/fstab里面的具有dump设置的分区是否有备份过

单一文件系统时，那么该文件系统可以使用完整dump功能，包括利用0~9的整个level来备份。
一开始是使用level为0的完整备份，再次备份设置level为1，此时备份的数据就只会记录与第一次备份所差异的
文件而已。

并非单一文件系统且仅能使用level0: dump -0j -f 文件名 目录

待备份的数据只是目录,并非单一文件系统:
例如你想备份/home/someone/，但该目录并非独立的文件系统,此时备份就有限制,包括：
1.所有备份数据都必须要在该目录下面(/home/someone/)；
2.且仅能使用level0,即仅支持完整备份而已；
3.不支持-u参数,即无法创建/etc/dumpdates这个level备份的时间记录文件；


例:使用dump将/home完整的备份到/backupdata上 
    完整备份:dump -0u -f /backupdata/home.dump /home
    第一次进行增量备份:dump -1u -f /backupdata/home.dump.1 /home

用dump备份完整的文件系统 ；用dump备份非文件系统，即单一目录的方法 ； 

用restore恢复dump的备份文件:
restore -t [-f dumpfile] [-h]                           <==用来查看dump文件
restore -C [-f dumpfile] [-D 挂载点]                    <==比较dump与实际文件
restore -i [-f dumpfile]                                <==进入互动模式
restore -r [-f dumpfile]                                <==还原整个文件系统

备份还原：先将备份的目录卸载umount 目录，并重新格式化mkfs -t ext 3 设备，然后重新挂载mount -a，
          可以自行使用df以及ll查阅该目录下的内容，cd切换到目录，将完整备份的level 0的文件还原
          restore -r -f 备份文件 ，将后续的level 1,2..的备份也还原回来cd 目录2，restore -r -f 备份文件2

由于dump是记录整个文件系统的，因此还原时你应该要给予一个全新的文件系统才行。
restore互动模式可以还原部分文件
 
光盘写入工具： -->刻录
1.现将所需要的备份数据构建成一个镜像文件（iso），利用mkisofs命令来处理
2.将该镜像文件刻录至光盘或DVD中，利用cdrecord命令来处理

新建光盘刻录数据：
mkisofs [-rv] [-o 镜像文件] [-m file] 带备份文件..[-V vol] -graft-point isodir=systemdir...
-r:通过Rocky Ridge 产生支持UNIX/Linux的文件数据，可记录较多的信息
-v：显示构建ISO文件的过程 / -m file :-m为排除文件的意思（exclude），后面的文件不备份到镜像文件中
-V vol：新建volume。 / -graft-point :graft有转嫁或移植的意思
所有要被加到镜像文件中的文件都会被放置到镜像文件中的根目录，当你利用-graft-point 这个参数后，
可以利用如下方法来定义镜像文件中的目录：
1.镜像文件中的目录所在=实际linux文件系统的目录所在
2./movies/=/srv/movies/（在linux的/src/movies 内的文件，加至镜像文件中的/movies/目录）
3./linux/etc=/etc（将linux的/etc/内的所有数据备份到镜像文件中的/linux/etc/目录中）

使用cdrecord来写入CD或DVD刻录机
cdrecord：光盘刻录工具
cdrecord -scanbuSdev=ATA                                 <==查询刻录机位置
cdrecord -v dev=ATA：x，y，z blank=[fast|all]            <==抹除重复读写片
cdrecord -v dev=ATA：x，y，z -format                     <==格式化DVD+RW
cdrecord -v dev=ATA：x，y，z [可用参数功能] file.iso

常见的压缩与备份工具
dd可以读取磁盘设备的内容（几乎是直接读取扇区），然后将整个设备备份成一个文件
dd可备份完整的分区或磁盘，因为dd可读取磁盘的扇区表面数据
dd if="input file" of="output file" bs="block size" count="number"
dd if=/dev/zero of=123 bs=1M count=20  创建20M的文件
if ：就是input file，也可以是设备 / of ：就是output file，也可以是设备
bs ：规划的一个block的大小，若未指定则默认是512bytes（一个扇区的大小）
count：多少个bs的意思

你可以说，tar是备份关键数据，而dd则可以用来备份整块分区或整块硬盘（新分区出来的分区不需要格式化）。

cpio可以备份任何东西，包括设备设备文件，不过有个问题就是cpio不会主动去找文件来备份，得配合find等
可以找到文件名的命令来高中cpio该备份的数据在哪里
cpio -ovcB  > [file|device]             <==备份
cpio -ivcdu < [file|device]             <==还原
cpio -ivct  < [file|device]             <==查看

例: find / -print | cpio -ovcB > /dev/st0 备份到磁带机
    cpio -idvc < /dev/st0 还原到磁带机

因为cpio会将数据整个显示到屏幕上，因此我们可以通过将这些屏幕的数据重新导向（>）一个新的文件，
至于还原呢，就是将备份文件读竟来cpio（<）进行处理之意


*****************************************第十章 vim编辑器*********************************************
vi的使用
一般模式、编辑模式（i,l,o,O,a,A,r,R）、命令行模式(q,wq..)
一般模式：ctrl+r：重做上一步   u：复原上一步   $移动到最后    .重复前一个操作
          H:移动到第一个字符  G:移动到最后一个字符 nG：移动到这个文件的n行
          nx/X :连续向后/前删除n个字符  /word :向下寻找一个名称为word的字符串 ？word :向上寻找
          gg :移动到这个文件的第一行 ndd ：删除光标所在向下n行
          n1,n2s/word1/word2/g（c）:在n1,n2行之间寻找word1这个字符，将之替换为word2，加上c代表
                                    替换会一个一个询问。
          nyy：n为数字，复制光标所在的向下的n行 p/P:将已复制的数据在光标下/上一行粘贴
编辑模式：i从目标光标所在处插入，a从目前光标所在的下一个字符处开始插入 
          o在目前光标所在的下一行处插入新的一行，r只会替换光标所在的那一个字符一次
命令行模式：:w!若文件属性为只读，强制写入该文件。不过到底能不能写入，与你对该文件的文件权限有关
            ZZ若文件没有更改，则不保存离开，若文件已经被更改，则保存后离开
	    :w[filename]将编辑的数据保存成另一个文件（类似于另存文件）
            :r[filena		开vi命令到命令行模式执行ls的显示结果
	    :set nu显示行号	 / :set nonu取消行号  

vim 块选择（Visual block）：按下v，V，ctrl+v，这时光标经过的地方就会反白。
v:字符选择，会将光标经过的地方反白选择 V:行选择，会将光标经过的行反白选择
[ctrl]+v:块选择，可以用长方形的方式选择数据
y:将反白的地方复制起来 / d:将反白的地方删除 / p:粘贴

多文件编辑
:n 编辑下一个文件 :N 编辑上一个文件 :files列出目前这个vim的打开的所有文件
vim 文件1 文件2 一个vim打开2个文件 
使用":file"查看下编辑的文件数据有什么，在vim的环境下输入"n"会来到第二个编辑的文件

多窗口编辑
在命令行模式输入":sp{filename}"即可。那个filename可有可无，如果想在窗口启动另一个文件，就加入
文件名，否则仅输入:sp时，出现的则是同一个文件在两个窗口间。
两个文件同时在同一个屏幕上面显示，你可以利用[ctrl]+w+↑↓在两个窗口之间移动：按键的按法是先按下
ctrl不放，再按下w后放开所有的按键，然后在按下j/k（↓/↑），则光标可移到下方的窗口。

vim环境设置与记录:~/.vimrc,~/.viminfo
vim的环境设置参数有很多，如果你想知道目前的设置值，可以在一般模式时输入":set all"来查阅
整个vim的设置值放置在/etc/vimrc这个文件中，不过不建议你修改它，你可以修改~/.vimrc这个文件（默认
不存在，请你手动创建），将你希望的设置值写入

中文编码的问题:LANG=zh_CN.big5

DOS与linux的断行字符
我们可以利用cat -A来查看以DOS（windows系统）建立的文件的特殊格式，也可以发现在DOS中使用的断行字符
为^M$，我们称为CR与LF两个符号。而在linux下面，则是仅有LF（$）这个断行符号。
dos2NUIX [-kn] file [newfile] 修改dos断行  与  NUIX2dos [-kn] file [newfile] 修改为linux断行字符

语系编码装换
inconv --list 与 inconv -f 原本编码 -t 新编码 filename [-o newfile]
--list:列出inconv支持的语系数据

**********************************第十一章 认识与学习bash****************************************
1.管理整个计算机硬件的其实是操作系统的内核（kernel），这个内核是需要进行保护的，所以我们一般用户就
只能通过shell来跟内核通信，以让内核可以控制硬件来达到我们所想要达到的工作。
2.其实shell的功能只是提供用户操作系统的一个接口，因此这个shell需要调用其他用户软件才好，包括man，
chmod，vi等命令都是独立的应用程序，但是我们可以通过shell（就是命令行模式）来操作这些命令系统，让
这些应用程序调用内核来运行软件所需的工作。
3.也就是说。只要能够操作应用程序的接口都能称为shell，狭义的shell指的是命令行方面的软件，包括本章要
介绍的bash等。广义的shell包括图形界面的软件，因为图形界面其实也能够操作各种应用程序来调用内核工作

用户->用户界面（shell,KDE,application)->硬件(Hardware)

系统的合法shell与/etc/shell功能：
linux使用的这一版本shell为"Bourne Again SHell（简称bash）"
系统上合法的shell要写入/etc/shells这个文件，因为系统某些服务在运行过程中，回去检查用户能够使用的
shells，而这些shells就是借助/etc/shells这个文件
我这个用户什么时候可以取得shell来工作呢?还有我这个用户默认会取得哪一个shell？当我登陆的时候系统会
给我一个shell来让我工作,而这个登陆取得的shell就记录在/etc/passwd这个文件夹内。

bash shell的功能：
命令记忆功能：只要在命令行按上下键就可以找到前/后一个输入的命令。~/.bash_history
命令与文件补全功能：[Tab]按键的好处
命令别名设置功能:使用alias->你在命令行输入alias就知道目前的命令行别名有哪些了，也可以直接执行命令
 		 来设置别名 alias 别名='原来的命令'
作业控制，前台，后台控制
程序脚本（shell script） / 通配符（wildcard） 

bash shell的内置命令：type 判断每个命令是否为bash的内置命令
type [-tpa] name : -a 会由PATH变量定义的路径中，将所有含name的命令都列出来，包含alias
   
shell的变量功能
环境变量：由于系统需要一些变量来提供它数据的访问或者一些环节的设置参数值（例如是否要显示颜色），
          所以就有了一些所谓的环境变量来读入系统中了。为了区别与自定义变量的不同，环境变量通常
	  以大写字符来表示(PATH,HOME,MAIL,SHELL等)

变量的显示与设置：echo，unset 《=========================================
echo $variable / echo $PATH
利用echo显示变量，但是在变量被显示时，前面必须加上字符$才行。
设置规则：1.变量与变量内容以一个等号"="来连接  2.等号两边不能直接接空格符
          3.变量只能是英文与数字，但是开头字符不能为数字 
          4.变量内容若有空格符，可使用双引号"或者单引号'将变量内容结合起来 
            双引号内的特殊字符入$等，可以保有原本的特性。 例:若var="lang is $LANG"则
            echo $var可得lang is en_US
	    单引号内的特殊字符则仅为一般字符（纯文本）。例:若var=‘lang is $LANG’则
            echo $var可得lang is $LANG
          5.可用转义字符"\"将特殊符号（如[Enter]、$、\、空格、！等）变成一般字符
          6.在一串命令中，还需要通过其他的命令提供的信息，可以使反单引号`命令`或"$(命令)"，特别
            注意的，那个是键盘1左边的那个按键，而不是单引号
             cd /lib/modules/`uname -r`/kernel 在一串命令中`之内的命令将会被先执行
          7.若该变量为了增加变量内容时，则可用"$变量名称"或者$(变量)累加内容 
             变量=$变量累加内容 、 变量="$变量"累加内容 或 变量=${变量}累加内容
  	  8.若该变量需要在其他子程序执行，则需要以export来使变量变成环境变量：export PATH
	  9.通常大写字符为系统默认变量，自行设置变量可以使用小写字符。
	  10.取消变量的方法为unset 变量名称

在变量的设置中,单引号与双引号的用途有何不同？
双引号仍然可以保有变量的内容,但单引号内仅是一般字符,而不会有特殊字符。
例：name=vbird name="$name is me" 表示 name=vbird is me
               name='$name is me' 表示 name=$name is me

在命令执行的过程中,反单引号(`)这个符号代表的意义为何？
在一串命令中,在`之内的命令将会被先执行,而将其执行出来的结果将作为外部的输入信息。

环境变量的功能
1.用env查看环境变量与常见环境变量说明
PATH：就是执行文件查找的路径，目录与目录中间以冒号分隔，由于文件的查找是依序由PATH的变量内的目录
      来查询，所以目录的顺序也是重要的。例如你执行ls这个命令时,系统就是用过PATH这个变量里面的内容
      所记录的路径顺序来查找命令的呢。
RANDOM：这是"随机数"的变量，我们可以通过这个随机数文件相关的变量（$RANDOM）来随机取得随机数值

2.用set查看所有变量（含环境变量与自定义变量）
PS1（提示符prompt的设置）：命令提示符 PS1='[\u \h \@ \参数]\$ ' 
例：[root@www home]# PS1='[\u@ \h \w \A #\#]\$ ' 将输出[root@www /home 17:02 #85]#
$关于本shell的PID，想知道我们的shell的PID，用echo $$即可，出现的数字就是你的PID号码
？关于上个执行命令的回传码echo $? 一般来说，如果成功执行了该命令，则会回传一个0，出现错误，回传
  一个执行后的代码
export：自定义变量转成环境变量。后面没有接变量时，会把所有的环境变量显示出来。
export 变量名称                      自变量和环境变量的差异在于该变量是否会被子进程所继续引用。

在你登录linux并取得一个bash之后，你的bash就是一个独立的进程，被称为PID的就是。接下来，你在这个
bash下面执行的任何命令都是由这个bash所衍生出来的，那些被执行的命令就被称为子进程了。
子进程仅会继承父进程的环境变量，不会继承父进程的自定义变量，直到回到原本的父进程。
因此，将自定义变量变成环境变量就可以使该变量继续存在于子程序了。
locale：影响显示结果的语系变量  整体系统默认的语序定义在/etc/sysconfig/i 18n

为什么环境变量（全局变量）可以被子程序引用呢？这是因为内存配置的关系，理论上是这样的：
1.当启动一个shell，操作系统会分配一记忆块给shell使用，此内存内的变量可让子进程取用；
2.若当父进程利用export功能，可以让自定义的内容写到上述的记忆块当中（环境变量）
3.当加载另一个shell时（即启动子进程，而离开原本的父进程），子shell可以将父shell的环境变量所在的
  记忆块导入自己的环境变量块当中。

影响显示结果的语系变量(locale)：整体系统默认的语系定义/etc/sysconfig/il8n
变量的有效范围:基本上你可以这样区别: 环境变量=全局变量 ； 自定义变量=局部变量

变量键盘读取、数组与声明：read，array，declare
read [-pt] variable  让用户由键盘输入内容，将该内容变成名为variable的变量
-p 后面可以接"提示符" ，-t 后面可以接等待的时间
declare/typeset  声明变量的类型 declare [-aixr] variable
-a：将后面名为variable 的变量定义成为数组类型（array）的类型
-i：将后面名为variable 的变量定义成为整数数字（integer）的类型
-x：用法和export一样，就是将后面的variable变成环境变量，设置为+x可以取消的操作
-r：将变量设置成为reaonly类型，该变量不可被更改内容，也不能重设
数组（array）变量类型
var[index]=content ， 目前我们bash提供的是一维数组 读取直接以${数组}来读取

与文件系统及程序的限制关系：ulimit
我们的bash是可以限制用户的某些系统资源的,包括打开的文件数量,可以使用的CPU时间,可以使用的内存总量等。
ulimit [-SHacdfltu] [配额]
-c：当某些进程发生错误时，系统可能会将该进程在内存中的信息写成文件（排错用），这种文件就被称为内
    核文件（core file）。此为限制每个内核文件的最大容量。
-f：此shell可以创建的最大文件容量（一般可能设置为2GB）单位为KB。
-d：进程可使用的最大断裂内存（segment）容量
-u：单一用户可以使用的最大进程（process）数量
想要复原ulimit设置最简单的方法就是注销再登录，否则就是得要重新以ulimit设置才行。不过要注意的是一般
身份用户如果以ulimit设置了-f的文件大小，那么他只能继续减小文件容量，不能增加文件容量。

变量内容的删除、替代与替换
path=${PATH}
#：符合替换文字最短的那一个。代表从前面开始向右删除,仅删除最短的那个。
##：符合替换文字最长的那一个。代表从前面开始向右删除,仅删除最长的那个。   
最短的一般就是第一个变量，最长的一般都是从第一个到最后不删除的那个
%：从后面向前删除变量内容，删除"最短的"
%% 从后面向前删除变量内容，删除"最长的"

例：删除：echo ${variable#/*kerberos/bin:}
variable这个是原本的变量名称 
#这个是重点，代表从变量内容的最前面开始删除，仅删除最短的那个。##则删除最长的那个数据。
/*kerberos/bin:代表被删除的部分，由于#代表从前面开始删除，所以这里便由开始的/写起
指的注意的是我们还可以通过通配符*来替代0到无穷多个字符 删除结果为/user/kerberos/bin:被删除

例：替换：将path的变量sbin替换成大写SBIN，echo ${path/sbin/SBIN}

new_var=${old_var-content}
${变量#关键字}                       若变量内容从头开始的数据符合关键字，则将符合的最短数据删除
${变量##关键字}			     若变量内容从头开始的数据符合关键字，则将符合的最长数据删除
${变量%关键字}			     若变量内容从尾到头的数据符合关键字，则将符合的最短数据删除
${变量%%关键字}                      若变量内容从尾到头的数据符合关键字，则将符合的最长数据删除
${变量/旧字符串/新字符串}            若变量内容符合旧字符串，则第一个旧字符串会被新字符串替换
${变量//旧字符串/新字符串}           若变量内容符合旧字符串，则全部的旧字符串会被新字符串替换

变量设置方法	    str没有设置	          str为空字符串	        str以设置非空字符串	
var=${str-expr}     var=expr              var=                  var=$str
var=${str:-expr}    var=expr              var=expr              var=expr
var=${str+expr}     var=                  var=expr              var=expr
var=${str:+expr}    var=                  var=                  str不变
var=${str=expr}     str=expr              str不变               str不变
                    var=expr              var=                  var=$str
var=${str:=expr}    str=expr              str=expr              str不变
		    var=expr              var=expr              var=$str
var=${str?xpr}      expr输出至stderr      var=                  var=str
var=${str:?expr}    expr输出至stderr      expr输出至stderr      var=str
一般来说，str:代表str没设置或为空的字符串时，至于str则仅表示没有该变量。

命令别名（alisa）是新创一个新的命令，你可以直接执行该命令的，至于变量则需要使用类似"echo"命令才能
够调用变量的内容。取消别名unalias。

历史命令：history
history [n] / history [-c] / history [-raw] histfiles
n:数字，是要列出最近的n条命令行的意思  / -C:将目前的shell中所有history内容全部消除
-a:将目前新增的history命令新增入histfiles中，若没有加histfiles，则默认写入~/.bash_history
-r:将histfiles的内容读到目前这个shell的history记忆中。
-w：将目前的history记忆内容写入histfiles中。

输入history命令得到结果后，可以!+数字执行第n条命令，!+部分命令执行以部分命来开头的命令

Bash Shell的操作环境
命令运行的顺序:1.以相对/绝对路径执行命令 		2.以alias找到该命令来执行
	       3.通过bash内置的（builtin）命令来执行    
               4.通过$PATH这个变量的顺序找到第一个命令来执行   
如果想要了解命令查找的顺序，可以通过type -a 命令查询得到。
                                                                    
bash的登录与欢迎信息:/etc/issue,/etc/motd   <==修改自己喜欢的登录提示，登录后显示欢迎讯息
当使用telnet远程登录程序连接到主机时，主机的登录界面就会显示/etc/issue.net 而不是/etc/issue
如果你想让用户登录后取得一些信息，可以将信息加入/etc/motd里面去。

要注意的是，我们之前谈到的命令别名、自定义的变量在你注销bash后就会失效，所以你想要保留你的设置，
就要将这些配置写入配置文件才行。

bash的环境配置文件：全体系统的配置文件以及用户个人偏好配置文件
(登录)login shell:取得bash时需要完整的登录流程，就称为login shell。举例来说你要由tty1~tty6登录，
		  需要输入账号和密码，此时取得的bash就称为login shell。
non-login shell:取得bash的接口的方法不需要重复登录的举动。举例来说,你以X Window登录Linux后,再以X的
                图形界面启动终端机,此时那个终端接口并没有需要再次输入账号与密码,那个bash的环境就称
                为non-login shell。你在原本的bash环境下再次执行bash这个命令,同样也没有输入账号密码
                那第二个bash(子进程)也是non-login shell。

一般来说，login shell其实只会读取这两个配置文件：
1./etc/profile:这是系统整体的设置，这个配置文件可以利用用户的标识符（UID）来决定很多重要的变量数据，
             这也是每个用户登录取得bash时一定会读取的配置文件，所以如果你想要帮所有用户设置整体环境，
             那就是在这里修改，但是，没事你最好不要修改这个文件。
PATH：会依据UID决定PATH变量要不要含有sbin的系统命令目录
MAIL：依据账号设置好的用户的mailbox到/var/spool/mail账户名
2.~/.bash_profile或~/.bash_login或~/.profile:属于用户个人设置，你要改自己的设置，就写入这里。

3./etc/inputrc：其实这个文件斌没有执行。其会主动判断用户有没有自定义输入的按键功能,如果没有的话,/etc/profile
                就会决定设置"INPUTRC=/etc/inputrc"这个变量。此文件内容为bash的热键,[tab]有没有声音等数据。
4./etc/profile/*.sh：只要在这个目录内且扩展名为.sh,另外用户由r的权限,那么该文件就会被/etc/profile.d/
                     这个目录调用。在CentOS 5.x内,这个目录下面文件规定了bash接口的颜色、语系、ll与ls命令
                     别名等。如果你需要帮所有用户设置一些共享的命令别名时,可以在这个目录下创建.sh的文件。
5./etc/sysconfig/i18n：这个文件由/etc/profile.d/lang.sh调用。这就是我们决定bash默认使用何种语系的重要配置
                       文件。

Source:读入环境配置文件的命令
由于/etc/profile与~/.bash_profile都是在取得login shell的时候才会读取的配置文件，所以如果你将自己的
偏好设置写入上诉的文件后，通常都是得注销再登录后该设置才会生效。那么能不能直接读取配置文件而不注销
登录呢，通常要利用source这个命令。
source（或小数点）:读入环境配置文件的命令   
source 配置文件名或 . 配置文件名

（non-login shell会读）~/.bashrc
1.调用/etc/bashrc文件,/etc/bashrc帮我们的bash定义出下面的数据
a.依据不同的UID规定umask的值；    b.依据不同的UID规定提示符（就是PS1变量）
c.调用/etc/profile.d/*.sh的设置：万一你没有~/.bashrc，你会发现你的bash提示符可能变成-bash-3.25
                                 不要太担心，因为你并没有调用/etc/bashrc来规定PS1变量，而且这样
				 的情况也不会影响你的bash使用。如果你想将命令提示符调回来，那么
				 可以复制/etc/skel/.bashrc到你的主文件夹，在修改你想要的内容，并
				 使用source去调用~/.bashrc,那么你的命令提示符就会回来了。
其他相关配置文件
/etc/man.config :这文件的内容规定了使用man的时候man page 的路径去哪里寻找。如果你是以tarball的方式
                 来安装你的数据，那么你的man page可能会放置在/user/local/softpackage/man里头，那个
                 softpackage是你的套件名称，这个时候你就得手动将该路径加到/etc/man.config，否则使用
		 man的时候就会找不到相关的说明文件。
~/.bash_history:默认情况下，我们的默认历史命令就记录在这里。而这个文件能够记录几条数据则与HISTSIZE
		这个变量有关。每次登陆bash后，bash会先读取这个文件，将所有的历史命令读入内存，因此
		当我们登陆bash后既可以查看上次使用过的哪些命令。
~/.bash_logout:这个文件记录了当我注销bash后系统在帮我做完什么操作后才离开。

终端机的环境设置:stty,set
1.查询目前的按键内容：stty（setting tty终端机的意思），stty也可以帮助设置终端机的输入按键代表意义。
stty [-a] ：列出所有的按键与按键内容。其中几个重要的意义
eof：end of file的意思，代表结束输入； erase：向后删除字符； kill：删除目前命令行上所有的文字；
intr：送出一个interrupt的信号给目前运行的程序  stop：停止目前屏幕的输出；
例：如果你想用ctrl+h来进行字符的删除 stty erase ^h
2.设置整个命令输入/输出的环境，例如记录历史命令，显示错误内容等
set [-uvCHhmBx]
3.组合按键 Ctrl+C终止目前的命令 Ctrl+D输入结束（EOF） Ctrl+M就是Enter Ctrl+S/Q暂停，恢复屏幕的输出

通配符（wildcard）
*代表0到无穷多个任意字符  ？代表一定有一个任意字符 []一定有一个在中括号内的字符（非任意字符）
[-]编码顺序内的所有字符   [^]反向选择
例子：找出/etc/下面文件名含有数字的文件名 ll -d /etc/*[0-9]*
      找出/etc/下面文件名开头非为小写字母的文件名 ll -d /etc/[^a-z]*

特殊字符
#批注符号 \转义符号 |管道 ;连续命令分隔符 ~用户的主文件夹 &作业控制，将命令变成背景下工作
！逻辑运算意义上的"非"的意思  /目录符号,路径分隔的符号 $使用变量前导符
 >,>>数据重定向,输出导向,分别是替换与累加  ''单引号，不具有变量置换的功能  
""双引号，具有变量置换功能  ``反引号，中间为可执行的命令，也可使用$() 

数据流重定向：就是将某个命令执行后应该要出现在屏幕上的数据传输到其他的地方
1.标准输入（stdin）:代码为0，使用<或<<    <就是将原本键盘输入的数据由文件内容替代，<<结束输入
2.标准输出（stdout）:代码为1，使用>或>>   单>将会覆盖原先数据，>>才是累加数据
3.标准错误输出（stderr）:代码为2，使用2>或2>>  命令执行失败后,所回传的错误信息

想要将正确的与错误的数据分别存入到不同的文件中 命令 文件 >list_right 2>list_error（2>会只留下错误）
将正确与错误数据通通写入一个文件: 2>&1或&> 。例:find /home -name .bashrc > list 2> list 。

垃圾桶黑洞设备与特殊写法: 命令 目录 >/dev/null


例：我要用cat直接将输入的信号输出到catfile中，当由键盘输入eof时，这次输入就结束
[root@www~]cat>catfile<<"eof"
>this is a test
>ok now stop
>eof          <==输入eod关键字，立即结束而不需要输入ctrl+d

重定向使用的情况：1.屏幕输出的信息横重要，而且我们需要将它存下来的时候
		  2.后台执行中的程序，不希望它干扰屏幕正常的输出结果时
		  3.一些系统的例行命令的执行结果，希望他可以存下来
		  4.一些执行命令的可能已知错误信息时，想要以2>/dev/null将它丢掉
                  5.错误与正确信息需要分别输出时

命令执行的判断依据: ；&& ||
cmd;cmd(不考虑命令相关性的连续命令执行,两个命令之间没有相关性)
$?(命令回传码)与&&或|| (命令之间具有相依性，这个相依性主要判断的地方就是前一个命令执行的结果是否正确）
命令回传符：若前一个命令执行的结果正确，在linux下面会回传一个$?=0的值。
cmd1&&cmd2：若cmd1执行完毕且正确执行（$？=0），则开始执行cmd2。反之，不执行cmd2.
cmd1||cmd2：若cmd1执行完毕且正确执行（$？=0），则不执行cmd2。反之，开始执行cmd2.
一般来说假设判断式有三个，也就是command1&&command2||command3

管道命令（pipe）
管道命令"|"仅能处理经由前面一个命令传来的正确信息（也就是standard output,对于standard error没有直接
处理的能力）而且这个命令必须要能够接受standard input的数据才行。例如less,more,head,tail等都是可以接
收standard input的管道命令,至于例如ls,cp,mv等就不是管道命令，因为ls,cp,mv并不会接收来自stdin的数据。

选取命令:cut,grep
1.cut -d'分隔字符' -f fields <==用于分隔字符          cut -c 字符范围 <==用于排列整齐的信息
-f:依据-d的分隔字符将一段信息切割成数段，用-f取出第几段的意思
cut是在一行信息当中取出某部分我们想要的，而grep则是分析一行信息，若有我们想要的信息，就将该行拿出来
2.grep [-acinv] [--color==auto] '查找字符串' filename 
-n:顺便输出行号 -v:反向选择 -i:忽略大小写不同

排序命令:sort,wc,uniq
1.sort [-fbMnrtuk] [file or stdin]
-f:忽略大小写的差异，例如A与a视为编码相同 / -b:忽略前面的空格符号 / -r:单向排序 
-t:分隔符，默认是用[tab]键来分隔 / -k:以那个区间来进行排序 / -M,n:以月份,纯数字进行排序
例：/etc/passwd内容是以:来分隔的，我想以第三列来排序，该如何？
    cat /etc/passwd | sort -t ':' -k 3
2.uniq [-ic]  排序完成后想要将重复的数据仅列出一个显示
-i:忽略大小写字符的不同 / -c:进行计数
3.wc [-lwm]   计算输出信息的和整体信息
-l:仅列出行 / -w:仅列出多少字（英文单字） / -m:多少字符

4.双向重定向:tee  会同时将数据流送与文件与屏幕，而输出到屏幕的,其实就是stdout,可以让下个命令继续处理
tee [-a] file    -a:以累加的方式,将数据加入file当中。
tee可以让standard output转存一份到文件内并将同样的数据继续到屏幕去处理，这样除了可以让我们同时分析
一份数据并记录下来之外，还可以作为一份数据的中间暂存盘记录使用。

字符转换命令:tr,col,join,paste,expand
1.tr:可以用来删除一段信息当中的文字，或者进行文字信息的替换。
tr [-ds] SET1 ...   -d: 删除信息当中的SET1这个字符串  -s:替换掉重复的字符

2.col [-xb]  -x:将tab键转换成对等的空格键 -b:在文字内有反斜杠（/）时，仅保留反斜杠最后接的那个字符
[tab]键显示就是^I的符号。此外,col经常被用于将man page 转存为纯文本文件以方便查阅功能。

3.join:处理两个文件之间的数据，主要是要将两个文件当中有相同的数据的那一行加在一起。
join [-ti12] file1 file2
-i:忽略大小写字符的不同 / -t:如果两条文件相同，则将两条数据连成一行，且第一个字符放在第一个、
-1:代表第一个文件要用哪个字段来分析的意思 / -2:代表第二个文件要用哪个字段来分析的意思
例:我们知道/etc/passwd的第四个字段是GID,那个GID记录在/etc/group当中第三个字段，将二者整合
join -t ':' -1 4 /etc/passwd -2 3 /etc/group   
-1 4代表第一个文件要用第4个字段来分析   :字符2加上冒号连接在后面
此外，需要注意的是在使用join之前，你需要将处理的文件应该事先经过排序（sort）处理。

4.paste 直接将两行贴在一起，且中间以tab键隔开而已
paste [-d] file1 file2        -d:后面可以接分隔字符，默认tab分隔   
-:如果file部分写成-，表示来自standard input的数据（管道输入的数据）的意思

5.expand 就是将[tab]按键转化成空格键
expand [-t] 数字 file    数字代表几个字符来表示一个tab的长度

6.切割命令：split [-bl] file PREFIX  将一个大文件依据文件大小或行数切割成为小文件
-b：后面接切割文件的大小  -l:以行数进行切割  PREFIX:代表前导符，可作为切割文件的前导文字
  合并时使用数据流重定向即可:cat xxx* >> xxx

7.参数代换：xargs 产生某个命令参数的意思,xargs可以读入stdin的数据,并且以空格符或断行字符进行分辨,将
                stdin的数据分隔成为arguments（参数）。
xargs [-0epn] command  就是将前面得到的信息通过管道和xargs作为command命令的参数
使用xargs 的原因是很多命令其实并不支持管道命令，因此我们可以通过xargs来提供该命令引用standard input之用
find /sbin -perm +7000 | xargs ls -l 因为ll不是管道命令，只能查看root所在目录，加上xargs就能查看前面
				     find输出的参数

finger account 可以取得该账号(account)的相关说明内容。

关于减号-的用途
在管道命令当中，经常会用到前一个命令的stdout来作为此次的stdin，某些命令需要用到文件名来处理时，该
stdin与stdout可以利用减号-来代替

**********************************第12章 正则表达式与文件格式处理*********************************************
正则表达式（Regular Expression）基本上是一种"表示法"，只要工具程序支持这种表示法，那么该工具程序就可
以作为正则表达式的字符串处理使用。

正则表达式和通配符是完全不一样的东西，因为通配符（wtlcard）代表的是bash槽接口的一个功能，但正则表达式
则是一种字符串处理的表达式。
举例来说,在不支持正则表达式的ls这个工具中,若我们使用"ls -l"代表的是任意文件名的文件,而"ls -l a*"代表的
是以a为开头的任何文件名的文件,但在正则表达式中,我们要找到含有以a为开头的文件,则需要这要(需搭配支持正则表达式的工具)
ls | grep -n '^a.*'

使用grep或其他工具进行正则表达式的字符串比较时，因为编码的问题会有不同的状态，因此，你最好将LANG等
变量设置为C或者en等英文语系！

基础正则表达式:
语系对正则表达式的影响：下面的练习都是使用"Lang=C"这个语系数据。为了避免编码造成的英文与数字选区问题,我们
                        需要了解下一些特殊符号。
[:alnum:]代表英文大小写字符及数字
[:alpha:]代表任何英文大小写字符
[:upper:]代表大写字符
[:lower:]代表小写字符
[:digit:]代表数字而已

grep的高级参数: grep [-A] [-B] [--color=auto] '搜寻字符串' filename
-A:后面可加数字，为after的意思，除了列出该行外，后续的n列也列出来
-B:后面可加数字，为befer的意思，除了列出该行外，前面的n列也列出来

利用[]查找集合字符:
例1: 如果我想查找test或taste这两个单词时，可以发现到，其实它们有共同的‘t?st’存在，
这个时候我们就grep -n 't[ae]st' regular_express.txt
例2: 连续编码使用"-"号。查找非小写字母加上oo开头的文件:grep -n '[^a-z]oo' regular_express.txt
     同样可以使用grep -n '[^[:lower:]]oo' regular_express.txt

行首与行尾字符^$
例1:让the只在行首列出:grep -n '^the' regular_express.txt
例2:不想开头是英文字母:grep -n '^[^a-zA-Z]' regular_express.txt
例3:找出行尾结束为小数点.的那一行:grep -n '\.$' regular_express.txt ,因为小数点具有其他意义，需要
     转义字符（\)来加以删除其特殊意义。
例4:找出空白行:grep -n '^$' regular_express.txt ,因为只有行首和行尾（^$）,所以这样就能找到空白行。
注意到，^符号在字符集合符号（中括号[]）之内与之外是不同的！在[]内代表'反向选择',在[]外则代表定义在
行首的意义。widows的断行字符（^M$）,而linux正常断行字符仅有$。

任意一个字符.与重复字符*
正则表达式当中的"."则代表绝对有一个任意字符的意思,"*"代表重复前一个0到无穷多次的意思,为组合形态；
例:找出g??d的字符串  grep -n ‘g..d’ regular_express.txt
   找出至少两个o的字符串  grep -n ‘ooo*’regular_express.txt 
   第一二个o是必须要存在的o，第三个o则是可有可无的多个o,至少两个o就要写三个o*
零个或多个任意字符: .*,因为.代表任意字符，*代表0个或多个重复前面字符。   <====常用

限定连续RE字符范围{}
因为{与}符号在shell是有特殊意义的，因此我们必须要用\转义字符来让他失去意义。
例:g后面接2到5个o,然后再接一个g的字符 grep -n ‘go\{2,5\}g’regular_express.txt 
   找到8位数字 grep '[0-9]\{8\}'

再次强调:正则表达式的特殊字符与一般在命令行输入命令的"通配符"并不相同,例如,在通配符当中的*代表的是
零到无限多个字符的意思,但是在正则表达式当中,*则是重复0到无穷多个的前一个RE字符的意思。

sed工具:sed本身也是一个管道命令,可以分析standard input的，而且sed还可以将数据进行替换、删除、新增、
        选定特定行的功能。
sed [-nefr] [动作]     -e:直接在命令行模式上进行sed的动作操作
-n:使用安静模式,在一般sed的用法中,所有来自STDIN的数据一般都会被列出到屏幕上,加上-n后，则只有经过sed
   特殊处理的那一行（或者操作）才会被列出。
-f:直接将sed的动作写在一个文件内,-f filename则可以执行filename被的sed动作
-r:sed的动作支持的是扩展型正则表达式的语法（默认是基础正则表达式的语法）
-i:直接修改读取的文件内容,而不是由屏幕输出
动作说明： [n1[,n2]] function   例: 动作需要在10到20行之间进行，则"10,20[动作行为]"
function参数:  a：新增,a的后面可以接字符串,而这些字符串会在新的一行出现（目前的下一行）
               c：替换,c的后面可以接字符串,这些字符串可以替换n1、n2之间的行
               d：删除,因为是删除,所以d后面通常不接任何参数
	       i：插入,i的后面可以接字符串,而这些字符串会在新的一行出现（目前的上一行）
	       p：打印,也就是将某个选择的数据打印出来,通常p会与参数send -n 一起运行
	       s：替换,可以直接进行替换的工作,通常这个s的动作可以搭配
sed后面接的动作，请务必以两个单引号扩住。如果sed后面要接超过两个以上的动作,每个动作前面得加-e才行。
例：仅列出/etc/passwd 文件的第5~7行 ： nl /etc/passwd | sed -n '5,7p'

部分数据的查找与替换：sed 's/要替换的字符串/新的字符串/g'
最后一行添加#This is a test:sed -i '$a # This is a test' regular.txt 。由于$代表最后一行,a是新增。

grep默认支持基础正则表达式，如果要使用扩展型正则表达式，你可以使用grep-E，不过更建议直接使用egrep。

扩展型正则表达式的特殊符号:
 +:重复一个或一个以上的前一个RE字符  例:查找god,good等字符串,'go+d'o+代表一个以上的o。
 ?:零个或一个的前一个RE字符  /  |:用或（or）的方式找出数个字符
（）:找出组字符串 例:查找glad或good这两个字符串,'g（la|oo）d'将非重复的用|分开。
（）+:多个重复组的判别 例:查找AxyzxyzC,egrep 'A（xyz）+C',查找开头是A结尾是C，中间有一个以上xyz字符串

文化的格式化与相关处理
printf '打印格式' 实际内容
\t 水平的[tab]按键   \v 垂直的[tab]按键  \f 清除屏幕 \xNN NN为两位数的数字,可以转化数字成为字符
%ns 那个n是数字,s代表string,即多少个字符  %ni 那个n是数字,i代表integer,即多少整数字数
%N,nf f代表floating(浮点)，假设我要八个位数，小数点后两位（小数点占一位）,即%10.2f：00000.00

awk:好用的数据处理工具,相比于sed常用于一整行的处理,awk则比较倾向于将一行分成数个字段处理。
因此,awk相当适合处理小型的数据处理,而默认的字段的分隔符为空格键或[tab]键。
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
处理流程：1.读入第一行，并将第一行的数据填入$0,$1,$2等变量当中。$1是第一个变量,一般是每一行第一个值。
	  2.依据条件类型的限制,判断是否需要进行后面的动作。
	  3.做完所有的动作与条件类型。
	  4.若还有后续的"行" 的数据,则重复上面1~3的步骤,直到所有的数据都读完为止。
awk怎么知道我到底这个数据有几行和几列呢？这就需要内置变量的帮忙了。
内置变量：NF:每一行($0)拥有的字段总数  / NR:目前awk所处理的是"第几行"数据 
FS:目前的分隔字符,默认是空格键,在第二行开始生效。要第一行生效的话可以预设awk的变量,利用关键字BEGIN,
   awk ‘BEGIN {FS=":"} ’
在awk的动作,即在{}内的动作,如果有需要多个命令辅助时,可以利用分号"；"间隔,或者直接以[Enter]按键来隔开每个
命令。

在每一行的每个字段都是有变量名称的,那就是$1,$2等变量名称。举个例子在last显示中root是$1，因为他是第一
列嘛！还有个变量$0则代表一整行数据的意思。
与bash、shell的变量不同,在awk当中,变量可以直接使用,不需要加上$符号。

文件比较工具
1.diff [-bBi] from-file to-file   比较两个文件之间的区别,以行为单位来比较
-b：忽略一行当中仅有多个空白的区别   -B：忽略空白行的区别   -i：忽略大小写的不同

2.cmp [-s] file1 file2        比较两个文件之间的区别,主要利用"字节"单位比较
-s：将所有的不同点的字节处都列出来,因为cmp默认仅会输出第一个发现的不同

3.patch 将旧文件升级成为新的文件 
例:制作补丁文件 diff -Naul passwd.old passwd.new > passwd.patch 
   更新  patch -pN < patch_file       还原 patch -R -pN < patch_file
-p：后面的N表示取消几层目录的意思     -R：代表还原，将新的文件还原成原来旧的文件

文件打印准备:pr

习题：找到/etc及其下面子目录中含有*的文件 grep '\*' $(find /etc/-type f),注意find找到的变量要连接$.
      如果grep '\*' /etc/*仅代表查找/etc下面第一层子目录的数据。

***********************************第13章  学习shell script********************************************************
shell scroipt是利用shell的功能所写的一个程序,这个程序是纯文本文件,将一些shell的语法与命令(含外部命令)
写在里面,搭配正则表达式，管道命令与数据流重定向等功能,以达到我们想要的处理目的。
Linux系统的服务启动的接口是在/etc/init.d这个目录下,目录下的所有文件都是script另外,包括启动(booting)
过程也是利用shell script来帮忙查找系统的相关设置数据,然后代入各个服务的设置参数。

$PATH：决定了shell将到哪些目录中寻找命令或程序，PATH的值是一系列目录，当您运行一个程序时，Linux在这些目录
下进行搜寻编译链接。
编辑你的 PATH 声明，其格式为：PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH N>

直接执行命令:shell.sh文件必须要具备可读与可执行(rx)的权限,然后：
 1.绝对路径:使用/home/dmtsai/shell.sh来执行命令；
 2.绝对路径:假设工作目录在/home/dmtsai,则使用./shell.sh来执行；
 3.变量"PATH"功能:将shell.sh放在PPATH指定的目录,例如: ~/bin/。
以bash进程来执行:通过"bash shell.sh"或"sh shell.sh"来执行
 
编写第一个script
1.第一行#!/bin/bash声明这个script使用的shell名称为bash(#!是用来声明shell的)
2.程序内容的说明
   read [-pt] variable  让用户由键盘输入内容，将该内容变成名为variable的变量
3.主要环境变量的声明:
   PATH=/bin:/sbin:/user/bin:/user/sbin:/user/local/bin:/user/local/sbin:~/bin
   export PATH
4.主要程序部分
5.告知执行结果。一个命令的执行成功与否可以使用$？这个变量来查看,那么我们也可以利用exit这个命令来让
  程序中断，并且回传一个数值给系统。

简单范例：
1.交互式脚本：变量内容由用户决定
2.随日期变化：利用日期进行文件的创建
3.数值运算:简单的加减乘除,在运算中,我们可以使用"declare -i total=$firstnu$secnu",也可使用var=$("(运算内容)")

script的执行方式区别（source,shscript,./script）
1.利用直接执行的方式来执行script(不论是绝对/相对路径还是$PATH内)，或者是利用bash(或sh)来执行脚本时，
  该script都会使用一个新的bash的环境来执行脚本内的命令。也就是说，使用这些执行方式时，该script都会
  使用一个新的bash环境来执行脚本内的命令。也就是说,使用这种执行方式时,其实script是在子程序的bash内
  执行的。
2.利用source来执行脚本：在父程序中执行   格式：source 脚本名

  		
善用判断式
条件判断：1.通过$?,$$,||来作为前一个命令执行回传值对于后一个命令是否要进行的依据。
          2.test命令

利用test命令的测试功能
test -e filename 表示存在否   (-f:存在且为file -d:directory -P:FIFO文件 -S:Socket文件 -L:连接文件)
test -r filename 表示可读否   (-r -w -x -u:SUID -g:SGID -k:Sticky bit -s:存在且非空白)        
test file1 -nt file2 两文件之间的比较 (-nt:newthan判断n1是否比n2新 -ot:oldthan -ef:判断是否为同一文件)
test n1 -eq n2  关于两整数之间的判定  (-eq:equal -ne -gt:greater than -lt:less -ge:大于等于 -le)
判断字符串的数据:Test -z/n string 判断字符串是否为0,若string为空字符,则为true/false.
                 test str1=str2 判断是否相等，是则返回true
多重条件判断,例如:test -r filename -a -x filename 
test -r filename -a/-o -x filename: -a表示all即filename同时满足-r,-x权限才会回传true，-o表示or。
判断文件类型和属性:
test -f $filename && filetype="regulare file"
test -d $filename && filetype="directory"
test -r $filename && perm="readable"
test -r $filename && perm="$perm writable"
test -r $filename && perm="$perm executable"  加上$perm防止x覆盖w,w覆盖r,产生的rwx只显示一个。

exit0 结束脚本
利用判断符号[]                                 <================================================
(因为[]用到很多地方,包括通配符与正则表达式,如果要在bash的语法当中使用中括号作为shell判断式时,则)
1.在中括号[]内的每个组件都需要有空格键来分隔;
2.在中括号内的变量，最好都以双引号括号起来;
3.在中括号内的常量，做好都以单或者双引号括号起来;

shell script的默认变量（$0,$1...）
脚本文件名后面加参数：/path/to/scriptname opt1 opt2 opt3 opt4
                             $0            $1   $2   $3   $4
执行的脚本用$0这个变量,第一个接的参数是$1.
$#:代表后接的参数的"个数"  
$@:代表$1(opt1),$2,$3,$4之意,每个变量都是独立的(用双引号括起来);
$*:代表$1c$2c$3c$4,其中c为分隔字符,默认为空格键
sh shxx.sh 变量1,2..:使用$0,1,2..等变量可以代替输入read" " 变量1,2..

[ -z "$HOME" ] 其实就等于 test -z "$HOME"可以用来判断$HOME这个变量是否为空。所以 [ ] 里面能用的选项
和test 语句能用的完全一样。 [ "$#" -lt 2 ]相当于test "$#" -lt 2，判断个数是否小于2.

shift:造成参数变量号码偏移
shift后面可以接数字，代表拿掉最前面几个参数的意思。

条件判断式
利用if..then:单层、简单条件判断式 if [ 条件判断式一 ] ；then 判断式一成立时，进行的内容
                                    elif [条件判断式二]；then 判断式二成立时，进行的内容
                                    else 不成立时，进行的内容
                                    fi  <==将if反过来写，结束if之意。

netstat -tuln来取得目前主机有启动的服务
#封包格式  本地IP:端口  远程IP:端口  是否监听
IP的部分说明是该服务位于哪个接口上,若为127.0.0.1则是仅对本机开放,若是0.0.0.0代表对整个Internet开放

几个常见的端口(port)与相关网络服务的关系是:
80:www    22:ssh   21:ftp    25:mail   111:RPC(远程过程调用)   631:CUPS(打印服务功能)

利用case..esac判断：case $变量名称 in
                     "第一个变量内容")
                       程序段
			；；   <==每个类型结尾使用两个连续的分号来处理！
		      "第二个变量内容")
                       程序段
			；；
                     *）       <==最后一个变量结尾内容都会用*来代表所有其他值
                       不包含第一个变量内容与第二个变量内容的其他程序执行段
			exit 1
			；；
		    esac       <==最终的case,结尾！

直接执行式:利用script.sh variable的方式来直接给予$1这个变量内容(variable) / 交互式:通过read命令.

利用函数function功能
在shell script当中的function的设置一定要在程序的最前面,这样才能够在执行时被找到可用的程序段。
function fname(){ 程序段 }


循环(loop)
while do done，until do done（不定循环）
格式 ： while [ condition ]  <==中括号内的状态就是判断式       until [ condition ]
        do			                               do			       
                程序段落 				               段落格式
	done 	             <==是循环的结束                   done

for...do...done（固定循环）
1.for var in con1 con2 con3 ...   第一次循环时，$var的内容是con1，第二次循环时，$var的内容是con2.
  do
        程序段
  done
2.for ((初始值；限制值；执行步长))
  do
        程序段
  done

连续数字1~100,(seq 1 100) seq为sequence(连续)的缩写

shell script的追踪与调试
格式：sh [-nvx] scripts.sh                -x:将使用到的script内容显示到屏幕上.
      -n:不要执行script,仅查询语法的问题; -v:在执行script前,先将script的内容输出到屏幕

在输出的信息中,在加号后面的数据其实都是命令串,由sh -x的方式来将命令执行过程也显示出来,如此用户可以判断
程序代码执行到哪一段时会出现相关的信息。

shell script的执行至少需要有r的权限,若需要直接命令执行,则需要拥有r与x的命令。

显示目前身份（用whoami）,目前所在的目录（用pwd）。

date命令:date(选项)(参数)
<+时间日期格式>：指定显示时使用的日期时间格式。
%s 从1970年1月1日00:00:00到目前经历的秒数 / %y 年的最后两个数字（1999则是99）
date_1=`date --date="$date2" +%s ` 将date2转化为到1970年经历的秒数
date_2=$((date_1/60/60/24)) 将所有秒数除以60秒60分24小时得到天数

*********************************第14章 Linux账号管理与ACL权限设置***************************************
你的主机并不会直接认识你的账号名称,它仅认识ID(ID就是一组号码)。而ID与账号对应关系就在/etc/passwd中。

用户标识符:UID,GID
当我们有要显示文件属性的需求时,系统会依据/etc/passwd与/etc/group的内容,找到UID/GID对应的账号与组名
再显示出来。
用户账号:用户如果需要登录主机来取得shell的环境来工作,首先,它必须要在计算机前面利用tty1~tty7的终端机
提供的login接口,并输入账号和密码后才能登录。如果是用过网络的话,哪要通过ssh功能。当输入密码后,系统:
1.先找寻/etc/passwd里面是否有你输入的账号,如果没有则跳出,如果有的话则将该账号对应的UID和GID读出来,
  另外,该账号的主文件夹与shell设置也一并读出来。
2.再来是核对密码表了！这时Linux会进入/etc/shadow里面找出对应账号的UID,然后核对一下输入的密码与里面
  密码是否相符。
3.如果一切OK的话,就进入shell管控的阶段了。

1./etc/passwd文件结构:
每一行代表一个账号,有几行就代表有几个账号在你的系统中！
[账号名称]:[密码]:[UID]:[GID]:[用户信息说明列]:[主文件夹]:[shell]:[/etc/shadow文件结构]
密码:早期UNIX系统的密码就是放在这个字段上！但是因为这个文件的特性是所有的程序是所有的程序都能够读取,
    这样一来很容易造成密码数据被窃取,因此后来就将这个字段的密码数据改放到/etc/shadow中了,所以这里
    你就会看到一个"x".
UID:用户标识符,id 范围：
               0(系统管理员)，系统管理员不见得只有root，不过不建议有多个账号的UID是0.
               1~499(系统账号):保留给系统使用的ID,其实除了0以外,其他的UID权限与特征并没有不一样。
                               默认500以下的数字让给系统作为保留账号只是一种习惯。
                               1~99:由distributions自行创建的系统账号
			       99~499:若用户有系统账号需求时,可以使用的账号UID
               500~65535(可登陆账号):给一般用户用的ID
GID:这个与/etc/group有关！其实/etc/group与/etc/passwd差不多,只是它是用来规定组名与GID的对应而已。
shell:为何默认shell会使用bash呢？就是在这个字段指定的,但是有一个shell可以用来替代成让账号无法取得
      shell环境的登录操作。那就是/sbin/nologin,这是用来制作纯POP邮件账号者的数据呢！

2./etc/shadow文件结构:
[账号名称]:[密码]:[最近改动密码日期]:[密码不可被更动的天数]:[密码需要重新更改的天数]:[密码需要更改期限前的警告天数]:[密码失效日]:[账号失效日]:[保留]
最近改动的时间:显示的是1970年到改动的日期经历的天数。
密码不可被更动的天数:限制几天内不可更改密码；密码需要重新更改的天数:强制用户更改密码。

有效(effetcive group)和初始用户组(initial group):group,newgrp
每个用户在他的/etc/passwd里面的第四列的GID就是所谓的初始用户组。也就是说当用户登陆系统,立即就拥有这个用户
组的相关权限的意思。但非初始用户组就不同了,举例来说,我将A加入B这个用户组当中,由于B这个用户组并非B的初始用
户组,因此,我必须要在/etc/group这个文件中找到A那一行,并且将B这个账号第四列,这样B才能够加入A这个用户组。

3./etc/group:这个文件就是记录GID和组名的对应
[用户组名称]:[用户组密码]:[GID]:[此用户组支持的账号名称]
密码已经移动到/etc/gshadow去。想要将某个账号加入用户组,将该账号填入这个字段即可。
例:让dmtsai加入root这个用户组,那么在第一行最后加上",dmtsai",注意不要有空格,使其成为"root:x:0:root,dmtsai"就可以
初始用户组第四个字段可以不需要填入字段。
groups:有效与支持用户组的查看,第一个输出的用户组为有效用户组。
newgrp:有效用户组的切换,而且是另外以一个shell来提供这个服务的(exit退出),切换的用户组必须是你已经有
       支持的用户组。
让一个用户加入不同的用户组:1.通过管理员(root)利用usermod帮你加入。
                           2.用户组管理员以gpasswd帮你加入他所管理的用户组。

4./etc/gshadow文件结构: 
[用户组名]:[密码列]:[用户组管理员的账号]:[该用户组的所属账号]
密码列:如果密码列上面是"!"时,表示该用户组不具备用户组管理员。

账号管理
新增与删除用户:useradd,相关配置文件,passwd,usermod,userdel
useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 主文件夹绝对路径] \
> [-s shell] 用户账号名
-m:强制!要创建用户主文件夹(一般账号默认值)/-M:强制!不要创建用户主文件夹(系统账号默认值)
-c:这个就是/etc/passwd的第五列的说明内容,可以随便设置。
-d:指定某个目录成为主文件夹,而不要使用默认值,务必使用绝对路径!
-r:创建一个系统的账号,这个账号的UID会有限制（参考/etc/login.defs）
   由于系统账号主要是用来运行系统所需服务的权限设置,所以系统账号默认都不会主动创建主文件夹的！

useradd参考文件: useradd的默认值可以使用下面的方法调用出来:useradd -D,这个数据其实是由
                 /etc/default/useradd调用出来的,你可以使用vim查看该文件的内容。
useradd命令作用的参考文件:/etc/default/useradd,/etc/login.defs,/etc/skel/等。

私有用户组机制:系统会创建一个与账号一样的用户组给用户作为初始用户组.保密性较强,因为每个用户都有自己
               的用户组,而且主文件夹的权限会设置为700.使用这种机制将不会参考GROUP=100这个设置值.
               代表性的distributions有REHL,Fedora,CentOS等。
公有用户组机制:就是以GROUP=100这个设置值作为新建账号的初始用户组,因此每个账号都属于user这个用户组,
               且默认文件夹通常的权限会是"drwxr-xr-x...dernameusers..."，由于每个账号都属于user用户组
               因此大家都可以互相分享主文件夹内的数据之故.代表的distributions有SuSE等。
系统上面GID为100者即是users这个用户组。由于我们的REHL使用的是私有机制,因此这个设置项目是不会生效的。
用户的主文件夹通常与账号同名的目录,并放在此设置值的目录后面,例vbird的主文件夹会在/home/vbird/中了。
INACTIVE=0/-1:密码过期后是否会失效的设置值。0代表密码过期立即失效,-1代表永不失效，如果是数字，如30
              代表过期30天后失效。
EXPIRE=: 账号失效的日期  
SHELL=/bin/bash: 默认使用的shell程序文件名
SKEL=/etc/skel: 这个就是指定用户主文件夹的参考基准目录。将来如果我想要新增用户时,该用户的环境变量~/.bashrc
                就设置妥当的话,你可以到/etc/skel/.bashrc去编辑一下,也可以新建/etc/skel/www 这个目录,将来
                新增用户后,在他的主文件夹下面就会有www那个目录了。
CREATE_MAIL_SPOOL=yes：创建用户的mailbox。

UID/GID密码参数参考:/etc/login.defs

因此,使用useradd这个程序在创建Linux的账号至少会参考：/etc/default/useradd、/etc/login.defs、/etc/skel/*
这些文件,不过最重要的其实是创建/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow,还有用户主文件夹。

passwd : 使用useradd创建账号后,默认的情况下,该账号是暂时被封锁的,也就是说该账号无法封路,这是就需要
         设置新的密码了。
passwd [--stdin] <==所有人均可以用来改自己的密码
passwd [-l] [-u] [--stdin] [-s] [-n 日数] [-x 日数] [-w 日数] [-i 日数] 账号 <==root功能
-l:是lock的意思,会将/etc/shadow第二列最前面加上！使密码失效 / -u:是Unlock的意思
-S:列出密码相关的参数,即shadow文件的大部分内容. / -n,-x,-w,-i:shadow的第4,5,6,7字段
--stdin:可以通过来自前一个管道的数据作为密码输入。

新的distributions是使用较严格的PAM模块来管理密码,这个管理的机制写在/etc/pam.d/passwd当中。而该文件与密码
有关的测试模块就是使用pam_cracklib.so,这个模块会检验密码相关的信息,并且替代/etc/login.defs内的PASS_MIN_LEN
的设置啦！

查看用户详细的密码参数:chage [-ldEImMW] 账号名
-l:列出该账号的详细参数 / -d,E后面接日期,修改shadow的第3,8字段
-m,M,W,I,E:后面接天数,修改shadow的第4,5,6,7字段
让用户在第一次登录时强制他们更改密码后才能使用系统资源:chage -d 0 账号

账号数据微调: usermod [-cdegGlsuLU] username
-a:与-G合用可增加次要用户组的支持而非设置 
-G:后接次要用户组,修改这个用户组能够支持的用户组,修改的是/etc/group
-c:后接账号的说明,即/etc/passwd第五列说明 / -d:后接账号的主文件夹,即修改/etc/passwd的第六列 
-l:后接账号名称,即是修改账号名称,/etc/passwd的第一列 / -U:将/etc/shadow密码列的!去掉。

删除用户的相关数据: userdel [-r] username 
-r:连同用户的主文件夹也一起删除

用户功能
finger [-s] username :查阅用户相关的信息
chfn [-foph] [账号名] :更改用户相关的信息
chsh [-ls] :chage shell的简写
id [username] :查询某人或自己的相关UID/GID等的信息

新增与删除用户组
groupadd [-g gid] [-r] 用户组名                添加
groupmod [-g gid] [-n group_name] 用户组名     修改
groupdel [groupname]                           删除

gpasswd :用户组管理员功能
1.关于系统管理员（root）做的动作
gpasswd groupname / gpasswd [-a user1,..] [-M user3,..] groupname / gpasswd [-rR] groupname
   若没有任何参数，表示给予groupname一个密码（/etc/gshadow）
-A:将groupname的主控权交由后面的用户管理 / -M:将某些账号加入这个用户组当中
-r:将groupname的密码删除 / -R:让groupname的密码栏失效
2.关于用户组管理员做的动作
gpasswd [-ad] user groupname
-a:将某个用户加入groupname这个用户组当中！ / -d:将某位用户删除出groupname这个用户组当中。

主机的具体权限规划:ACL的使用 (之前是通过文件权限限制所有人的读、写、执行,现在可以针对用户)
ACL是Access Control List的缩写,主要的目的是提供传统的owner,group,others的读、写、执行权限之外的具体
权限设置。ACL可以针对单一用户,单一文件或目录来进行r,w,x的权限设置,对于需要特殊权限的使用状况非常有
帮助。
如果一个文件设置了ACL参数后,它的权限部分就会多出一个+号了！
查看你的文件系统是否支持ACL:mount 查看挂载 ； dumpe2fs -h /dev/xxx 由superblock内容去查询ACL。

ACL的设置技巧:getfacl,setfacl
getfacl:取得某个文件/目录的ACL设置项目；
setfacl:设置某个目录/文件规定；

setfacl:设置某个目录/文件的ACL规定
setfacl [-bkRd] [{-m|-x} acl参数] 目标文件夹
-m:设置后续的acl参数给文件使用,不可与-x合用 / -x:删除后续的acl参数,不可与-m合用
-b:删除所有的ACL设置参数 / -k:删除默认的ACL参数,包括所谓的"默认"参数后于后续范例中介绍
-R:递归设置acl,亦即包括子目录都会设置起来 
-d:设置acl参数！只对目录有效,在该目录新建的数据会引用此默认值

getfacl:取得某个文件/目录的ACL设置项目 
getfacl filename
mask:有效权限,用户或组所设置的权限必须要存在于mask的权限设置范围内才会生效,此即有效权限。我们可以通过使用
     mask来规定最大允许的权限,就能避免不小心开放某些权限给其他用户或用户组了。

ACL的特殊权限:
1.针对特定用户的方法：
设置规定:" u:[用户账号列表]:[rwx] " 例如针对vbird的权限规定rx: setfacl -m u:vbird:rx 文件名
2.针对特定用户组的方法：
设置规范:" g:{用户组列表}:[rwx]" 例如针对mygroup的权限规范rx: setfacl -m g:mygroup:rx 文件名
3.针对有效权限mask的设置方法：
设置规定:" m:[rwx]" 例如针对刚才的文件规定为仅有r: setfacl -m m:r 文件名
4.针对默认权限的设置方法：
设置规范: "d:[ug]:用户列表:[rwx]"

身份切换可使用su,也可使用sudo,但使用sudo则必须先以visudo设置可使用的命令.
su [-lm] [-c 命令] [username]
-:单纯使用-如"su -",代表使用login-shell的变量文件读取方式来登录系统,若用户名称没有加上去,则代表
  切换为root的身份。单纯的"su"切换成为root的身份,读取的变量设置方式为non-login shell的方式。这种
  方式下很多原本的变量不会被改变。
-l:与 - 类似,但后面需要加欲切换的用户账号.也是login-shell的方式。
-c:仅进行一次命令。

exit:可以离开su的环境。

sudo相对于su需要了解新切换的用户密码,sudu的执行则仅需要自己的密码即可！甚至可以设置不需要密码即可
执行sudo呢！由于sudo可以让你以其他用户的身份执行命令,因此并非所有人都能执行sudo,而是仅有/etc/sudoers
内的用户才能够执行sudo这个命令。
sudo [-b] [-u 新用户账号] 命令
-b:将后续的命令让系统自行执行,而不与目前的shell产生影响
使用sh -c的方法来执行一连串的命令。

visudo命令设置将用户、用户组加入到/etc/sudoers:
除了root以外的其他账号,若想要使用sudo执行属于root的权限命令,则root需要先使用visudo去修改/etc/sudoers
让该账号能够使用全部或部分的root命令功能。

一般来说,visudo的设置方法有几种简单方法：
1.单一用户可进行root所有命令与sudoers文件语法
visudo 命令 :其实visudo只是利用vi将/etc/sudoer文件调出来进行修改而已,所以这个文件就是/etc/sudoerds。这个
             文件设置其实很简单,如果你找到76行(有root设置的那行)左右,看到的数据就是：
[用户账号] [登陆者的来源主机=(可切换的身份)]  [可执行的命令]

2.利用用户组以及免密码的功能处理visudo
在最左边加上%,代表后面接的是一个用户组的意思：%group  ALL=(ALL)  ALL
如果组内用户不需要输入密码则：%group ALL=(ALL) NOPASSWD:ALL

3.有限制的命令操作
上面两点都会让用户能够利用root的身份进行任何事情,这样总是不太好。如果我想让用户仅能进行部分系统任务,
例如:user1仅可以使用passwd命令帮忙root修改其他用户密码
user1 ALL=(root) /user/bin/passwd <=最后命令务必使用绝对路径。 
但要注意限制修改root密码:xxx ALL=（root） ！/user/bin/passwd,/user/bin/passwd [A-Za-z]*,!/user/bin/passwd root

4.通过别名设置visudo
User_Alias/账号别名命令 账号别名=实际账号
Cmnd_Alias/命令别名命令 账号别名=实际命令
例:将pro1,pro2,pro3加入上诉的密码管理员的sudo列表,那我可以新建一个账户别名为ADMPW的名称
User_Alias ADMPW=pro1,pro2,pro3
Cmnd_Alias ADMPWCOM= ！/user/bin/passwd,/user/bin/passwd [A-Za-z]*,!/user/bin/passwd root
ADMWP ALL=(root) ADMWPCOM
账号名称一定要用大写字符来处理,包括Host_Alias(来源主机别名),命令别名等。最后一行则写入账号与命令别名
将来要修改时，只要修改上面两行即可！

5.sudo的时间间隔问题
两次执行sudo的间隔在五分钟内,那么在执行sudo时就不需要再次输入密码了。

6.sudo搭配su的使用方法
将大量需要执行的工作一口气将身份转为root,而且还用用户自己的密码来变成root。
例:将pro1,2,3用户只要输入sudo su-,并且输入自己的密码,立刻变成root用户。
User_Alias ADMPW=pro1,pro2,pro3
ADMWP ALL=(root) /bin/su -

特殊的shell,/sbin/nologin
我们所谓的"无法登陆"指的仅是这个用户无法使用bash或其他shell来登录系统而已,并不是说这个账号就无法使
用其他的系统资源。

PAM模块简介/etc/pam.d/*
PAM可以说是一套应用程序编程接口(API),它提供了一连串的验证机制,只要用户将验证阶段的需求告知PAM后，
PAM就能够回报用户验证的结果（成功或失败）。

我们以passwd这个命令调用PAM时,这个程序调用PAM的流程是:
1.用户开始执行/usr/bin/passwd这支程序,并输入密码；
2.passwd调用PAM模块进行验证；
3.PAM模块会到/etc/pam.d/中找寻与程序(passwd)同名的配置文件；
4.依据/etc/pam.d/passwd内的设置,引用相关的PAM模块逐步进行验证分析；
5.将验证结果回传给passwd这个程序；
6.passwd这支程序会根据PAM回传的结果决定下一个操作(重新输入新密码或者通过验证！)；

[验证类型] [控制标准] [PAM模块与该模块的参数]
验证类型分为auth(认证)、account(账号)、session(会议期间)、password(密码)
验证的控制方式分为required、requisite、sufficient、optional

PAM用来进行验证的数据称为模块。
/etc/pam.d/* :每个程序个别的PAM配置文件            /etc/security/* :其他PAM环境的配置文件
/lib/security/* :PAM模块文件的实际放置目录         /user/share/doc/pam-*/ :详细的PAM说明文件

其他相关文件
1. limit.conf /etc/security/limits.conf [账号] [限制依据] [限制项目] [限制值]
   第一字段为账号,或者用户组！若为用户组则前面加上@,例如@projects.
2. /var/log/secure /var/log/messages  出现问题可以在这里面查看！

Linux主机上的用户信息传递
1.查询用户:w,who,last,lastlog
  如果你想知道目前已经登录在系统上面的用户:w,who查询
  如果你想知道每个账户的最近登录的时间:lastlog命令,lastlog会去读取/var/log/lastlog文件,然后将数据输出
2.用户对谈:write,mesg,wall
  write 用户账号 [用户所在终端接口]
  mesg n 不想接受信息
  wall 对所有系统上面的用户传达信息（广播）
用户邮件邮箱:mail

手动新增用户
1.一些检查工具
pwck：这个命令会检查/etc/passwd这个账号配置文件内的信息,与实际的文件夹是否存在等信息,还可以比较
      /etc/passwd /etc/shadow的信息是否一致,另外,如果/etc/passwd内的数据字段错误时,会提示用户修改
pwconv:这个命令主要是将/etc/passwd内的账号与密码移动到/etc/shadow当中！
chpasswd:可以读入未加密前的密码,并且经过加密后,将加密后的密码写入/etc/shadow当中。

2.特殊账号(如纯数字账号)的手工新建
新建一个账号并且属于用户组
1.先新建所需要的用户组(vi /etc/group)   2.将/etc/group与/etc/gshadow同步(grpconv)
3.新建账号的各个属性(vi /etc/passwd)    4.将/etc/passwd与/etc/shadow同步(pwconv)
5.新建该账号的密码(passwd accountname)  6.新建用户主文件夹(cp -a/etc/skel/home/accountname)
7.更改用户文件夹的属性(chown -R accountname.group/home/accountname)

3.批量新建账号模板(适用于passwd--stdin参数): http://linux.vbird.org/linux_basic/0410accountmanager/account1.sh

例题:1.如果我要让test这个账号具有root的权限,应该怎么做？
       答:将/etc/passwd里,test的UID和GID栏位变成0即可。
     2.如果我想让一个账户暂时失效,但不删除,该怎么做?(使用3种不同方法)
       答:1.将/etc/passwd的shell栏位写成/sbin/nologin
	  2.将/etc/shadow内的密码栏位增加一个*号在最前面
	  3.将/etc/shadow的第八个栏位关于账号取消日期的那个,设置小于目前日期的数字
     3.我希望在我设置每个账号的时候(使用useradd),默认的情况中,他们的主文件夹就含有一个名称为www的子
       目录,我应该怎么做?
       答:由于使用useradd的时候,会自动以/etc/skel作为主文件夹,所以,我可以在/etc/skel里面新增加一个
	  名称为www的目录即可。
     4.如果我需要将用户主文件夹以后都放置到/account这个目录下，我该如何做才可以使用useradd时默认的
       主文件夹就指向/account？
       答:最简单的办法,编辑/etc/default/useradd,将里头的HOME=/home改成HOME=/account即可。

***********************************第15章 磁盘配额与高级文件系统管理********************************
磁盘配额(Quota)的应用与实践
限制因素:1.仅针对整个文件系统 2.内核必须支持quota 3.只对一般用户有效 4.Quota的日志文件
规范设置选项:1.容量限制与文件数量限制 2.宽限时间grace time（介于soft与hard之间）

1>.实践Quota流程1:文件系统支持
df -h /home 如果你的sda5是挂载在/home下面,检查/home是否是个独立的文件系统。
mount | grep home   由于VFAT文件系统并不支持Linux Quota功能,所以我们mount查询一下/home文件系统
如果只是想要在这次开机中实验Quota,那么可以使用一下方式手动添加:
mount -o remount,userquota,grpquota /home
mount | grep home  当你重新挂载时,系统会同步更新/etc/mtab这个文件,所以你必须要确定/etc/mtab已经加入
                   userquota,grpquota(用户和用户组的文件系统支持参数)的支持到你所想要设置的文件系统中。
不过手动挂载的数据在下次重新挂载就会消失,因此最好写入配置文件中/etc/fstab。
vi /etc/fstab   ->  LABEL=/home  /home  ext3 defaults,userquota,grpquota 1 2

2>.实践Quota流程2:新建Quota配置文件
其实Quota是通过分析整个文件系统中的每个用户(组)拥有的文件总数与总容量,再将这些数据记录在该文件系统的最
顶层目录,然后在该配置文件中再使用每个账号(或组)的限制值去规定磁盘使用量的。

quotacheck:扫描文件系统并新建Quota的配置文件   quotacheck [-avugfM] [/mount_point]
-a:扫描所有在/etc/mtab内,含有quota支持的文件系统,加上此参数后,/mount_point可不必写,因此扫描所有文件系统
-u/-g:针对用户/用户组扫描文件与目录的使用情况,会新建aquota.user/aquota.grp。
-v:显示扫描过程的信息   -f:强制扫描文件系统,并写入新的quota配置文件(危险) 
-M:强制以读写的方式扫描文件系统,只有在特殊情况下使用。
注:-f,M是在文件系统已经可能启动quota但你还想重新扫描文件系统时，系统会要求你加入那两个参数。一般只
   -avug一起执行即可。

3>.实践Quota流程3:Quota启动、关闭与限制
使用Quotaon启动,Quotaoff关闭:     
①quotaon[-avug]  quotaon[-vug][/mount_point]
-u:针对用户启动quota(aquota.user)  / -g:针对用户组启动quota(aquota.group)
-a:根据/etc/mtab内的文件系统设置启动相关的quota,若不加-a的话,则后面需要加特定的那个文件系统
-v:显示启动过程的相关信息 
②quotaoff [-a]   quotaoff [-ug] [/mount_point]
-a:全部的文件系统的quota都关闭(根据/etc/mtab)   -u:仅针对后面接的那个/mount_point关闭user quota
-g:仅针对后面接的那个/mount_point关闭group quota
③edquota:编辑账号/用户组的限值与宽限时间
edquota [-u username] [-g groupname]  /  edquota -t  <==修改宽限时间
edquota -p 范本账号 -u 新账号   : -p复制范本,将范本账号这个人的quota限值值复制给新账号。
[文件系统][磁盘容量][磁盘容量soft限制值][block的hard限制值][文件数量][inode的soft限制值][inode的hard限制值]
在edquota的界面中,每一行只要保持七个字段就可以了,并不需要排列整齐的！

4>.时间Quota流程4:Quota限制的报表
quota的报表主要有两种模式,一种是针对每个个人或用户组的quota命令,一个是针对整个文件系统的repquota命令
①quota:单一用户的quota报表
quota [-uvs] [username] / quota [-gvs] [groupname]
-u:后面可以接username,表示显示出该用户的quota限制值。若不接username,表示显示出执行者的quota限制值
-g:后面可以接groupname,表示显示出该用户组的quota限制值。
-v:显示每个用户在文件系统中的quota值  / -s:使用1024的倍数来指定单位,会显示如M之类的单位
②repquota:针对文件系统的限额做报表   repquota -a [-vugs]
-a:直接到/etc/mtab查询具有quota标志的文件系统,并报告quota的结果.
-v:输出的数据将含有文件系统相关的详细信息 / -u:显示出用户的quota限制(这是默认值)
-g:显示出个别用户的quota限值 / -s:使用M,G为单位显示结果

5>.实践Quota流程5:测试与管理
①warnquota:对超出限额者发出警告信
  依据/etc/warnquota.conf的设置,然后找出目前系统上面quota用量超过soft(就是有gracetime出现的哪些家伙)
  通过Email的功能将警告信息发送到用户的电子邮箱信箱。
②如何让系统自动执行warnquota
③setquota:直接与命令中设置quota权限
  setquota [-u|-g] 名称 block(soft) block(hard) inode(soft) inode(hard) 文件系统

6.使用Link连接来实现不改动既有系统的Quota进行限制(需要符合SELinux规则)。

软件磁盘阵列(software RAID)
为了将系统可以实时地在坏掉硬盘时重建,因此就需要预备磁盘(spare disk)的辅助。
为何磁盘阵列又分为硬件与软件呢？所谓的硬件磁盘阵列是通过磁盘阵列卡来完成数组的目的。磁盘阵列卡上面
一块专门的芯片在处理RAID的任务，因此在性能方面会比较好。硬件磁盘阵列在linux下面看来就是一块实际的大
硬盘,因此硬件磁盘阵列的设备文件名为/dev/sd[a-p],因为使用到SCSI的模块之故。至于软件磁盘阵列通过软件
来仿真数组的任务,使用的设备文件名是系统的设备文件(/dev/md[0-9]),因此会损耗较多的系统资源。
 
软件磁盘阵列的设置(新建和查看)
mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N --level=[015] --spare-devices=N /dev/sdx .. 
mdadm --detail /dev/md0       --detail:后面接的那个磁盘阵列设备的详细信息
--create:为新建RAID的参数  /  --auto=yes:决定新建后面接的磁盘作为磁盘阵列的设备,即/dev/md0等
--raid-devices=N:使用几个磁盘作为磁盘阵列的设备 / --spare-devices=N:使用几个磁盘作为备用(spare)设备
--level=[015]:设置这组磁盘阵列的等级,支持很多RAID-0、RAID-1等，不过建议只要用0,1,5即可

你也可以查阅以下的文件来看看系统软件磁盘阵列的情况:cat /proc/mdstat

格式化与挂载使用RAID:mkfs -t ext3 /dev/md0   mkdir /mnt/raid   
	             mount /dev/md0 /mmt/raid         df查看

仿真RAID错误的救援模式
mdadm --manage /dev/md[0-9] [--add 设备] [--remove 设备] [--fail 设备]
--add:会将后面的设备加入到这个md中！     --remove:会将后面的设备从这个md中删除。
--fail:会将后面的设备设置成为出错的状态。
1.设置磁盘为错误  
2.将出错的磁盘删除并加入新磁盘:首先我们再新建一个新的分区,这个分区要与其他分区一样才好！然后在利用
  mdadm删除错误的并加入新的！
 
开机自启动RAID并自动挂载
新的distribution大多会自己查询/dev/md[0-9]，然后在开机的时候给予设置好的所需要的功能。不过还是建议
修改配置文件。RAID也是有配置文件的(/etc/mdadm.conf)。文件内容很简单,你只要知道/dev/md0的UUID就能够
设置这个文件了。
madadm --detail /dev/md0 | grep -i uuid   #后面那一串数据就是这个设备向系统注册的UUID标识符
vi /etc/mdadm.conf                        #开始设置madadm.conf
vi /etc/fstab                             #开始设置开机自动挂载并测试

关闭软件RAID(重要!)
umount /dev/md0    vi /etc/fstab          #先卸载且删除配置文件内容与这个/dev/md0有关的设置
madam --stop /dev/md0                     #直接关闭/dev/md0的方法
cat /proc/mdstat                          vi /etc/mdadm.conf                           

逻辑卷管理器（LVM / Logical volume manager）
LVM的重点在于可以弹性调整文件系统的容量！而并非在于性能与数据保全上面。LVM可以整合多个物理分区或将
其从这个LVM管理的磁盘当中删除。

什么是LVM:PV,PE,VG,LV的意义
LVM的作法是将几个物理的分区(或磁盘通过软件组合成为一块看起来是独立的大磁盘VG),然后将这块大磁盘在经过
分成可使用的分区LV,最后就能够挂在使用了。
1.PhysicalVolume,PV,物理卷
  我们实际的分区需要调整系统标识符（system ID）成为8e（LVM的标识符）,然后再经过pvcreate的命令将它转
  成LVM最底层的物理卷（PV）,之后才能够将这些PV加以利用,调整system ID的方式就是通过fdisk。
2.Volume Group,VG,卷用户组
  所谓的LVM大磁盘就是将许多的PV整合成这个VG,所以VG就是LVM组合起来的大磁盘。这个大磁盘的容量与PE有关,
  因为每个VG最多仅能包含65534个PE而已。如果使用LVM默认的参数,则一个VG最大可达256GB容量。
3.Physical Extend,PE,物理扩展块
  PE是LVM最小的储存块,为了方便用户利用LVM来管理系统,因此LV的设备文件名通过指定为/dev/vgname/lvname
  的样式。
  LVM可弹性更改文件系统的容量是通过交换PE来进行数据转换,将原本LV内的PE移动到其他设备中以降低LV容量,
  或将其他设备的PE加到此LV中以加大容量。
4.实现流程
  实际partition阶段->PV阶段->VG阶段->LV阶段->文件系统使用阶段
  利用LV来进行系统的挂载时,数据写入这个LV时,到底它是怎么写入硬盘当中的?依据写入机制不同,有两种方式:
  ①线性模式(linear):假如我将/dev/hda1,/dev/hdb1这两个分区加入到VG当中,并且整个VG只有一个LV时,那么所
                     谓的线性模式就是/dev/hda1的容量用完之后,/dev/hdb1的硬盘才会被使用到。
  ②交错模式(triped):将一条数据拆成两部分,分别写入/dev/hda1与/dev/hdb1的意思。感觉有点像RAID 0。如此
                     一来,一份数据用两块硬盘来写入。

实践阶段:1.分区，设置分区容量,且systemID需要为8e；2.将分区整合成为一个VG,且PE的大小为16MB；
         3.全部的VG容量都丢给LV；                 4.格式化LV为ext3的文件系统,且挂载

PV阶段:pvscan 查询目前系统里面任何具有PV的磁盘；  pvcreate 将物理分区新建成为PV
       pvdisplay 显示出目前系统上面的pv状态；     pvremove 将pv属性删除,让该分区不具有pv属性
VG阶段:vgscan 查找系统上面是否有VG存在；          vgcreate 新建VG的命令
       vgdisplay 显示目前系统上面的VG状态；       vgextend 在VG内增加额外的PV
       vgreduce 在VG内删除PV；                    vgchange 设置VG是否启动(active)
       vgremove 删除一个VG；
       与PV不同的是,VG的名称是可以自定义的！我们知道PV的名称其实就是分区的设备文件名,但VG名称可以随便
       vgcreate [-s N[mgt]] VG名称 PV名称  -s:后面接PE的大小,单位可以是m,g,t
LV阶段:创造出VG这个大磁盘之后,再来就是要新建分区。这个分区就是所谓的LV。（名称必须使用全名）
       lvcreate 新建LV；    lvscan 查询系统上面的LV；    lvdisplay 显示系统上面的LV状态；
       lvextend 在LV里面增加容量；   lvreduce 在LV里面减少容量；    lvremove 删除一个LV；
       lvresize 对LV进行容量大小进行调整；
       lvcreate [-L N[mgt]] -s [-n LV名称] VG名称 / lvcreate [-l N] [-n LV名称] VG名称
       -L:后接容量,大小为PE的倍数   -l:后面接PE的个数  
特别注意的是VG名称可以是vbirdvg，但LV的名称必须使用全名/dev/vbirdvg/vbirdlv（例子）。其实LV的名称构
建成为/dev/vbirdvg/vbirdlv是为了用户直观找到我们所需要的数据,实际上LVM使用的设备是放置在/dev/mapper
目录下的！
 
文件系统阶段
格式化,挂载,查看我们的LV吧！mkfs ->mkdir ->mount ->df
放大LV容量:1.用fdisk设置新的具有8e systemID的分区      2.利用pvcreate构建PV
           3.利用vgextend将PV加入我们的VG中            4.利用lvresize将新加入的PV内的PE加入LV中
           5.通过resize2fs将文件系统的容量确实增加(通过在文件系统增加block group的方式增加文件系统的量)
             resize2fs [-f] [device] [size]   ：-f 强制进行resize的操作
缩小LV容量:先查看需要卸载的磁盘的容量情况pvdisplay、pvscan，然后卸载umount /mnt/lvm ,e2fsck检查磁盘
           然后在resize2fs  [device]  缩减后的size，重新挂载/mnt/lvm与device，并且df查看/mnt/lvm，
           然后lvresize -l -number（缩小磁盘的PE数） [device] 这样就将LV缩小了,lvdisplay查看
           接下来就要将磁盘移出VG之外了,首先需要确定磁盘里面的PE完全不被使用后才能抽离,pvdisplay观察
           是否PE被使用,如果被使用,pvmove将PE移动到另一个磁盘。然后将磁盘移出VG中vgreduce，并pvscan查看
           最后pvremove。
LVM的系统快照:lvcreate [-l N] -s -n 快照区的设备名称 被快照的LV完整文件名
              -s:snapshot快照功能的意思
              快照区的新建:下面操作主要增加需要的VG容量,然后再通过lvcreate -s的功能新建快照区。
LVM的设备的关闭并删除：1.先卸载系统上面的LVM文件系统（包括快照与所有LV）
 		       2.使用lvremove删除LV；3.使用vgchange -an VGname 让VGname这个VG不具有Active标志
                       4.使用vgremove删除VG；5.使用pvremove删除PV；
                       6.最后,使用fdisk将ID修改回来。

************************************第16章 例行性工作***************************************************
Linux工作调度的种类:at,cron
例行性的工作调度:crontab这个命令所设置的工作将会循环一直进行下去。可循环的时间为分钟、小时、每周等,
                 crontab除了可以使用命令执行外,也可以编辑/etc/crontab来支持。至于让crontab生效的服务
                 则是crond这个服务。
突发性的工作调度:at是个可以处理仅执行一次就结束调度的命令,不过要执行at必须要有atd这个服务的支持才行。

常见的例行任务:进行日志文件的替换log rotate,日志文件分析logwatch的任务，新建locate的数据库,
               whatis数据库的建立,RPM软件日志文件的新建,删除临时文件,与网络服务有关的分析行为。

《仅执行一次的工作调度:atd的启动与at运行的方式》
启动atd:/etc/init.d/atd restart,并且设置开机启动chkconfig atd on ；                          
1.我们使用at这个命令来生成所要执行的工作,并将这个工作以文本文件的方式写入/var/spool/at/目录内,该工作
便能等待atd这个服务的取用与执行了。
2.我们可以利用/etc/at.allow与/etc/at.deny这两个文件来进行at的使用限制,防止被黑客程序绑架
  ①先寻找/etc/at.allow这个文件，写在这个文件中的用户才能使用at,没有在这个文件中的用户则不能使用at(即使没
    有写在/etc/at.deny)；
  ②如果/etc/at.allow不存在,就寻找/etc/at.deny这个文件,若写在at.deny的用户则不能使用at,而没有在这个文件中
    的用户就可以使用at；
  ③如果两个文件都不存在,那么只有root可以使用at这个命令；

实际运行单一工作调度
at [-mldv] TIME     /  at -c 工作号码
-m:当at的工作完成后,以email通知用户工作完成。 -l:at -l相当于atq,列出目前系统上面的所有该用户的at调度
-d:at -d相当于atrm，可以取消一个在at调度中的工作  -v:可以使用较明显的时间格式列出at调度中的任务列表
-c:可以列出后面接的该项工作的实际命令内容  TIME:可以定义什么时候要进行at这项工作的时间

最后,输入[ctrl]+d就会出现<EOF>的字样,代表结束！

注:当我们使用at时会进入一个at shell的环境来让用户执行工作命令,此时建议你最好使用绝对路径来执行你的
   命令.由于命令的执行与PATH变量有关,同时与当时的工作目录也有关联。

at的执行与终端机环境无关,而所有standard output/standard error output都会传送到执行者的mailbox去啦!

at有另一个优点就是后台执行的功能！
由于在at工作调度的使用上,系统会将该项at工作独立出你的bash环境中，直接交给系统的atd程序来接管，因此
当你执行at的工作之后就可以立即脱机,剩下的工作就完全交给LINUX管理即可！

at工作的管理:
atq 查询目前主机上面有多少的at工作调度 
atrm 删除at工作调度

如果你是在一个非常忙碌的系统下运行at,能不能指定你的工作在系统较闲的时候才进行？使用batch命令试试。
batch:系统有空时才进行后台任务,会在CPU工作负载小于0.8的时候,才进行你所执行的工作情况。

《循环执行的例行性工作调度:cron控制》
1.与at相似,我们可以利用/etc/cron.allow和/etc/cron.deny这两个文件限制使用crontab的用户账号。
2.当用户使用crontab这个命令来新建工作调度之后,该项工作就会被记录到/var/spool/cron里面去了,而且是以账
  号来作为判别的。但请注意,不要使用vi直接编辑该文件,因为可能由于输入语法错误,会导致无法执行cron.另外,
  cron执行的每一项工作都会被记录到/var/log/cron这个日志文件中,所以你可以查询这个文件来判断主机是否被
  植入木马。
crontab [-u username] [-l|-e|-r]
-u:只有root才能进行这个任务,也即帮其他用户新建/删除crontab工作调度
-e:编辑crontab的工作内容  -l:查询crontab的工作内容  -r:删除所有crontab的工作内容,若只删除一项,-e编辑

[分钟][小时][日期][月份][周][命令]                                   <<<================================ 
特殊符号:*星号代表任何时刻都接受  ,逗号代表分隔时段的意思  -减号代表一段时间范围内 
         /n斜线代表每隔n单位间隔进行一次

系统的配置文件:/etc/crontab
基本上,cron这个服务的最低检测限制是"分钟",所以cron会每分钟去读取一次/etc/crontab与/var/spool/cron里面
的数据内容,因此,只要你编辑完/etc/crontab这个文件,并且将它保存后,那么cron的设置就自动回来执行了！

/etc/crontab这个文件里面支持两种执行命令的方式:
1.命令类型  例: 01  * * * * dmtsai mail -s "testing" kiki < /home/dmtsai/test.txt
            析: 以dmtsai这个用户的身份,在每小时执行一次mail命令。
2.目录规划  假设你有一个目录,让系统可以每隔一段时间去执行该目录下的所有可执行文件,可以使用run-parts
            这是一个bash script会将目录内的所有文件找出来执行。
            例: */5 * * * * root run-parts /root/runcron
            析: 新建一个/root/runcron的目录,将要每隔五分钟执行的"可执行文件"都写到该目录下,就可以让
                系统每五分钟执行一次该目录下的所有可执行文件。
            例: 01 * * * * root run-parts /etc/cron.hourly
            析:后面的命令你可以使用"which run-parts"看看,其实那是一个bash script。如果你直接进入/usr/bin/run-parts
               去看看,会发现这个命令会将后面接的"目录"内的所有文件找出来执行！也就是说如果你想系统每小时
               主动帮你执行某个命令,将该命令写成script,并将该文件放置到/etc/cron.hourly目录即可。
一些注意事项:
1.资源分配不均的问题；
2..取消不必要的输出选项:使用数据重定向直接以命令重定向将输出的结果输出到/dev/null这个垃圾桶就好了；
3.安全的检测:可以检查/var/log/cron的内容来查看是否有非你设置的cron被执行；
4.周与日、月不可同时并存；

可唤醒停机器件的工作任务
anacron命令在于处理非24小时一直启动的Linux系统的crontab的执行。所以anacron并不能指定何时执行某项任务
而是以天为单位或者是开机后立即进行anacron的操作,它会去检测停机期间应该进行但没有进行的crontab任务,
并将该任务执行一遍,然后anacron就会自动停止了。
anacron运行的时间通常有两个,一个是系统开机期间运行,一个是写入crontab的调度中。这样才能够在特定时间
分析系统未进行的crontab工作。

anacron [-sfn] [job].. / anacron -u [job]..
-s:开始连续执行各项工作(job),会依据时间记录文件的数据判断是否进行
-f:强制进行,而不去判断时间记录文件的时间戳;      -n:立即进行未进行的任务,而不延迟等待时间
-u:仅更新时间记录文件的时间戳,不进行任何工作;    job:由/etc/anacrontab定义的各项工作名称

所以我们发现其实/etc/cron.daily/0anacron仅进行时间戳的更新,而没有进行任何anacron的操作。在我们的CentOS中,
anacron的进行其实是在开机完成后才进行的一项任务,你也可以将anacron排入ceontab的调度中。但是为了担心anacron
误判时间参数,因此/etc/cron.daily/里面的anacron才会在文件名之前加个0,让anacron最先进行,就是为了时间戳先更新
以避免anacron误判crontab尚未进行任何工作的意思。

anacron若执行"anacron -scron.daily"时,它会这样运行:
1.由/etc/anacrontan分析到cron.daily这项工作名称的天数为1天；
2.由/var/spool/anacron/cron.daily取出最近一次执行anacron的时间戳；
3.由上个步骤与目前时间比较,若差异天数为1天以上(含1天),就准备进行命令；
4.若准备进行命令,根据/etc/anacrontab的设置延迟65分钟；
5.延迟时间过后,开始执行后续明理路,即"run-part /etc/cron.daily"这串命令；
6.执行完毕后,anacron程序结束；

举例来说,如果我的主机是在20090315(周末)18:00关机,然后在20090316(周一)8:00开机,由于我的crontab是在早上04:00
左右进行各项任务,由于该时刻系统是关机的,因此时间戳依旧是20090315,但目前时间已经是20090316,因此run-part 
/etc/cron.daily就会在开机过65分钟开始运行。

确定开机执行anacroon: chkconfig --list anacron

系统每天,每周,每月各有进行什么工作可以通过/etc/cron.daily/,/etc/cron.week/,/etc/cron.monthly/这三个
目录内查看。

************************************第17章 程序管理与SELinux初探*******************************************

SELinux全称为Security-Enhanced Linux是美国国家安全局在Linux开源社区帮助下开发的一个MAC强制访问控制的
安全子系统，在红帽RHEL7系统中启用SELinux技术的目的是为了让各个服务进程都受到约束，仅能获取到服务本应
获取到的资源。例如您在自己的电脑上下载了一个美图软件，正在全神贯注得把自己P瘦点的时候，这款软件却在
后台默默监听着浏览器中输入的密码信息，这显然不应该是这款美图软件本应做的事情（即便是访问电脑中的图片
资源都情有可原），SELinux安全系统就是为了杜绝此类情况而设计的，它能够从多方面进行违法行为监控，首先
是对服务进程进行功能限制，SELinux域限制技术让服务程序做不了出格的事情，其次还能够对文件进行资源限制，
SELinux安全上下文让文件只能被所属于的服务程序所获取到。


一个程序被加载到内存当中运行,那么内存内的那个数据就被称为进程。
触发任何一个事件时,系统都会将它定义成为一个进程,并且给予这个进程一个ID,称为PID,同时依据触发这个进程
的用户与相关属性关系，给予这个PID一组有效的权限设置。
fork and exec:过程调用的流程；系统或网络服务:常驻于内存的进程；

工作管理(job control)
由于假设我们只有一个终端,因此在可以出现提示符让你操作的环境就称为前台(foreground),至于其他工作就可
以让你放入后台去暂停或运行。要注意的是,放入后台的工作想要运行时,它必须不能够与用户互动。举例来说,
vim绝对不可能在后台里面执行(running)。因为你没有输入数据它就不会跑。而且放入后台的工作是不可以使用
[ctrl]+c来终止的！
总之,要进行bash的job control必须要注意的限制是:
这些工作所触发的进程必须来自于你shell的子程序（只管理自己的bash）；
前台:你可以控制与执行命令的这个环境成为前台(foreground)工作；
后台:可以自行运行的工作,你无法使用[ctrl]+c终止它,可使用bg/fg调用该工作；
后台中"执行"的进程不能等待terminal/shell的输入(input)；

进行job控制的命令有哪些?              <<< <=======================================================
1.直接将命令丢到后台中"执行"的"&"。     2.将目前的工作丢到后台中"暂停":ctrl-z。+代表最后一个被丢到后台的工作。
3.查看目前的后台工作状态:jobs [-lrs]。  -l列出PID号码,-r仅列出正在后台run的工作,-s仅列出正在后台暂停的工作
4.将后台工作拿到前台来处理:fg %jobnumber。jobnumber为工作号码(数字),那个%可有可无。
5.让工作在后台的状态变成运行中:bg %jobnumber。
6.管理后台当中的工作:kill -signal %jobnumber / kill -l
  -l:列出目前kill能够使用的信号有哪些；
  signal:代表给予后面接的那个工作什么样的指示。用man 7 signal可知:
  -1:重新读取一次参数的配置文件(类似reload)； -2:代表由键盘输入[ctrl]-c同样的操作；
  -9:立即强制删除一个工作；                   -15:以正常的程序方式终止一项工作。

脱机管理问题:
nohup [命令与参数] & <==加上&表示在终端机后台中工作，去掉&表示在前台工作。

进程的查看
ps：将某个时间点的进程运行情况选取下来
ps aux 查看系统所有的进程数据  ps -lA 也是能够查看所有系统的数据  ps axjf 连同部分进程树的状态

ps -l:仅查看自己的bash相关进程
[进程标志][进程状态][UID][PID][PPID][CPU使用率][CPU执行优先级][优先级][所在内存部分][用掉内存][进程运行状态][登陆者终端机位置][使用掉的CPU的时间][触发进程的命令]
F进程标志:说明这个进程的权限,常见号码有,若表示此进程的权限为root,为1则表示此子程序仅可进行复制而无法实际执行
S进程状态:常见的状态有 R:running S:sleep D:不可唤醒的睡眠状态 T:stop Z:zombie,僵尸状态,进程已经终止但无法被删除至室外
PRI/NI:优先级数值越小代表进程越快被CPU执行。
TTY:登陆者的终端机位置,若为远程登录则使用动态终端接口(pts/n)。
TIME:使用掉的CPU时间,注意,是此进程实际花费CPU运行的时间,而不是系统时间。
CMD:就是command的缩写,造成此程序的触发进程的命令为何。

ps aux
%MEN:该进程所占用的物理内存百分比  VSZ:该进程使用掉的虚拟内存量  RSS:该进程占用的固定的内存量
STAT:该进程目前的状态  START:该进程被触发启动的时间  TIME:该进程实际使用CPU运行的时间

top:动态查看进程的变化
top [-d 数字] | top [-bnp]
-d:后面接秒数,就是整个进程界面更新的秒数  
在top执行过程中可以使用的按键命令: ?:显示在top当中可以输入的按键命令 P:以CPU的使用资源排序显示
                                   M:以内存的使用资源排序显示  N:以PID排序显示  T:由该进程使用的CPU时间积累排序
				   K:给予某个PID一个信号 r:给予某个PID重新制作一个nice值 q:离开top软件

我们自己的PID可由$$变量取得,请使用top持续查看该PID。

pstree [-A|U] [-up] ：进程树,寻找进程之间的相关性。
-A:各进程树之间的连接以ASCII字符来连接； -U:各进程树之间的连接以utf8码的字符来连接,在某些终端接口下可能有错误
-p:同时列出每个进程的PID；               -u:同时列出每个进程的所属账号名称。


进程的管理
kill -signal PID
kill可以帮我们将这个signal传送给某个工作(%jobnumber)或者是某个PID(直接输入数字)。
主要信号代号与名称对应
1  SIGHUP  启动被终止的进程,可让该PID重新读取自己的配置文件,类似重新启动
2  SIGINT  相当于用键盘ctrl-c来中断一个进程的进行
9  SIGKILL 代表强制中断一个进程的进行,如果该进程进行到一半,那么尚未完成的部分可能会有半产品产生
15 SIGTERM 以正常的结束进程来终止该进程
17 SIGSTOP 相当于用键盘ctrl-z来暂停一个进程的进行
killall -signal 命令名称
killall [-iIe] [command name]  
-i：交互式的,若要需要删除时,会出现提示符给用户；

关于进程的执行顺序
优先执行序(priority PRI),这个PRI值越低则代表越优先的意思。不过这个PRI值是由内核动态调整的,用户无法
直接调整的PRI值的。由于PRI是内核动态调整的,我们用户也无权去干涉PRI,那如果你想要调整进程的优先执行序
时,就要通过NICE值了！NICE值就是上面的NI。一般来说,PRI与NI的相关性如下:PRI(new)=PRI(old)+nice
nice值的可调整范围:-20~19；
root可随意调整自己与他人进程的Nice值,且范围为-20~19；
一般用户仅可调整自己进程的Nice值,且范围仅为0~19,且仅能越调越高,例本次nice为5,则将来仅能调整大于5；

Nice:新执行的命令即给予新的nice值
nice [-n 数字] command
Renice:已存在进程的nice重新调整
renice [number] PID

系统资源的查看
free:查看内存的使用情况 free [-b|-k|-m|-g] [-t] / -t 在输出的最终结果中显示物理内存与swap的总量
uname:查看统与内核相关信息 uname [-asrmpi] / -a:all -s:系统内核名称 -r:内核版本 -m:系统的硬件名称
uptime:查看系统启动时间与工作负载 
netstat:跟踪网络 netstat -[atunlp] / -a:列出系统上所有连接,监听,Socket等
利用netstat去看看我们的哪些进程有启动哪些网络的"后门"。
dmesg:分析内核产生的信息-系统开机时,内核会去检测系统的硬件,你的某些硬件到底有没有被识别出来就与这个
                         时候的检测有关。
vmstat:检测系统资源变化  vmstat [-a] [延迟[总计检测次数]] <==cpu/内存等信息
		         vmstat [-fs]                     <==内存相关
                         vmstat [-s 单位]                 <==设置显示数据的单位
                         vmstat [-d] / vmstat [-p 分区]   <==与磁盘有关
内存字段(procs)的选项分为r(等待运行中的进程数量)、b(不可唤醒的进程数量)。
内存字段(memory)的选项分为swpd(虚拟内存被使用的量)、free(未被使用的内存容量)、buff(用于缓存储存器)
                          cache(用于高速缓存)。
内存交换空间(swap)的选项可分为si(由磁盘中将程序取出的量)、so(由于内存不足而将没用到的程序写入到磁
                              盘的swap的容量)
磁盘读写(io)的选项分别为bi(由磁盘写入的块数量)、bo(写入到磁盘去的块数量)
系统(system)的项目分别为:in(每秒被中断的进程次数)、cs(每秒钟进行的事切换次数)
CPU的选项分为us(非内核层的cpu使用状态)、sy(内核层的cpu状态)、id(闲置的状态)、wa(等待I/O所耗费的CPU状态)、
             st(被虚拟机所盗用的CPU使用状态)

特殊文件与程序
内存当中的数据都是写入到/proc/*这个目录下，基本上目前主机上面的各个进程的PID都是以目录的类型存在于
/proc当中。举例来说,我们开机所执行的第一个进程init它的PID是1,这个PID的所有相关信息都写入在/proc/1/*当中。

查询已打开文件或已执行程序打开的文件

fuser：通过文件(或文件系统)找出正在使用该文件的程序 / fuser [-umv] [-k [i] [-signal]] file/dir
-u:除了进程的PID之外,同时列出该进程的所有者 / -m:后面接的那些文件名会主动上提到该文件系统的所顶层,对umount不成功很有效
-v:可以列出每个文件与程序还有命令的完整相关性 / -k:找出使用该文件、目录的PID,并试图以SIGKILL这个信号给予该PID
-i:必须与-k配合,在删除PID之前会先询问用户意愿 / -signal:例如-1 -15等,不加的话默认为SIGKILL(-9)
ACCESS选项:  c-此进程在当前的目录下(非子目录)；e-可被触发为执行状态；f-是一个被打开的文件；
             r-代表顶层目录(root directory)；F-该文件被打开了,不过在等待回应中；
             m-可能为分享的动态函数库。

lsof:列出被进程所打开的文件名 / lsof [-aUu] [+d]
-a:多项数据需要"同时成立"才显示出结果时！          -U:仅列出Unix like系统的socket文件系统；
-u:后面接username,列出该用户相关进程所打开的文件； +d:后接目录,即找出某个目录下面已经被打开的文件！
例:仅列出关于root的所有进程打开的socket文件。      析:lsof -u root -a -u

pidof:找出某个正在执行的进程的PID / pidof [-sx] program_name
-s:仅列出一个PID而不列出所有的PID  / -x:同时列出该program name可能的PPID那个进程的PID

SELinux(Security Enhanced Linux)初探
SELinux是整合到内核的一个模块,其实SELinux是在进行程序、文件等权限设置依据的一个内核模块。由于启动
网络服务的也是程序,因此刚好也是能够控制网络服务能否访问系统资源的一道关卡。SELinux使用的是MAC委任
访问设置。

主体如何取得目标的资源访问权限：主体程序必须要通过SELinux策略内的规则放行后,就能与目标资源进行安全
                                上下文的比较,若失败则无法访问目标,成功则可以访问目标。但最终能否访
			        问目标还是与文件系统的rwx权限设置有关。
主体(Subject)也就是进程--要求->SELinux-->安全上下文-->目标(object)数据访问 
                                   |         |                |
                              策略(poliy)   AVC       能否访问最终还是要参考rwx的权限设置
策略:一个文件进程能否读取到目标文件资源的重点在于SELinux的策略以及策略内的各项规则,然后在通过该规则
的定义去处理各目标文件的安全上下文。预设值以_t结尾。

查看安全上下文可使用"ls -Z"（你必须已经启动了SELinux） / 安全上下文是放置到文件的inode内的
安全上下文主要用冒号分为三个字段:Identify(身份识别):role(角色):type(类型)
类型:基本上,一个主体进程能不能读取到这个文件资源与类型字段有关。而类型字段在文件与进程的定义不太相同
     type：在文件资源(Object)上面称为类型(type)；
     domain：在主体程序(Subject)中称为域(domain)；
     domain需要与type搭配,则该程序才能够顺利读取文件资源；

/user/sbin/httpd(http_exec_t)--触发执行->>http domain<<--可读写-->>/var/www/html(http_sys_content_t)
                                           |__>subject，就是httpd进程

http属于http_exec_t这个可执行的类型,而/var/www/html则属于http_sys_content_t这个可以让http域(domail)
读取的类型:
首先,我们触发一个可执行的目标文件,那就是具有httpd_exec_t这个类型的/user/sbin/httpd文件；
该文件的类型会让这个文件所造成的主体进程(subject)具有httpd这个域,我们的策略针对这个域已经制定了许多
规则,其中包括这个域可以读取的目标资源类型；
由于httpd domain被设置为可以读取http_sys_content_t这个类型的目标文件(object),因此你的网页放置到/var/
www/html目录下,就能被httpd那个进程所读取了；
但最终能否读取到正确的数据，还是与文件系统的rwx权限设置有关。

SELinux的启动、关闭与查看
目前SELinux支持三种模式:enforcing-强制模式,代表SELinux正在运行中,且已经正确开始限制domain(域)/type了。
                        permissive-宽容模式,代表SELinux正在运行中,不过仅会有警告信息并不会实际限制domain/type的访问,这种模式可以用来作为SELinux的调试之用。
			disabled-关闭,SELinux并没有实际运行。
查看目前的SELinux模式: getenforce
查看目前的SELinux策略: sestatus [-vb] / -v:检查列于/etc/sestatus.conf内的文件与程序的安全上下文内容
                                        -b:将目前策略的规则布尔值列出,即某些规则(rule)是否要启动(0/1)之意

SELinux的配置文件:/etc/selinux/config
内核有无关闭SELinux配置文件:/boot/grub/menu.lst

SELinux网络服务运行规范
一般服务启动的脚本会在/etc/init.d下面。启动http服务:/etc/init.d/httpd start
首页是放置在/var/www/html,且文件名应该要是"index.html"

重设安全上下文:chcon [-R] [-t type] [-u user] [-r role] 文件
               chcon [-R] --reference=范例文件 文件
-R:连同该目录下子目录也同时修改 / -t:后面接安全上下文的类型字段 / -u:后面接身份识别 / -r:后面接角色
--reference=范例文件:拿某个文件当范例来修改后续接的文件的类型；
例：将index.html类型改为http_sys_content_t类型 ：chcon -t http_sys_content_t /var/www/html/index.html
    以/etc/passwd为依据,将index.html类型改为该类型：chocn --reference=/etc/passwd /var/www/html/index.html

使用默认的安全上下文来还原:restorecon [-Rv] 文件或目录
-R:连同该目录下子目录也同时修改 / -v:将过程显示到屏幕

SELinux所需的服务
setroubleshoot:这个服务会将错误信息与克服方法写入/var/log/messages里面。设置开机启动:chkconfig --list setroubleshoot
               我们linux运行模式是在3或5号,因此这两个设置为on；chkconfig setroubleshoot on。
auditd:将详细数据写入/var/log/audit/audit.log中。设置开机启动:chkconfig --list auditd；chkconfig auditd on。
AVC是access vector cache的缩写,目的是记录所有与SELinux有关的访问统计数据。

SELinux的策略与规则管理
查看策略提供的规则:seinfo [-Atrub]     
查找某进程的安全上下文的类型 seinfo -t|grep subject
-A:列出SELinux的状态,规则布尔值,类型等信息 / -t:列出SELinux的所有类型种类
-r:列出SELinux的所有角色种类 / -u:列出SELinux的所有身份标识种类 / -b:列出所有规则的种类(布尔值)

查看详细的规则:sesearch [-a] [-a 主体类型] [-t 目标类型] [-b 布尔值]
-a:列出该类型或布尔值的所有相关信息 / -t:后面还要接类型 / -b:后面还要接布尔值的规则。
#allow   主体程序安全上下文类型    目标文件安全上下文类型
如上,说明这个类型可以被那个主体程序的类型所读取,以及目标文件资源的格式。

实际的策略数据都是放置在/etc/selinux/targeted/policy/下面，事实上所有与targetd相关的信息都是放置
到/etc/selinux/taegeted里面的呢！包括安全上下文相关的信息。

布尔值的查询与修改
其实,主体(subject)与目标(object)能否有访问的权限是与布尔运算有关的,我们可以通过seinfo -b查询系统有
多少布尔值，但每个布尔值是启动还是关闭可以使用:
getsebool [-a] [布尔值条款] / -a:列出目前系统上面的所有布尔值条款设置为开启或关闭值。
setsebool [-P] 布尔值=[0|1] / -P:直接将设置值写入配置文件,该设置数据将来会生效的。

默认目录的安全上下文查询与修改
semanage {login|user|port|interface|fcontext|translation} -l
semanage fcontext -{a|d|m} [-frst] file_spec
fcontext:主要用在安全上下文方面的用途,-l为查询的意思。 /  -m:修改的意思。 /  -d:删除的意思。
-a:增加的意思,你可以增加一些目录的默认安全上下文类型设置

***********************************第18章 认识系统服务daemons******************************************
service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。

实现循环型例行工作调度服务(service)的程序为crond这个daemon。你不比区分什么是daemon与service,事实上,
你可以将这两者视为相同！因为达成某个服务是需要一个daemon在后台运行,没有这个daemon就不会有service。

xinetd（extended internet daemon）
linux有许多网络服务,是通过xinetd进行总体管理的,比如说大名鼎鼎的telnet服务,就是通过xinetd进行管理的。
就是说,这个服务,用来管理多个小型的网络服务。但是,由于采用这种统一管理的方式,导致了效率的降低,所以现
在的大型网络服务都是自己管理自己,比如httpd等。所以说，xinetd有一些过时了,但是经典的网络服务还是需要由它进行统一管理的。

daemon的分类:
①以启动与管理方式区分:
stand_alone  此daemon可以自行单独启动服务,常见的stand_alone daemon有WWW的deamon(http)、FTP的daemon(vsftpd)等。
super daemon 一个特殊的daemon来统一管理,常见的super daemon有xinetd。
             Client-PI请求->Super daemon-触发->Program-载入->Daemon
                      |_______________提高连线_________________↑
             super daemon又可以分为multi-threaded(多线程),single-threaded(单线程)。
②以工作类型区分:
signal-control:这种daemon通过信号来管理,只要有任何客户端的请求进来,它就会立即启动去处理。
interval-control:这种daemon主要是每隔一段时间就主动执行某项工作,所以你要做的是在配置文件指定服务的
 		 名称被创建后,被挂上Linux使用时,通常在服务的名称之后会加上一个d,例如例行性命令的新
                 建的at与cron这两个服务,它的程序文件名会被取为atd与crond,这个d代表的就是daemon的意思。
                                ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

服务与端口对应
系统上面让服务与端口号对应的设置/etc/services。第一列为daemon的名称,第二列为该daemon所使用的端口号
与网络数据包协议,数据包协议主要为可靠连接的TCP数据包以及较快速但为非面向连接的UDP数据包。

/etc/init.d/* :启动脚本放置处           /etc/init.d/服务文件名{start,stop}服务的启动
/etc/sysconfig/* :各服务的初始化环境配置文件
/etc/xinetd.conf,/etc/xinetd.d/* :super daemon配置文件
/etc/* :各服务各自的配置文件
/var/lib/* :各服务产生的数据库
/var/run/* :各服务的程序的PID记录处

service [service name] (start|stop|restart|...) / service --status-all
service name:需要启动的服务名称,需与/etc/init.c对应；
--status-all:将系统所有的stand alone的服务状态全部列出来；

解析super daemon的配置文件
前面我们知道super daemon是一个总管进程,这个super daemon是xinetd这一个进程所实现的。而且由前面的图示
我们知道这个xinetd可以进行安全性或者是其他管理机制的控制,也能够控制连接的行为。由于super daemon可以
做这样的管理,因此一些对客户端开放较多权限的服务或者本身不具有管理机制或防火墙机制的服务就可以通过
xinetd来管理。

默认值配置文件:xinetd.conf
socket_type数据包类型:stream为连接机制较为可靠的TCP数据包,若为UDP数据包则使用dgram机制,raw代表server
                      需要与IP直接互换。

我们知道通过super daemon管理的服务可以多一层管理的手续来达成类似防火墙的机制,那么该如何设置这些类似
防火墙机制的设置参数呢？我们可以使用rsync进行远程镜像(mirror)的服务来说明。rsync可以让两部主机上面
的某个目录一模一样,在远程异地备份系统上面是挺好用的一个机制。

默认的rsync配置文件/etc/xinetd.d/rsync
由于/etc/services当中规定rsync使用的端口号码为873,这个端口小于1024,所以理论上启动这个端口的身份一定
是root才行！

服务的防火墙管理xinetd,TCP Wrappers套件
防火墙分析主要可以通过数据包过滤或者是通过软件分析。
管理某些进程能否接受或者拒绝来自因特网的连接的配置文件:/etc/hosts.deny和/etc/hosts.allow。
其实我们修改/etc/xinetd.d/rsync也可以进行防火墙设置,不过使用/etc/hosts.deny和/etc/hosts.allow则更容易
集中管理,在设置与查询方面也较为方便！

其实/etc/hosts.deny和/etc/hosts.allow也是/etc/sbin/tcpd的配置文件,而这个文件则是用来分析进入系统的
TCP网络数据包的一个软件,TCP是一种面向连接的网络连接数据包,包括www,email,ftp等都是使用TCP数据包来实现
连接的。所以顾名思义,这个套件本身的功能就是分析TCP数据包。而TCP数据包的文件头主要记录了来源与目的主机
的IP与port,因此通过分析TCP数据包并搭配/etc/host.{allow,deny}的规则比较,就可以决定该连接是否能够进入我
们的主机。

/etc/hosts.{allow，deny}
写在hosts.allow当中的IP与网段则默认为deny,第三列的allow也可省略。而写在hosts.deny当中的IP与网段则默
认为deny,第三列的deny可省略。通常我们允许进入的写在/etc/hosts.allow当中,不允许进入的写在/etc/hosts.deny

查询某个程序动态函数库支持状态: ldd $ (which 程序 程序 ..)

TCP Wrappers特殊功能
spawn(action):可以利用后续的shell来进行额外的工作,且具有变量功能,主要的变量内容有:%h(hostname),%a(address)
              %d(daemon)等。
twist(action):立即以后续的命令进行,且执行完后终止该次连接的请求(DENY)

查看系统开启的服务
netstat -tulp 找出目前系统开启的网络服务  netstat -lnp 找出所有的有监听网络的服务
service --status-all 查看所有的服务状态

设置开机后立即启动服务的方法
chkconfig:管理系统服务默认开机启动与否
chkconfig --list [服务名称] / chkconfig [--level [012356]] [服务名称] [on|off]
--list:仅将目前的各项服务状态栏显示出来  --level:设置某个服务在该level下启动或关闭
chkconfig:设置自己的系统服务
chkconfig [--add|--del] [服务名称] / --add:增加一个服务名称给chkconfig来管理,该服务名称必须在/etc/init.d/内
chkconfig: [runlevel][启动顺序][停止顺序]


使用stand alone的启动方式查看program目前是否启动:/etc/init.d/program status
使用super daemon的管理方式查看program目前是否启动:netstat -tlup | grep program

ntsysv:类图形界面管理模式 / ntsysv [--level <levels>]   

*************************************第19章 认识与分析日志文件*********************************************

Linux常见的日志文件名
/var/log/cron:记录关于crontab例行性调度的各项信息。
/var/log/dmesg:记录系统在开机的时候内核检测过程所参数的各项信息。
/var/log/lastlog:记录系统上面所有的账号最近一次登录系统时的相关信息。
/var/log/maillog或/var/log/mail/*:记录邮件的往来信息。
/var/log/messages:记录系统发生的错误信息(或者重要信息)。
/var/log/secure:记录账号密码等登录信息。
/var/log/wtmp或/var/log/faillog:记录正确登录系统者的账户信息与错误登录时所使用的账户信息。
/var/log/httpd/*或/var/log/new/*或/var/log/samba/*:个别服务所指定的日志文件。

日志文件所需相关服务(daemon)与进程

①syslogd:主要登录系统与网络等服务的信息。syslogd针对各种服务与信息记录在某些文件的配置文件就是
           /etc/syslogconf,里面规定了什么服务的什么等级信息以及需要被记录在哪里(设备或文件)。  
          服务名称[.=!]信息登记 信息记录的文件名或设备或主机 
          " ."代表比后面还要高的等级(含该等级)都被记录下来,例如mail.info代表只要mail的信息,而该信息
               等级高于info时,就会被记录下来的意思。
          ".="代表所需要的等级就是后面接的等级而已 ".!"代表不等于,即除了该等级外的其他等级都记录                            
②klogd:主要登录内核参数的各项信息；
③logrotate:主要进行日志文件的轮替功能。syslog利用的是daemon的方式来启动的,当有需求的时候就会立即执行
            但是logrotate却是在规定的时间到了之后才来进行日志文件的轮替,所以这个logrotate程序当然就是
            挂在cron下面进行的。仔细看一下/etc/cron.daily/里面的文件,/etc/cron.daily/logrotate就是记录
            了每天要进行的日志文件轮替的行为。
logrotate的配置文件:/etc/logrotate.conf /etc/logrotate.d/
prerotate:在启动logrotate之前进行的命令,例如修改日志文件的属性等操作；
postrotate:在做完logrotate之后启动的命令,例如重新启动(kill-HUP)某个服务；
logrotate [-vf] logfile / -v启动显示模式,会显示logrotate运行的过程  -f不论是否符合配置文件的数据,强制每个日志文件都进行rotate的操作

日志文件的安全性设置 / 日志服务器的设置 
syslog的日志文件只要"被编辑过"就无法继续记录,如果用vim打开了日志文件并且用":wq"退出导致日志文件不能
记录的问题,需要重启syslog让他继续提供服务/etc/init.d/syslog restart

***********************************第20章 启动流程、模块管理与Loader*************************************
启动过程:
1.加载BIOS的硬件信息与进行自我测试,并依据设置取得第一个可启动的设备；
2.读取并执行第一个启动设备内的MBR的boot Loader(即是grub,spfdisk等程序)；
3.依据boot loader的设置加载kernel,Kernel会开始检测硬件与加载驱动程序；
4.在硬件驱动成功后,kernel会主动调用init进程,而init会取得run-level信息；
5.init执行/etc/rc.d/rc.sysinit文件来准备软件执行的操作环境(如网络、时区等)；
6.init执行run-level的各个服务的启动(script方式)；
7.init执行/etc/rc.d/rc.local文件；
8.init执行终端机模拟程序mingetty来启动login进程,最后就等待用户登录；

内核模块放置在/lib/modules目录内
虚拟文件系统(InitialRAM Disk)一般使用的文件名为/boot/initrd,这个文件的特点是,它可能够通过boot loader
来加载内存中,而且这个文件会被解压缩并且在内存当中仿真成一个根目录,且此仿真在内存当中的文件系统能够提
供一个可执行的程序,通过该程序来加载启动过程中所需要的内核模块,通常这些模块就是USB,RAID,LVM,SCSI等文件
系统与磁盘接口的驱动程序。

ls --format=single-column -F /boot 查看内核文件

第一个进程init及配置文件/etc/inittab与/runlevel
/sbin/init最主要的功能就是准备软件执行的环境,包括系统的主机名,网络设置,语系处理,文件系统格式及其他服务的
启动等。而所有的操作都会通过init的配置文件/etc/inittab来规划,而inittab内还有一个很重要的设置选项,那就是
默认的run level。

run level ：执行等级                             <=================================================
0-halt(系统直接关机) / 1-single user mode(单用户维护模式) / 2-Multi-user,without NFS(与3类似,但无NFS)
3-Full multi-user mode(完整含有网络功能的纯文本模式) / 4-unuser(系统保留功能)
5-X11(与3类似,但加载使用X windows) / 6-reboot(重新启动)

/etc/inittab  [设置选项]:[run level]:[init的操作模式]:[命令选项]
Run level的查看与切换 - 查看:runlevel 切换:init [level]

init的处理系统初始化流程(/etc/rc.d/rc.sysinit）
在不同的distribution当中都不相同,最好自行到/etc/inittab去查看一下系统的工作。
用户自定义模块的加载:/etc/sysconfig/modules/*.modules
加载内核的相关设置:/etc/sysctl.conf       初始化软件磁盘阵列:/etc/mdadm.conf
如果你想要知道到底启动过程中发生了什么事,那么就执行"dmesg"吧。

启动系统服务与相关启动配置文件(/etc/rc.d/rc.N & /etc/sysconfig)
/etc/rc.d/rc[0-6].d里面有Sxxname与Kxxname可以设定开机启动和关机启动时事项。

用户自定义开机启动程序(/etc/rc.d/rc.local)
启动过程会用到的主要配置文件:
1.启动过程会用到的配置文件大多放置在/etc/sysconfig/目录下
2.由于内核还需要加载一些驱动程序(内核模块),此时系统自定义的设备与模块对应文件/etc/modprobe.conf就显得
  十分重要了。

关于模块:/etc/modprobe.conf 这个文件大多在于指定系统内的硬件所使用的模块。

/etc/sysconfig/* 启动过程中,服务的配置文件,其中包括-
1.authconfig这个文件主要设置用户的身份认证的机制,包括是否使用本机的/etc/passwd,/etc/shadow等,以及/etc/shadow
密码记录使用何种加密算法,还有是否使用外部密码服务器提供的账号验证等。
2.clock文件用于设置Linux主机的时区,在clock文件内的设置选项"ZONE"所参考的时区位于/user/share/zoneinfo
目录下的相对路径中,而且要修改时区的话,还得将/user/share/zoneinfo/Asia/shanghai这个文件复制成为/ert/localtime
i18n用于设置一些语系的使用方面 / keyboard & mouse用于设置键盘和鼠标的形式。
3.i18n用于设置一些语系的使用方面。

Run level的切换
事实上,与run level有关的启动其实是在/etc/rc.d/rc.sysinit执行完毕后。也就是说,其实run level的不同仅是
/etc/rc[0-6].d里面启动的服务不同而已。不过依据启动是否进入不同run level的设置,我们可以说:
1.要每次启动都执行某个默认的run level,则需要修改/etc/inittab内的设置选项,即是"id:5:initdefault:"里头的数字
2.如果仅只是暂时更改系统的run level时,则使用init[0-6]来进行run level的更改,但下次重新启动时,依然会是以
  /etc/inittab的设置为准。

内核(kernel)与内核模块
内核:/boot/vmlinuz或/boot/vmlinuz-version；  内核解压所需RAMDisk:/boot/initrd(/boot/initrd-version)；
内核模块:/lib/modules/version/kernel或/lib/modules/$(uname-r)/kernel；
内核源码:/user/src/linux或/user/src/kernels(需安装才有！默认不安装)；   内核版本:/proc/version
系统内核功能/proc/sys/kernel； 内核模块依赖性:/lib/modules/$(uname-r)/modules.dep

内核模块里面主要还分了几个目录:
1.arch：  与硬件平台有关的选项,例如CPU的等级等；
2.crypto：内核所支持的加密的技术.例如md5或者是des等；
3.drivers：一些硬件的驱动程序,例如显卡,网卡,PCI相关硬件；
4.fs：    内核所支持的文件系统,例如vfat,reiserfs,nfs等；
5.lib:    一些函数库；
6.net:   与网络有关的各项协议数据,还有防火墙模块(net/ipv4/netfilter/*)等；
7.aound：与音效有关的各项模块；

内核模块依赖性文件的创建:
depmod [-Ane] / -A:不加任何参数时,depmod会主动去分析目前内核的模块,并重新写入/lib/modules/$(uname-r)/modules.dep
                   若加入-A参数时,则depmod会查找比modules.dep还要新的模块,如果真找到新模块,才更新。
                -n:不写入modules.dep,而是将结果输出到屏幕上；   -e:显示出目前已加载的不可执行的模块名称
例:若我做好一个网卡驱动程序,文件名为a.ko,该如何更新内核依赖性？
   # cp a.ko /lib/modules/$(uname -r)/kernel/drivers/net
   # depmod

内核模块的查看 ：lsmod
显示内容: 模块名称(Module)  此模块是否被其他模块所使用(user by) 
modinfo [-adln] [module_name|filename] ：查询模块信息
-a:仅列出作者名称 | -d:仅列出该module的说明 | -l:仅列出授权 | -n:仅列出该模块的详细路径

内核模块的加载与删除:
 模块无依赖性加载与删除： 
 insmod [/full/path/module_name] [parameters] 后面接的模块必须是完整的"文件名":/lib/modules/$(uname-r)/kernel/..
 rmmod [-fw] module_name  -f:强制将该模块删掉,不论是否正被使用 / -w:若该模块正被使用,使用完毕后删除
 模块有依赖性加载与删除：
 modprobe [-lcfr] module_name  -c:列出目前系统所有的模块 / -l:列出目前在/lib/modules/`uname -r`/kernel当中的所有模块完整文件名
                               -f:强制加载该模块 / -r:删除某个模块
 modprobe会主动去查找modules.dep的内容,先克服依赖性后,才决定需要加载的模块有哪些,很方便。

内核模块的额外参数设置:/etc/modprobe.conf

目前主流的Boot loader：Grub
grub的配置文件/boot/grub/menu.lst与菜单类型
(hd0,0) 代表 第一块查找到的硬盘代号0的第一个分区代号0；
编写内核文件位置 / 扇区(boot sector)

/boot/grub/menu.lst配置文件
title以前的四行都是属于grub的整体设置,包括默认的等待时间与默认的启动选项,还有显示的界面特征等。
1.default=0 代表使用第一个启动菜单(title)选项来启动。
2.timeout=5 如果在5秒内没有按下任何按键,就会使用上面提到的default后面接的那个title选项来启动。
3.splashimage=(hd0,0)/grub/splash.xpm.gz 代表的是(hd0,0)这个分区内的最顶层目录下的grub/splash.xpm.gz那个文件
4.hiddenmenu 这个说的是启动时是否要显示菜单。

title CentOS （2.6.18-92e15） <==第一个菜单的内容
其中root、kernel、initrd后面接的内容的含义:
root:代表的是内核文件放置的那个分区,而不是根目录。
kernel:后面接的则是内核的文件名,而在文件名后面接的则是内核的参数。由于启动过程中需要挂载根目录,因此
       kernel后面接的那个root=LABEL=/1指的是Linux的根目录在哪个分区的意思。至于rhgb是色彩显示而quiet
       则是安静模式(屏幕不会输出内核检测的信息)。
initrd:就是initrd制作出RAM Disk的文件名。

利用chain loader的方式转交控制权
menu.lst内设置loader控制权移交时,最重要的为chainloader+1这个选项。

initrd的重要性与创建新initrd文件
initrd的目的在于提供启动过程中所需要的最重要内核模块，以让系统启动过程可以顺利完成。会需要initrd的
原因是因为内核模块放置于/lib/modules/$(uname -r)/kernel/当中，这些模块必须要根目录(/)被挂载时才能被
读取。但如果内核本身不具备磁盘的驱动程序时,当然无法挂载根目录,也就无法取得驱动程序,通过initrd可以将
/lib/modules/..内的启动过程中一定需要的模块打包,然后启动时通过主机的INT13硬件功能将文件读出来,并且
initrd在内存内会仿真成为根目录,由于此虚拟文件系统(Initial RAM Disk)主要包含磁盘与文件系统的模块,因此
我们的内核最后就能够认识实际的磁盘,那就能进行实际根目录的挂载。
一般来说.需要initrd的时刻: 根目录所在磁盘为SATA、USB或SCSI等连接接口；
                           根目录所在文件系统为LVM、RAID等特殊格式；
			   根目录所在文件系统为非传统Linux"认识"的文件系统时；
                           其他必须要在内核加载时提供的模块；
mkinitrd [-v] [--with=模块名称] initrd文件名 内核版本                   <-- 重制initrd文件
mkinitrd -v/boot/initrd-2.6.30.3vbird.img  2.6.30.3vbird

测试与安装grub
grub-install[--root-directory=DIR] INSTALL_DEVICE
--root-directory=DIR 那个DIR为实际的目录,使用grub-install默认会将grub所有的文件复制到/boot/grub/*,
如果想要复制到其他目录与设备去,就要使用这个参数。
INSTALL_DEVICE 安装的设备代号

如果是从其他boot loader转成grub，得先使用grub-install安装grub配置文件，接着开始编辑menu.lst这个重要
的配置文件，最后通过grub来将主程序安装到系统中，如MBR的(hd0)或boot sector的(hd0,0)等。
grub shell:更多信息可以info grub查阅
 1.用root(hdx.x)选择含有grub目录的那个分区代号；
 2.用"find/boot/grub/stage1"看看能否找到安装信息文件；
 3.用"find/boot/vmlinuz"看看能否找到内核文件l； 
 4.用"setup(hdx.x)"或者"setup (hdx)"将grub安装在boot sector或MBR中；
 5.用"quit"离开grub shell；

启动前的额外功能修改
调整终端机分辨率:前提:支持FRAMEBUFFER_CONSOLE这个内核参数 grep ‘FRAMEBUFFER_CONSOLE’/boot/config-2.6.18-92.e15

BIOS无法读取大硬盘的问题:BIOS无法读取大容量硬盘内的kernel与initrd文件。
                         解决办法:由于DIOS至少可以读到大磁盘的1024柱面的数据,将kernel与initrd文件放置
                          	  在大硬盘的最前头就能读取内核与虚拟文件系统的文件。
为某个菜单加上密码:grub-md5-crypt将密码转换为md5编码

启动过程的问题解决:进入runlevel 1(单用户维护模式/救援模式)
忘记root密码:重新启动,启动进入grub菜单后,在你要进入的菜单上面点e进入详细设置,将鼠标移动到kernel上方
             并点e进入编辑界面，在grub edit这行最后加上single,然后按下enter后再按下b就能够启动进入单
             用户维护模式,进入单用户维护模式后,系统会以root的权限直接给你一个shell,此时你就能执行Passwd
             命令来重建root密码,然后直接执行init 5就可以切换成为X窗口界面。
init配置文件错误:重新启动,启动进入grub菜单后,在你要进入的菜单上面点e进入详细设置,将鼠标移动到kernel上方
                 并点e进入编辑界面，在grub edit这行最后加上init=/bin/bash。
BIOS磁盘对应的问题(device.map)
因文件系统错误而无法启动
利用chroot切换到另一块硬盘工作：可以暂时将根目录移动到某个目录下,然后去处理某个问题,最后在离开该root
                                而回到原本的系统当中。

**********************************第21章 系统设置工具与硬件检测*********************************************

centos系统设置工具:setup
用户身份验证设置：Authentication configuration
网络配置选项(手动设置IP与自动获取) / 防火墙设置(Firewall configuration) / 键盘形式设置(Keyboard configuration)
系统时钟的时区设置(Timezone configuration) / X窗口界面分辨率设置(X configuration)
利用CUPS设置Linux打印机:当启动IPP时,打印机会启动port631. 浏览器地址栏输入http://localhost:631
nmap是个可以扫描主机端口的软件(port scan)
手动设置打印机:/etc/cups/printers.conf 打印机的设置值文件
               /etc/cups/cupsd.conf CPUS的主要配置文件,包括作为服务器用途的设置
               /etc/cups/ppd/*.ppd 打印机的驱动程序(PPD配置文件)
使用Ipadmin进行打印机的新建与删除及打印机状态的查看
lpadmin [-p 自定义队列名] [-v URI] [-m PPD] [-E] <==建立打印机
lpadmin [-d 已存在的队列名] <==设置成为默认打印机 / lpadmin [-x 已存在的队列名] <==删除此一打印机队列  
lpatat [-adprt]
利用lpr与lp来产生打印操作
lpr [-p printer 队列] [-# 打印份数] -U [username] file
打印作业的查看(lpq)与删除(lprm)
lpr [-al] [-P 打印队列] / lprm [-P printer队列] job id

硬件数据收集与驱动及Im_sensors
lspci:列出整个PC系统的PCI接口设备！ lspci [-vvn]   
lsusb:列出目前系统上面各个USB端口的状态与连接的USB设备； lsusb [-t]  
iostat:列出整个CPU与接口设备的I/O状态； iostat [-c|-d] [-k|-m] [-t] [间隔秒数] [检测次数]
/user/share/hwdata/pci.ids:PCI标准ID与品牌名称的对应表

驱动USB设备 / 使用Im_sensors取得温度、电压等信息:sensors_detect与sensors命令
udev与hal简介

IP地址（ipv4）是由网络地址+主机地址组成，四段每段八位共32位（二进制），网络地址到哪一位，由掩码告诉你
(网络中的某台计算机)(这就是掩码的作用),后面的叫主机位。当主机位全为0时，它是一个不可用的IP地址(网络中
的计算机不能以此作为身份识别），通常用它来表示网络号，即一个网段。也就是这个网段的“最小”IP地址。主机
位全为1时，也是一个不可用的IP地址（不特指哪一台计算机，而是大家）,就是这个网段的“最大”IP地址叫直接广
播地址，可以穿过路由器。
给你一个（含掩码的）IP地址149.88.160.58/18，你就知道该地址的网络号与主机位各是多少。
掩码是18，那前18位都是网络号，那149与88都可以不管它，只管160就行了。
160换成二进制是：10100000。掩码是18位，这是第三段，所以左边两位即1和0属于网络地址位，不能动，你求网络号
把这两位后面的全改成0就OK了，即10000000，即128，第四段当然也全是0，所以网络号是：149.88.128.0/18，广播
地址就是把这两位以后的全改成1就成了，160换成二进制是：10100000，左两位不能动，后面的改成1，即10111111，
即191，第四段也全改为1，即255，所以广播地址是：149.88.191.255/18，注：这是直接广播地址。

**************************************第22章 软件安装:源码与Tarball*******************************************

查看是否文件为二进制：file 文件目录
如果是二进制程序而且可以执行的时候,它就会显示可执行文件类(ELF 32-bit LSB executable),同时会说明是否使用
共享库(shared libs),而如果是一般的script,那它就会显示出text executables 之类的字样。

开放源码:就是程序代码,写给人类看的程序语言,但机器并不认识,所以无法执行；
编译程序:将程序代码转译成为机器看得懂的语言；
可执行文件:经过编译程序变成二进制程序后机器看得懂所以可以执行的文件；

1.什么是函数库
2.什么是make与configure:当执行make时,make会在当前的目录下搜索Makefile这个文本文件,而Makefile里面则记录了
  源码如何编译的详细信息。make会自动判别源码是否经过变动了而自动更新执行文件。
  通常软件开发商都会写一个检测程序来检测用户的操作环境,以及该操作环境是否有软件开发商所需要的其他功能,
  该检测程序检测完毕后,就会主动新建这个Makefile的规则文件。通常这个检测程序的文件名为configure或config。
  执行configure来新建Makefile,成功之后再以make来调用所需要的数据来编译即可。
3.什么是Tarball的软件:所谓的Tarball文件,其实就是将软件的所有源码文件先以tar打包,然后再以压缩技术来压缩。
                      所以tarball文件一般的扩展名就会写成*.tar.gz或者*.tgz。
4.如何安装与升级软件: 1.将Tarball由厂商的网页下载下来。
		 2.将Tarball解压缩,生成很多的源码文件。
                      	 3.开始以gcc进行源码的编译(会生成目标文件)。
		 4.然后以gcc进行函数库、主程序、子程序的链接,以形成主要的二进制文件。
                                 5.将上诉的二进制文件以相关的配置文件安装至自己的主机上面。

使用传统程序语言进行编译的简单范例
1.在默认的状态下,如果我们直接以gcc编译源码,并且没有加上任何参数,则执行文件的文件名会被自动设置为a.out
  这个文件名,所以你就能直接执行./a.out这个执行文件。如果我想要产生目标文件(object file)来进行其他的操作
  而且执行文件的文件名也不要默认的a.out呢？

2.主程序、子程序链接:子程序的编译 
  为什么要制作目标文件:由于我们的源码文件有时并非仅只有一个文件(需要调用其他文件内容),所以我们无法直接
  进行编译,这时候就需要先生成目标文件,然后再以链接制作成二进制可执行文件。
  链接目标文件:gcc -o 生成的执行文件名称 目标文件1.o  目标文件2.o
  如果有一天,你更新了文件1的文件内容,则你只需要重新编译文件1来产生新的目标文件1,然后再以链接制作成新的
  二进制可执行文件即可,而不必重新编译其他没有改动过的源码文件。

3.调用外部函数库:加入链接的函数库
  编译时加入额外函数库链接的方式：gcc 执行文件 -l -L/path
   例1:gcc sin.c -lm -L/lib -L/user/lib；-l:是加入某个函数库的意思 m:则是libm.so这个函数库,所以-lm表示使用
      libm.so(或libm.a)这个函数库的意思。至于-L后面接的路径表示我要的函数库libm.so请到/lib或/user/lib里面搜索。
  定义要读取的include文件放置的目录:gcc 执行文件 -l -I/path
   例2:gcc sin.c -lm -I/user/include
  -I/path 后面接的路径就是设置要去搜索相关的include文件的目录，默认放置在/user/include下面。  
  
  即-L后面接的路径是函数库的搜索目录,-I后面接的是源码内的include文件的所在目录；

gcc的简易用法(编译、参数与链接)
#仅将源码编译成为目标文件，并不制作链接等功能:gcc -c hello.c
#在编译的时候,依据操作环境给予优化执行速度:gcc -O hello.c -c
#在进行二进制文件制作时,将链接的函数库与相关路径填入:gcc sin.c -lm -L/user/lib -I/user/include
#将编译结果输出成某个特定文件名:gcc -o hello hello.c
#在编译的时候,输出较多的信息说明:gcc -o hello hello.c -Wall

用Make进行宏编译：make的功能是简化编译过程里面执行的命令，同时还具有很多很方便的功能。
1.先编辑makefile这个规则文件,内容只要制作出main这个可执行文件；
  vim makefile
  main: main.o haha.o sin.o cos.o
  	gcc -o main main.o haha.o sin.o cos.o -lm
2.尝试使用makefile制作的规则进行编译的行为；
  make main
makefile的基本语法与变量
  目标(target): 目标文件1 目标文件2
  <tab>	   gcc -o 欲新建的可执行文件 目标文件1 目标文件2    #命令行必须要以tab按键作为开头才行！ 

执行输入命令: main 目标
用变量简化makefile: 1.变量与变量内容以"="隔开,同时两边可以具有空格；
		    2.变量左边不可以有<tab>；            3.变量与变量内容在"="两边不能具有":"；
                    4.在习惯上,变量最好以大写字母为主；  5.运用变量时,以${变量}或$(变量)使用；
                    6.在该shell的环境变量是可以被套用的；7.在命令行模式也可以定义变量；
环境变量取用的规则是这样的:1.make命令行后面加上的环境变量为第一优先；
                                          2.makefile里面指定的环境变量为第二优先；
 		          3.shell原本具有的环境变量为第三优先；
$@：代表目前的目标(target)

Tarball的管理与建议
Tarball的安装时可以跨平台的,因为C语言的程序代码在各个平台上面是可以互通的,只是需要的编译程序可能并不相同
而已。
Tarball安装的基本步骤
1.取得源文件:将tarball文件在/user/local/src目录下解压缩；
2.取得步骤流程:进入新建立的目录下,去查阅INSTALL与README等相关帮助文件内容(很重要的步骤)；
3.相关属性软件安装:根据INSTALL/README的内容查看并安装好一些相关的软件(非必要)；
4.建立makefile:以自动检测程序(configure或config)检测操作环境,并建立Makefile这个文件；
5.编译:以make这个程序并使用该目录下的Makefile作为它的配置文件,来进行make(编译或其他)的操作；
6.安装:以make这个程序,并以Makefile这个配置文件,依据install这个目标(target)的指定来安装到正确的路径；

大部分的tarball软件安装的命令执行方式:
1. ./configure configure检测程序找到所需函数库、编译器及其他资料,并主动建立Makefile这个文件(厂商会写入到tarball)。
               检查configure支持的参数 ./configure --help | more <==查询可用的参数有哪些
2. makeclean   去除目标文件(主要去除上次编译过的目标文件*.o)。
3. make        依据Makefile当中的默认工作进行编译的行为。编译的工作主要是进行gcc来将源码编译成为可以被
               执行的目标文件,但是这些目标文件通常还需要一些函数库之类的链接后,才能生成一个完整的可执行
               文件！使用make就是将源码编译成为可以被执行的可执行文件,而这个文件会放置在目前所在的目录
               下,尚未被安装到预定安装的目录中。
4. make install通常这就是最后的安装步骤,make会依据Makefile这个文件里面关于install的选项,将上一个步骤所
               编译完成的数据安装到默认的目录中,就完成安装！
如果安装成功,并且是安装在独立的一个目录中,那么你就必须手动将这个软件的man page写入/etc/man.config

一般Tarball软件安装的注意事项(如何删除、升级)
基本上,在默认的情况下,原本的Linux distribution发布安装的软件大多是在/user里面的,而用户自行安装的软件则
建议放置在/user/local里面,这是考虑到管理用户所安装软件的便利性。因为每个软件都会提供在线帮助的服务,那就
是info与man的功能。在默认的情况下,man会去搜索/user/local/man里面的说明文件,因此如果我们将软件安装在/user/local
下面的话,那么自然安装完成之后,该软件的说明文件就可以被找到了。
为了方便Tarball的管理,通常鸟哥会这样建立用户:
1.最好将tarball的原始数据解压缩到/user/local/src当中；
2.安装时,最好安装到/user/local这个默认的路径下；
3.考虑将来的反安装步骤,最好可以将每个程序单独安装在/user/local下面；
4.为安装到单独目录的软件的man page加入man path搜索(/etc/man.config)；
例:如果你安装的软件放置到/user/local/software/中,那么在man page搜索的设置中可能就要在/etc/man.config内
   写上一行: MAN PATH /user/local/software/man

利用patch更新源码
patch的基本语法: patch -p 数字 < patch_file 
                 -p xx那个数字代表拿掉几个斜线(/)的意思！

函数库管理
1.动态与静态函数库： 
  A:静态函数库的特色-扩展名(为.a),这类的函数库通常拓展名为libxxx.a类型；
                     编译行为,这类函数库编译的时候会直接整合到执行程序当中,所以利用静态函数库编译的文件
                              会比较大一些；
     		     独立执行的状态,这类函数最大的优点就是编译成功的可执行文件可以独立执行,而不需要再向
                                    外部要求读取函数库的内容。
                     升级难易度,因为函数库是直接整合到可执行文件中,因此若函数库升级时,整个可执行文件必须
                                要重新编译才能将新版的函数库整合到程序当中。也就是说,在升级方面,只要函数库
                                升级了,所有将此函数库纳入的程序都需要重新编译。 
 B:动态函数库的特殊-扩展名(为.so),这类的函数库通常拓展名为libxxx.so类型；
       		    编译行为,与静态函数库被整个捕捉到程序中不同,动态函数库在编译的时候,在程序里面只有一个
                             "指向"(Pointer)的位置而已。也就是说,动态函数库的内容并没有整合到可执行文件
                              当中,而是当可执行文件要使用到函数库的机制时,程序才会去读取函数库来使用。
                    独立执行的状态,这类型的函数库所编译出来的程序不能被独立执行,因为当我们使用到函数库的
                                   机制时,程序才会去读取函数库,所以函数库必须要存在才行,而且,函数库的所在
                                   目录也不能改变,因为我们的可执行文件里面仅有"指标",亦即当要取用该函数库
                                   时,程序会主动去某个路径下读取,所以函数库可不能随意移动与删除,会影响很多
                                   相关的程序软件。
                    升级难易度,虽然类型的可执行文件无法独立运行,然而由于具有指向的功能,所以,当函数库升级
                               后,可以执行文件根本不需要重新编译的行为,可执行文件会直接指向新的函数库文件
                               当然,前提是函数库新旧版本的文件名相同。
绝大多数的函数库放置在/user/lib,lib目录,此外,linux系统里面很多的函数库其实kernel就提供了,并存放在/lib/modules里面。
2.ldconfig与/etc/ld.so.conf:
  增强函数库的读取性能:我们知道内存访问速度是硬盘的好几倍,所以,如果我们将常用到的动态函数库先加载内存当中
                       (缓存,cache),如此一来,当软件要使用动态函数库时,就不需要从头由硬盘里面读出了,这样不就增进动态函数库的读取速度了！
                       这时候就需要ldconfig与/etc/ld.so.conf的协助了。
  如何将动态函数库加载高速缓存当中呢？
  1.首先,我们必须要在/etc/ld.so.conf里面写下想要读入高速缓存当中的动态函数库所在的目录,注意是目录而不是文件；
  2.接下来则是利用ldconfig这个可执行文件将/etc/ld.so.conf的数据读入缓存当中。
  3.同时也将数据记录一份在/etc/ld.so.cache这个文件当中。
  ldconfig [-f conf] [-C cache] / ldconfig [-p]
  -f conf:那个conf指的是某个文件名,也就是说,使用conf作为libarary函数库的取得路径,而不以/etc/ld.so.conf为默认值；
  -C cache:那个cache指的是某个文件名,也就是说,使用cache作为缓存暂存的函数库资料,而不以/etc/ld.so.conf为默认值；
  -p:列出目前的所有函数库数据内容(/etc/ld.so.conf内的数据)；
3.程序的动态函数库解析: ldd
  ldd [-vdr] [filename] / -v:列出所有内容信息 -d:重新将数据有丢失的link点显示出来 -r:将ELF有关的错误内容显示出来

检验软件的正确性
镜像文件、MD5指纹编码、SHA1指纹编码 
md5sum/sha1sum [bct] filename                        
md5sum/sha1sum [--status|--warn] --check filename
-b:使用二进制的读取方式,默认为windows/Dos文件类型的读取方式 / -c:检验文件指纹 / -t:以文件类型来读取文件指纹
基本上,你必须要在你的Linux系统上为你的重要的文件进行指纹数据库的创建,将这些文件新建数据库:
/etc/passwd , /etc/shadow , /etc/group , /user/bin/passwd , /sbin/portmap , /bin/login , /bin/ls , /bin/ps , /user/bin/top
如果你可以为这些文件新建指纹数据库(就是使用md5sum检查一次,将该文件指纹记录下来,然后经常以shell script的
方式由程序自行来检查指纹表是否相同),那么对于文件系统会比较安全。

例题：将/etc/{passwd,shadow,group}以及系统上面所有的SUID/SGID文件创建文件列表,文件列表名为"important.file"
      并通过该文件列表,以md5.checkfile.sh的文件名去新建指纹码,并将该指纹码文件"finger1.file"设置为不可修改
      的属性,通过相同的机制去新建后续的分析数据为空finger_new.file，并将两者进行比较,若有问题则提供email
      给root查阅。
步骤: 1.# ls /etc/{pass,shadow,group} >important.file
      2.# find /bin /sbin /user/sbin /user/bin -perm +6000 >>important.file
      3.# vim md5.checkfile.sh
        #!/bin/bash
        for filename in $ (cat important.file)
        do 
          md5sum $filename >> finger1.file
        done
      4.# sh md5.checkfile.sh
      5.# chattr +i finger1.file
      6.# vim md5.checkfile.sh
        #!/bin/bash
        if [ "$1" == "new" ] ; then
           for filename in $ (cat important.file)
           do 
	     md5sum $filename >> finger1.file
           done
 	   echo "new file finger1.file is created ."
           exit 0
        fi [ ! -f finger1.file ] ; then
           echo "file: finger1.file NOT exist ."
           exit1 
        fi 
        [ -f finger_new.file ] && rm finger_new.file
        for filename in $(cat important.file)
        do 
           md5sum $filename >> finger_new.file
        done
        testing=$(diff finger1.file finger_new.file)
        if [ "$testing" != "" ] ; then
           diff finger1.file finger_new.file | mail -s 'finger trouble..' root
        fi    
      7.#vim /etc/crontab
        30 2 * * * root cd /root; sh md5.checkfile.sh

************************************第23章 软件安装:RPM、SRPM与YUM功能*********************************************
利用厂商发布的Tarball来进行软件的安装每次安装都需要检测操作系统与环境、设置编译参数、实际的编译,最后还需要
依据个人喜好的方式来安装软件到定位。这个过程太麻烦了。那么如果我的Linux系统和厂商的系统一模一样,那么在厂商
系统上面编译出来的可执行文件自然也可以在我系统上面跑,所以厂商将这个编译好可直接执行的软件发布给用户来安装
如同Windows的安装方式,由程序开发者直接在已知的系统上面编译好,再将程序直接给用户安装此称为软件管理器,常见的
两大主流软件管理器有RPM与DPKG。

RPM类型的软件中,所有的软件时经过编译的二进制程序，所以可以直接安装在用户端的系统上,SRPM内含的文件为源代码
而非为二进制文件,所以安装SRPM时还需要经过编译,不过SRPM优点是可以让用户自行修改设置参数。
SRPM 它是Source RPM的意思，也就是RPM文件里面含有的源代码。通常扩展名为***.src.rpm这种格式来命名。
 如果我们下载的是SRPM,那么安装该软件时,你必须要:
 0.修改SRPM内的参数设置文件(需要时进行)；
 1.先将该软件以RPM管理的方式编译,此时SRPM会被编译成RPM文件；
 2.然后将编译完成的RPM文件安装到Linux系统当中；

系统版本: 软件名称-软件的版本信息-发布的次数.适合的硬件平台.扩展名
      例: rp-pppoe-3.1           -5         .i386          .rpm

CentOS先将发布的软件放置到YUM服务器内,然后分析这些软件的依赖属性问题,将软件内的记录信息写下来(header),
然后再将这些信息分析后记录成软件相关性的清单列表。这些列表数据与软件所在的位置可以称为容器(repository)。
其在YUM服务器内,是一个网址类似于http://mirrors.163.com/centos/7/os/x86_64/Packages/

yum设置文件内的容器设置(/etc/yum.repos.d/*.repo)

RPM软件管理程序: rpm
RPM默认安装的路径: /var/lib/rpm/ 里面记录了软件的版本、名称、文件与目录配置、系统需求等
RPM安装(install) ：rpm -ivh package_name  
-i:install的意思 -v:查看更详细的安装信息画面 -h:以安装信息栏显示安装进度
其他可执行参数: --nodeps ：当发生软件属性依赖问题而无法安装,当你执意强制安装时。
                --replacefiles ：已经安装或者版本不和时,覆盖之前文件。
                --replacepkgs ：重新安装某个已经安装过的软件。
                --test ：测试一下软件是否可以被安装到用户的Linux环境中,可找出是否有属性依赖的问题。
                ...
RPM查询(query)
rpm -qa                             <==已安装软件 /    rpm -q[licdR] 已安装软件名       <==已安装软件
rpm -qf 存在于系统上面的某个文件名  <==已安装软件 / rpm -qp[licdR] 未安装的某个文件名称 <==查阅RPM文件
 参数:
 查询已安装软件的信息:
 -q:仅查询,后面接的软件名称是否有安装 / -qa:列出所有的已安装在本机Linux系统上面的所有软件名称
 -qi:列出该软件的详细信息  / -ql:列出该软件所有的文件与目录所在完整文件名 / -qc:列出该软件的所有配置信息
 -qd:列出该软件的所有帮助文件 / -qR:列出与该软件有关的依赖软件所含的文件 / -qf:由后面接的文件名称找出该文件属于那一个已安装软件
 查询某个RPM文件含有的信息:
 -qp[icdlR]:与上基本一致,但用途仅在于找出某个RPM文件内的信息,而非已安装的软件信息。

RPM验证与数字证书（Verify/Signature）
 验证的功能主要在于提供系统管路员一个有用的管理机制,其作用的方式是使用/var/lib/rpm下面的数据库内容来比较
 目前Linux系统的环境下的所有软件文件,也就是说,当你有数据不小心丢失,被修改就用这个简单方法验证原来的文件系
 统。好让你了解这一阵子到底是修改到哪些文件数据了！
  rpm -Va / rpm -V 已安装的软件名称 / rpm -Vp 某个RPM文件的文件名 / rpm -Vf 在系统上面的某个文件
  -Va:列出目前系统上面所有可能被修改过的文件； -Vp:列出该软件内可能被改动的文件 / -Vf:列出某个文件是否被改动过
 [文件容量][文件类型、属性][MD5指纹码][设备的代码][Link路径][文件的所有者][文件的所属用户组][文件的创建时间]
 上面显示哪个数据代表哪个数据被改变了；
 数字证书(digital signature)
 当你要安装一个RPM文件时:
 1.首先你必须要安装原厂发布的公钥文件；
 2.实际安装原厂的RPM软件时,rpm命令会去读取RPM文件的证书信息,与本机系统内的证书信息比较；
 3.若证书相同则予以安装,若找不到相关的证书信息时,则给予警告并且停止安装；
 CentOS的数字证书位于:/etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5

卸载RPM与重建数据库(erase/rebuilddb)
rpm --rebuilddb <==重建数据库

SRPM的使用:rpmbuild
1.利用默认值安装SRPM文件(--rebuild/--recompile)
  --rebuild:这个选项会将后面的SPRM进行编译与打包的操作,最后会生成RPM的文件,但是产生的RPM文件并没有安装
            带系统上。你需要将RPM安装时,请加绝对路径来安装。
  --recompile:这个动作会直接编译、打包并且安装。与rebuild不同,其只进行了编译并打包,而recompile在此基础上
              还进行了打包。
2.SRPM使用的路径与需要的软件
  /user/src/redhat/SPECS ：这个目录放置的是该软件的设置文件,例如这个软件的信息参数、设置项目等
  /user/src/redhat/SOURCES ：这个目录放置的是该软件的源文件(*.tar.gz的文件)以及config这个设置文件
  /user/src/redhat/BUILD ：编译的过程中,有些暂存的数据会放置在这个目录当中
  /user/src/redhat/RPMS ：经过编译后,并且顺利编译成功之后,将打包完成的文件放置在这个目录当中。
  /user/src/redhat/SRPMS ：与RPMS内相似,这里放置的就是SRPM封装的文件。
3.设置文件的主要内容(*.spec)
  rpm -i XX.rpm安装软件包,切换至cd /user/src/redhat/SPECS目录,编辑vi xxx.spec文件。
  注意到的是xxx.sepcpec这个文件,这里主要是将SPRM编译成RPM的设置文件,它的基本规则可以这样看:
  1.整个文件的开头以Summary为开始,这部分的设置都是最基础的说明内容；
  2.然后每个不同的段落之间都以%来作为开头,例如%prep与%install等；
  系统整体信息方面:
  Summary ：本软件的主要说明
  BuildRoot ：设置作为编译时,该使用哪个目录来临时存放中间文件(如编译过程的目标文件/链接文件等)
  Requires ：如果你这个软件还需要其他的软件的支持,那么这里就必须写上来,则当你制作成RPM之后,系统就会自动
             去检查。这就是"依赖属性"的主要来源。
  根据上面的设置,最终的文件名就是"{Name}-{Version}-{Release}.{ExclusiveArch}.rpm"的样子。
  %description:将你的软件做一个简短的说明。
  %prep:尚未进行设置或安装之前你需要编译完成的RPM帮你事先做的事情,就是prepare的缩写,它的工作事项主要有:
        1.进行软件的补丁(patch)等相关工作；
        2.寻找软件所需的目录是否已经存在,确定用的；
        3.事先新建你的软件所需目录,或者事先需要进行的任务；
        4.如果带安装的Linux系统内已经安装的时候可能会被覆盖掉的文件时,那么就需要进行备份(backup)的工作了；
  %setup:这个选项就是在进行类似解压缩之类的工作。这个选项一定要写。不然你的taball源代码是无法解压缩的；
  %build:这个段落就是在谈怎么编译成为可执行的程序。这部分的程序代码方面就是./configure、make等选项；
  %install:编译完成就是安装。安装就是写在这里,也就是类似Tarball里面的makeinstall的意思；
  %clean:编译与安装完毕后,必须要将一些暂存在BuildRoot内的数据删除才好。这有点像make clean的感觉；
  %file:这个软件安装的文件都需要写到这里来,当然包括了"目录"。
  %changelog:这个选项主要则是记录这个软件曾经的更新记录。*星号后面应该要以时间、修改者、email与软件版本
             来作说明,-减号后面则是你要做的详细说明；
4.SRPM的编译命令(-ba/-bb)
  要将在/user/src/redhat下面的数据编译或者是单纯打包成为RPM或SRPM时,就需要rpmbuild命令与相关选项的帮忙了!
  rpmbuild -ba XXX.spec <==编译并同时生成RPM与SRPM文件
  rpmbuild -bb XXX.spec <==仅编译成RPM文件
  这个时候系统就会这样做:
  1.先进入到BUILD这个目录,即/user/src/redhat/BUILD这个目录；	
  2.依据*.spec文件内的Name与Version定义出工作的目录名称,以我们上面例子为例,那么系统就会在BUID目录先删除
    xxx-x.x的目录，再重新建立一个xxx-x.x的目录,并进入这个目录；
  3.在新建的目录里面,针对SOURCES目录下面的源文件,也就是*.spec里面的Source设置的那个文件,以tar进行解压缩；
  4.再来开始%build及%install的设置与编译；
  5.最后将完成打包的文件放置到该放置的地方去；
5.一个打包自己软件的范例
  制作源代码文件tarball生成:将xx.tgz放置在/root下面,并且在/user/local/src下面新建一个目录进行解压。cd切换
                            到新建目录,新建源代码所需的make规则(vim Makefile)，cd ..切换到上层目录,将新建
                            目录打包tar到上层目录,并将其cp复制到/user/src/redhat/SOURCES。
  新建*.spec的设置文件:cd切换到/user/src/redhat/SPECS，编辑 vim main.spec
  编译成为RPM与SRPM:rpmbuild -ba main.spec
  安装/测试/实际查询:rpm -ivh /user/src/redhat/RPMS/xxx/xxx.rpm
                     rpm -ql main
                     rpm -qi main

YUM在线升级机制
1.利用yum进行查询、安装、升级与删除功能
  查询功能:yum [list|info|search|provides|whatprovides] 参数
           yum [option] [查询工作项目] [相关参数]
  安装/升级功能:yum [install|update] 软件
                yum [option] [查询工作项目] [相关参数]
  删除功能:yum [remove] 软件
2.yum的设置文件
  repodata目录:分析RPM软件后所产生的软件属性依赖数据放置处。

  vi /etc/yum.repos.d/xxx.repo 设置容器的网站
  [容器名]
  name=：只是说明一下这个容器的意义。
  mirrorlist=：列出这个容器可以使用的镜像站点,可以不使用。
  baseurl=：容器的实际网址。mirrorlist是由yum程序自行去找镜像站点,baseurl则是指向固定的一个容器网址。
  enable=1：就是让这个容器被启动。
  gpgcheck=1：指定是否需要查阅RPM文件内的数字证书。
  gpgkey=：就是数字证书的公钥文件所在位置。使用默认值即可。

  修改容器产生的问题与解决之道:yum clean [package|headers|all] 清除本机上面的旧数据
3.yum的软件组功能
  yum [组功能] [软件组] 
  参数:grouplist-列出所有可用的组列表；  groupinfo-后面接group name,则可以了解group内含的所有组名称；
       groupinstall-安装一整组软件；     groupremove-移除某个组；
4.全系统自动安装
  yum -y update 如果需要每天检查自动升级 vim /etc/crontab  0 3 * * * root /user/bin/yum -y -update
  此外你还得分析登录文件与收集root的信件的,因为如果升级的是内核软件(kernel),那么你还是得要重新开机才会
  让系统的软件顺利进行。所以还是得分析日志文件,若有新内核安装,就重新开机,否则就让系统自动维持在最新较安全的环境吧。
5.管理的抉择:RPM还是Tarball
  1.优先选择原厂的RPM功能；
  2.选择软件官网发布的RPM或者是提供的容器网址；
  3.利用Tarball来安装特殊软件；
  4.用Tarball测试新版软件；

****************************************第24章 X Windows设置介绍**************************************************************************
1.主要组件:X Server/X Client/Windows Manager/Display Manager
  X Server:硬件管路、屏幕绘制与提供字体功能
  X Client:负责X Server要求的"事件"的处理
  X Windows Manager:特殊的X Client,负责管理所有的X Client软件。类型有KDE、GNOME、SFCE还有twm等。
  Display Manager:提供登录需求

2.X Windows的启动流程
 1.在文字界面启动X : 通过startx命令
   startx [X client 参数] -- [X server 参数]
 
 2.startx最重要的任务是找出用户或者系统默认的X Servr/X Client的设置文件,而用户也可以使用startx外接参数来取
  代设置文件内容。事实上启动X的是xinit这支程序,startx仅是帮忙找出设置值而已！那么startx找到的设置值可用顺
  序是什么呢？
  X Server的参数方面:1.使用startx 后面接的参数；
                     2.若无参数,则查找用户根目录的文件,亦即~/.xserverrc；
                     3.若无上述两者,则以/etc/X11/xinit/xserverrc；
                     4.若无上述三者,则单纯执行/user/bin/X(此即X server可执行文件)；
  X Client的参数方面:1.使用startx 后面接的参数；
                     2.若无参数,则查找用户主文件夹的文件,亦即~/.xinitrc；
                     3.若无上述两者,则使用/etc/X11/xinit/xinitrc；
                     4.若无上述三者,则单纯执行xterm(此即X下面的终端机软件)；

 3.由startx调用执行的xinit:实际上,当startx找到需要的设置值后,就调用xinit实际启动X的。
                          xinit [client option] -- [server or display option]
  那么为什么不直接执行xinit而使用startx来调用xinit呢？这是因为我们必须要取得一些参数！start可以帮我们快速
  找到这些参数而不必手动输入。

 4.启动X Server的文件:xserverrc-在启动X Server时,Xorg会去读取/etc/X11/xorg.conf这个设置文件。<===========
   事实上我们的Linux可以同时启动多个X。各个X显示的位置使用-display来处理,显示位置为:0、:1等；
   第一个X的界面是:0即是tty7,第二个X则是:1即是tty8。                                         <===============
   启动了X Server后,接下来就是加载X Client到这个X Server上面

 5.启动X Client的文件:xinitrc 
   最终在X Client文件当中会有两个命令的查询,包括startkde与gnome-session这两个,这也是CentOS默认会提供的两
   个主要的Window Manager。而你也可以通过修改/etc/sysconfig/desktop内的DESKTOP=GNOME或DESKTOP=KDE来决定
   默认使用哪个窗口管理器。如果你没有安装这两个,那么X就会去使用twm这个窗口管理器来管理你的环境。

   另外,如果有特殊需求,你当然可以自定义X Client的参数！这就得要修改你的主文件夹下的~/.xinitrc。不过要注意
   如果你的..xinitrc设置文件里面有启动的X Client很多的时候,千万注意将除了最后一个Window Manager或X Client
   之外,都放在后台里面去执行(后面加&)。

 6.无论怎么说,鸟哥还是希望大家通过解析startx这个script的内容去找到每个文件,再根据分析每个文件来找到你distrubutions
   上面的X相关文件。另外需要注意的是,如果你的.xinitrc设置文件里面有启动X client很多的时候,千万注意将除了
   最后一个Window Manger或X Client之外,都放到后台里面去执行(方法是在最后面加上&)。

 7.X启动的端口:在X Window System的环境下,我们称port 6000为第0个显示接口,也即hostname:0,那个主机名通常可以
               不写,所以就成了:0即可。在通常情况下,第一个启动的X(无论是启动在第几个port number)是在tty 7，
               亦即按下[ctrl]+[alt]+[F7]那个界面,而启动的第二个X(注意到了,可以有多个X同时启动在你的系统)，
               默认在tty8。

3.X启动流程测试

4.我是否需要启用X Window System
  X Window仅是Linux上面的一个软件，鸟哥不建议对Internet开放的服务器启动X Window的。

5.X Server设置文件解析与设置
  X Server的设置文件都是默认放置在/etc/X11目录下,而相关的显示模板或上面提到的显示模板则主要放置在/usr/lib/xorg/modules下面。
  比较重要的是字体文件与芯片组:提供的屏幕字体(/user/share/X11/fonts/)、显卡的芯片组(/user/lib/xorg/modules/drivers/)

6.解析xrog.conf设置
  本书使用的测试机使用的X Server是Xorg基金会提供的X11R7版,因为是Xorg这个X Server,因此我们的设置文件名为/etc/X11/xorg.conf
  X version查看X Server版本；注意在修改这个文件之前,务必备份一份,防止导致X Server无法启动。
  内容: Section "section name"
        ...     <===与这个section name有关的设置值
        ...     
        EndSection
  至于常见的section name主要有:
  Moudule:被加载到X Server当中的模块(某些功能的驱动程序)
  InputDevice:包括输入的键盘的格式、鼠标的格式、以及其他相关输入设备
  Files:设置字体所在的目录位置等
  Monitor:监视器的格式,主要是设置水平、垂直的更新频率，与硬件有关
  Device:这个重要，就是显卡芯片组的相关设置
  Screen:这个是在屏幕上显示的相关分辨率与色彩深度的设置项目，与显示的行为有关
  ServerLayout:上述的每个选项都可以重复设置,这里则是此X Server要选用的那个选项值的设置

7.X Font Server(XFS)与加入其它中文字体
  这个XFS的主设置文件在/etc/X11/fs/config中,而字体文件则在/usr/share/X11/fonts/中,字型一般放置在/usr/lib/xorg/modules/fonts/当中
  至于启动的脚本则在/etc/init.d/xfs中。
  mkfontdir 这个命令生成font.dir这个文件,提供字体文件目录的说明
  chkfontpath 查看xfs支持的目录                  |          xlsofnts 在X Window下面启动终端机
  fc-cache -f -c 将上诉字体加入字体的支持        |          fc-list 列出已被使用的字体文件

8.设置文件重建与显示器参数微调
 1.Xorg -configure :1 使用Xorg重新制作出设置文件
   此时X会主动以内置的模块进行系统硬件的探索,并将将硬件与字体检测结果写入/root/xorg.conf.new这个文件里面去
   这就是xorg.conf的重置结果。不过这个新建的文件不见得真的能够启动X Server,所以我们需要测试。
   X -config /root/xorg.conf.new :1  测试上面新的设置文件能否顺利运行
 2.关于屏幕分辨率与更新率
   gtf 水平像素 垂直像素 更新频率 [-xv]
   -x:使用xorg设置文件的模式输出,这是默认值；    |          -v:显示检测结果
   更改后记得将数据写入xorg..conf内的Monitor项目中。

9.显卡驱动程序安装范例
  
***************************************第25章 Linux 备份策略*********************************************************

1.备份哪些Linux数据
  具有备份意义的文件通常可以粗分为两大类,一类是系统基本设置信息,一类则是类似网络服务的内部数据。

  1.操作系统本身需要备份的文件
    这方面的文件主要跟账号与配置文件有关系。/etc/passwd、/etc/shadow、/etc/group、/etc/gshadow、/home下面
    的用户文件夹等,而由于Linux默认的重要参数文件都在/etc/下面,所以只要将这个目录备份下来啊的话,那么几乎所有的配置文件都可以被保存的！
    至于/home目录是一般用户的文件夹,自然也需要备份！如果你曾经修改过内核,那么/boost里面的信息也很重要。
    所以以下目录:/etc/整个目录、/home 整个目录、/var/spool/mail、/boot、/root,以及如果你自行安装过其他软件
                 那么/usr/local或/opt也最好备份以下。
  2.网络服务的数据库方面
    如果你的网络配置文件安装都是以原厂提供的为主,那么你的配置文件大多是在/etc下面,但如果你的套件大多是来自
    自行的安装,那么/usr/local这个目录就相当重要了。
    假设我们提供的服务软件都是使用原厂的RPM安装的,所以需要备份的数据文件有:
     1.软件本身的配置文件,例如:/etc/整个目录,/usr/local/整个目录；
     2.软件服务器提供的数据,以WWW及MYSQL为例: WWW数据:/var/www 整个目录或/src/www 整个目录、及系统的用户主文件夹
                                              MySQL  :/var/lib/mysql 整个目录
  3.推荐需要备份的目录:/boot、/etc、/home、/root、/us/local(或者/opt及/srv等)、/var 。                                   
  4.不需要备份的目录:/dev、/proc、/mnt与/media、/tmp 。    
  5.选择备份设备

2.备份的种类、频率与工具的选择
  1.完整备份的增量备份:与在完整备份基础上的上一次备份进行比较
    完整备份的常用工具有dd,cpio,dump/restore等。dd可以直接读取磁盘的扇区(sector)而不理会文件系统,不过缺点
    是很慢。cpio是能够备份所有的文件名,不过要配合find或其他找文件名的命令才能够处理得当。以上两个都能够进
    行完整备份,但增量备份就得额外使用脚本程序来处理。也可以直接进行增量备份的就是dump这个命令咯!
  
  2.完整备份的差异备份:与原始的完整备份进行比较
    rsync进行镜像备份。这个rsync可以对两个目录进行镜像,其简单的语法为: rsync -av 源目录 目标目录
  
  3.关键数据备份
    例：依据日期来备份mysql的数据库 tar -jpcvf mysql.`date +%Y-%m-%d`.tar.bz2 /var/lib/mysql
   
    备份是非常重要的工作,如果我们需要自动备份的话,需要自己编写script,配合crontab去执行！

3.鸟哥的备份策略
  1.每周系统备份的script
    包括/home,/var,/etc,/boot,/usr/local等目录与特殊服务的目录；
    http://linux.vbird.org/linux_basic/0580backup/backupwk-0.1.sh
  2.每日备份数据的script
    目前仅备份MySQL数据库
    http://linux.vbird.org/linux_basic/0580backup/backupday.sh
  3.将script加入crontab自动处理
    vi /etc/crontab
    30 3 * * 0 root /back/backupwk-0.1.sh
    30 2 * * 0 root /back/backupday.sh
  4.远程备份的script
     1.使用FTP上传备份数据
     2.使用rsync上传备份数据  

4.灾难恢复的考虑 

************************************第26章 Linux内核编译与管理**************************************************************

1.编译前的任务:认识内核与取得内核源码
  1.什么是内核(Kernel)
    内核就是系统上面的一个文件而已,这个文件包含了驱动主机各项硬件的检测程序与驱动模块。
    内核模块:现在硬件更新速度太快,如果我内核比较旧,但我换了新硬件,需要重新编译一个内核吗？因此,Linux早就
             开始使用所谓的模块化设置了！即是将一些不常用的类似驱动程序的内容独立出内核,编译成模块,然后
             内核可以在系统正常运行的过程当中加载这个模块到内核的支持。如此我不需要改动内核只要编译适当
             内核模块并加载它,我的Linux就能使用这个硬件了。
    内核编译:内核由源代码编译而成!也就是说,我们必须要取得内核的源代码,然后利用Tarball安装方式提到的编译
             概念来实现内核的编译。
  
  2.更新内核的目的
  3.内核的版本
  4.内核源码的取得方式
  5.内核源代码的解压缩/安装/观察

2.内核编译的前处理与内核功能选择
  1.硬件环境查看与内核功能要求
  2.保持干净的源代码:make mrproper - 清理临时文件与设置文件。/
                                     这个操作会将你以前进行的内核功能选择文件也删除掉,所以几乎只有第一次
                                     执行内核编译前才进行这个操作,其余时刻,你想要删除前一次编译过程的残留
                                     数据,只要执行make clean。因为make clean仅会删除类似目标文件之类的编译
    				     过程生成的中间文件,而不会删除设置文件。
  3.开始挑选内核功能:make XXconfig
    内核功能列表文件:/boot/config-xxx
    make menuconfig：最常用,在文字模式下面显示类似图形界面的方式,不需要启动X Window就能够挑选内核功能菜单。
    make oldconfig：通过使用已存在的./config文件内容,使用该文件内的设置值为默认值,只将新版本内核内的新功能
                    选项列出让用户选择,可以简化内核功能的挑选过程。
    make xconfig：通过以Qt为图形界面基础功能的图形化界面显示,需要具有X Window的支持。
    make gconfig：通过以Gtk为图形接口基础功能的图形化界面显示,需要具有X Window的支持。
    make  config：最老式的功能挑选方式,每个选项都以条列式一条一条列出让你选择,如果设置错误只能再次选择,很不人性化。
    
    若为[*]、<*>则表示编译进内核；若为<M>则表示编译成模块。如果不知道该选项为何时,且有模块可以选,那么就直接
    选择为模块。  
    建议:"肯定"内核一定要的功能,直接编译进内核内；
         可能在将来会用到的功能,那么尽量编译成模块；
         不知道那个东西要干嘛,看帮助也看不懂的,那么就保留默认值,或者将它编译成模块；
  
  4.内核功能细项选择

3.内核的编译与安装
  1.编译内核与内核模块: 你可以先使用"make help"去查阅一下所有可用编译参数就会知道以下基本功能
                        make vmlinux <==为经压缩的内核     make modules <==仅内核模块
                        make bzImage <==仅压缩的内核(默认) make all     <==进行上述的三个操作

    bzImage可以制作出压缩后的内核,也就是一般我们拿来进行系统开机的信息。所以,基本上我们会进行的操作是:
            make clean <==先清除临时文件  make bzImage <==先编译内核  make modules <==再编译模块
    最后制作出来的数据是被放置在/usr/src/kernels/linux-2.6.30.3/这个目录下,还没有被放到系统的相关路径中。
  
  2.实际安装模块: 模块是放置到/lib/modules/$ (uname -r)目录下
                  安装模块 make modules_install
  
  3.开始安装新内核与多重内核菜单(grub)
    内核的安装过程中,需要移动bzImage文件、创建initrd文件、编辑/boot/grub/menu.lst等操作。
    现在我们知道内核文件放置在/usr/src/kernels/linux-2.6.30.3/arch/x86/boot/bzImage下,但是其实系统内核理论
    上都是摆在/boot下面且为vmlinuz开头的文件名。
    1.移动内核到/boot且保留旧内核文件
    2.新建相对应的Initial Ram Disk(initrd): mkinitrd -v/boot/initrd-2.6.30.3vbird.img 2.6.30.3vbird
    3.编辑开机菜单(grub): vim /boot/grub/menu.lst

4.额外(单一)内核模块编译
  1.编译前注意事项: 如果我们想要自行使用硬件开发商提供的模块来进行编译时,就需要使用到内核所提供的源文件
                    当中所谓的头文件(header include file)来取得驱动模块所要需要的一些函数库或头的定义。
   
   在2.6版本以后,内核使用比较有趣的方法来设计它的原代码放置文件目录,那就是/lib/modules/$(uname r)/build
   及/lib/modules/$(uname -r)/source这两个链接文件来指向正确的内核源代码放置目录。    
   
   其中modules.dep文件记录了内核模块的相依属性的地方,依据该文件,我们可以简单实用modprobe这个指令来加载
   模块。
   
   如果你想要在默认的内核下面添加模块的话,那么就得找到kernel对的SRPM文件了！安装该文件并且取得source code
   后,才能顺利编译。
  
 2.单一模块编译
   如果后来发现忘记加入某个功能了,那么如果你仅是重新编译模块的话,我们可以先到目前的内核源代码所在目录执行
   make menuconfig,然后将NTFS的选项设置成为模块,之后执行make fs/ntfs/,那么ntfs的模块(ntfs.ko)就会自动编译
   出来了！然后将该模块复制到/lib/modules/2.6.30.3vbird/kernel/fs/ntfs/目录下,再执行depmod -a,就可以在原来
   的内核下面新增某个想要加入的模块功能。

 3.内核模块管理

5.例题
  1.简要说明内核编译的步骤
    1.先下载核心原始码,可以从www.kernel.org或者是distributions的SRPM来着手；
    2.以下以Tarball来处理,解开原始码到/usr/src/kernel目录下；
    3.先进行旧资料删除的动作:[make mrproper]；
    4.开始挑选核心功能,可以利用[make menuconfig]、[make oldconfig]、[make gconfig]等；
    5.清除过去的中间暂存挡资料:[make clean]；
    6.开始核心文件与核心模块的编译:[make bzImage]、[make modules]；
    7.开始核心模块的安装:[make modules_install]；
    8.开始核心文件的安装,可以使用的方式有[make install]或者通过手动的方式复制核心文件到/boot/grub当中；
    9.建立initrd档案；
   10.修改/boot/grub/menu.lst档案；
>>>>>>> temp
